<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Konzepte und Konventionen | AutoHotkey v2</title>
<meta name="description" content="Erfahren Sie mehr über einige allgemeine Konzepte und Konventionen, die von AutoHotkey verwendet werden, wobei der Schwerpunkt eher auf Erklärungen als auf Code liegt." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
</head>
<body>
<h1>Konzepte und Konventionen</h1>
<p>Dieses Dokument behandelt einige allgemeine Konzepte und Konventionen, die von AutoHotkey verwendet werden, wobei der Schwerpunkt eher auf Erklärungen als auf Code liegt. Es wird nicht davon ausgegangen, dass der Leser über Vorkenntnisse in Scripting oder Programmierung verfügt, aber er sollte für neue Fachbegriffe offen sein.</p>
<p>Genauere Informationen zur Syntax finden Sie unter <a href="Language.htm">Skriptsprache</a>.</p>

<h2>Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#values">Werte</a>
  <ul>
    <li><a href="#strings">Zeichenketten (Strings)</a></li>
    <li><a href="#numbers">Zahlen</a></li>
    <li><a href="#boolean">Boolesche Werte</a></li>
    <li><a href="#nothing">Nichts</a></li>
    <li><a href="#objects">Objekte</a></li>
    <li><a href="#object-protocol">Objektorientierte Schnittstelle</a></li>
  </ul></li>
  <li><a href="#variables">Variablen</a>
  <ul>
    <li><a href="#uninitialised-variables">Nicht initialisierte Variablen</a></li>
    <li><a href="#built-in-variables">Interne Variablen</a></li>
    <li><a href="#environment-variables">Umgebungsvariablen</a></li>
    <li><a href="#caching">Caching</a></li>
  </ul></li>
  <li><a href="#functions">Funktionen</a>
  <ul>
    <li><a href="#methods">Methoden</a></li>
  </ul></li>
  <li><a href="#control-flow">Ablaufsteuerung</a></li>
  <li><a href="#details">Details</a>
  <ul>
    <li><a href="#string-encoding">Zeichenkettencodierung</a></li>
    <li><a href="#pure-numbers">Reine Zahlen</a></li>
    <li><a href="#names">Namen</a></li>
    <li><a href="#variable-references">Variablenreferenzen vs. Werte</a></li>
    <li><a href="#references-to-objects">Objektreferenzen</a></li>
  </ul></li>
</ul><!-- TODO:
Scope/declarations
Technical terms: dynamic, default
Classes
Exception handling
-->


<h2 id="values">Werte</h2>
<p>Ein <em>Wert</em> repräsentiert eine einzelne Information innerhalb eines Programms. Zum Beispiel wäre das der Name einer zu sendenden Taste oder eines zu startenden Programms, die Anzahl der Tastendrücke, der Titel eines zu aktivierenden Fensters, oder was auch immer innerhalb des Programms oder Skripts eine Bedeutung hat.</p>
<p>AutoHotkey unterstützt folgende Typen von Werten:</p>
<ul>
  <li><a href="#strings">Zeichenketten</a> (Strings)</li>
  <li><a href="#numbers">Zahlen</a> (Integer und Floating-Point-Zahlen)</li>
  <li><a href="#objects">Objekte</a></li>
</ul>
<p>Mit der <a href="commands/Type.htm">Type</a>-Funktion kann der Typ eines Wertes festgestellt werden.</p>
<p>Einige andere verwandte Konzepte:</p>
<ul>
  <li><a href="#boolean">Boolesche Werte</a></li>
  <li><a href="#nothing">Nichts</a></li>
</ul>

<h3 id="strings">Zeichenketten (Strings)</h3>
<p>Eine <em>Zeichenkette</em> ist einfach nur Text. Jede Zeichenkette ist eigentlich eine Sequenz, Folge oder <em>Kette</em> von Zeichen. Sie kann aber auch als einzelne Entität gesehen werden. Die <em>Länge</em> einer Zeichenkette repräsentiert die Anzahl der Zeichen in der Sequenz, während die <em>Position</em> eines Zeichens innerhalb der Zeichenkette lediglich die fortlaufende Nummer dieses Zeichens ist. Gemäß der Konvention von AutoHotkey befindet sich das erste Zeichen auf Position 1.</p>
<p>Eine Kette von Zahlen (oder von anderen unterstützten <a href="#numbers">Zahlenformaten</a>) wird automatisch als Zahl interpretiert, wenn eine mathematische Operation oder ein Vergleich dies erfordert.</p>
<p>Wie literaler (direkt geschriebener) Text innerhalb des Skripts geschrieben werden soll, hängt vom Kontext ab. Zum Beispiel müssen in einem Ausdruck <a href="Language.htm#strings">Zeichenketten</a> in Anführungszeichen gesetzt werden. In Direktiven (mit Ausnahme von #If) und automatisch-ersetzenden Hotstrings werden Anführungszeichen nicht benötigt.</p>
<p>Eine genauere Erklärung der Funktionsweise von Zeichenketten finden Sie unter <a href="#string-encoding">Zeichenkettencodierung</a>.</p>

<h3 id="numbers">Zahlen</h3>
<p>AutoHotkey unterstützt folgende Zahlenformate:</p>
<ul>
  <li>Dezimale Integer (ganze Zahlen), wie z. B. <code>123</code>, <code>00123</code> oder <code>-1</code>.</li>
  <li>Hexadezimale Integer, wie z. B. <code>0x7B</code>, <code>0x007B</code> oder <code>-0x1</code>.</li>
  <li>Dezimale Floating-Point-Zahlen (Gleitkommazahlen), wie z. B. <code>3.14159</code>.</li>
</ul>
<p>Hexadezimale Zahlen müssen das <code>0x</code>- oder <code>0X</code>-Präfix verwenden, wenn nicht anders in der Dokumentation vermerkt. Dieses Präfix muss nach einem Vorzeichen wie <code>+</code> oder <code>-</code>, falls vorhanden, und vor führenden Nullen erfolgen. Zum Beispiel wäre <code>0x001</code> gültig, aber nicht <code>000x1</code>.</p>
<p>Zahlen, die mit einem Dezimalpunkt geschrieben werden, gelten immer als Floating-Point-Zahlen, auch wenn die Nachkommastelle eine Null ist. <code>42</code> und <code>42.0</code> beispielsweise sind in der Regel das gleiche, aber dies trifft nicht immer zu. Die wissenschaftliche Schreibweise wird ebenfalls erkannt (z. B. <code>1.0e4</code> und <code>-2.1E-4</code>), aber sie erzeugt immer eine Floating-Point-Zahl, egal ob ein Dezimalpunkt vorhanden ist oder nicht.</p>
<p>Das Dezimaltrennzeichen ist immer ein Punkt, auch wenn in den Ländereinstellungen des Benutzers ein Komma angegeben ist.</p>
<p id="number-default-format">Wenn eine Zahl in eine Zeichenkette umgewandelt wird, wird sie als Dezimalzahl formatiert. Floating-Point-Zahlen werden mit voller Präzision formatiert (wobei redundante, nachfolgende Nullen verworfen werden), was in manchen Fällen zu einer <a href="#float-imprecision">Ungenauigkeit</a> führen kann. Verwenden Sie die <a href="commands/Format.htm">Format</a>-Funktion, um eine numerische Zeichenkette in einem anderen Format zu erzeugen. Floating-Point-Zahlen können auch mit der <a href="commands/Math.htm#Round">Round</a>-Funktion formatiert werden.</p>
<p>Details über den Bereich und die Genauigkeit von numerischen Werten finden Sie unter <a href="#pure-numbers">Reine Zahlen</a>.</p>

<h3 id="boolean">Boolesche Werte</h3>
<p>Ein <em>boolescher</em> Wert kann entweder <em>True</em> (wahr) oder <em>False</em> (falsch) sein. Boolesche Werte werden genutzt, um etwas wiederzugeben, das exakt zwei mögliche Zustände hat, wie z. B. die <em>Wahrheit</em> eines Ausdrucks. Der Ausdruck <code>(x &lt;= y)</code> beispielsweise wäre <em>True</em> bzw. wahr, wenn x kleiner gleich y ist. Ein boolescher Wert könnte auch <em>Yes</em> oder <em>No</em>, <em>On</em> oder <em>Off</em>, <em>Down</em> oder <em>Up</em> (z. B. bei <a href="commands/GetKeyState.htm">GetKeyState</a>) und so weiter repräsentieren.</p>
<p>AutoHotkey hat keinen spezifischen booleschen Wertetyp, deshalb verwendet es den Integer-Wert <code>0</code> für False und <code>1</code> für True. Wenn ein Wert entweder True oder False sein muss, wird ein leerer Wert oder ein Wert von 0 als False und alle anderen Werte als True angesehen. (Objekte werden immer als True angesehen.)</p>
<p>Die Wörter <code>True</code> und <code>False</code> sind <a href="#built-in-variables">interne Variablen</a>, die 1 und 0 enthalten. Sie können verwendet werden, um ein Skript besser lesbar zu machen.</p>

<h3 id="nothing">Nichts</h3>
<p>AutoHotkey hat keinen Wert, der eindeutig <em>nichts</em>, <em>null</em>, <em>nil</em> oder <em>undefined</em> repräsentiert, wie es in anderen Sprachen der Fall ist. Stattdessen hat oft eine leere Zeichenkette (eine Zeichenkette mit einer Länge von 0) diese Bedeutung.</p>
<p>Wenn eine <a href="#variables">Variable</a> oder ein Parameter als "leer" bezeichnet wird, meint man damit in der Regel eine leere Zeichenkette (eine Zeichenkette mit einer Länge von 0).</p>

<h3 id="objects">Objekte</h3>
<p>Das <em>Objekt</em> ist der zusammengesetzte bzw. abstrakte Datentyp von AutoHotkey. Ein Objekt besteht aus beliebig vielen <em>Eigenschaften</em> (die abgerufen oder gesetzt werden können) und <a href="#methods"><em>Methoden</em></a> (die aufgerufen werden können). Der Name und Effekt jeder Eigenschaft oder Methode hängt vom jeweiligen Objekt oder Objekttyp ab.</p>
<p>Objekte haben die folgenden Attribute:</p>
<ul>
  <li>Objekte werden nicht gespeichert, sondern <a href="#references-to-objects">referenziert</a>. <code>alpha := []</code> beispielsweise erstellt ein neues <a href="objects/Array.htm">Array</a> und speichert eine Referenz in <em>alpha</em>. <code>bravo := alpha</code> kopiert die Referenz (nicht das Objekt) nach <code>bravo</code>, so dass beide auf das gleiche Objekt verweisen. Die Aussage, dass Arrays oder Variablen ein Objekt enthalten, bedeutet eigentlich, dass sie eine Referenz zum Objekt enthalten.</li>
  <li>Zwei Objektreferenzen werden nur als gleich angesehen, wenn sie auf das gleiche Objekt verweisen.</li>
  <li>Bei Anweisungen wie <code>if obj</code>, <code>!obj</code> oder <code>obj ? x : y</code> ist der boolesche Wert eines Objekts immer <i>True</i>.</li>
  <li>Jedes Objekt hat eine einzigartige Adresse (Position im Speicher), die via <a href="Variables.htm#amp">Adressoperator</a> abgerufen werden kann, aber normalerweise nicht direkt verwendet wird. Mit dieser Adresse ist das Objekt eindeutig identifizierbar, zumindest solange, bis das Objekt freigegeben wird.</li>
  <li>Ein Objekt wird normalerweise als leere Zeichenkette behandelt, wenn es in einem Kontext verwendet wird, wo ein Objekt nicht erwartet wird. Zum Beispiel würde <code>MsgBox(meinObjekt)</code> eine leere MsgBox anzeigen. Verlassen Sie sich nicht auf dieses Verhalten, weil es noch geändert werden könnte.</li>
</ul>
<p class="note"><strong>Hinweis:</strong> Alle Objekte, die von <a href="objects/Object.htm">Object</a> abgeleitet werden, haben zusätzliche Verhaltensweisen, Eigenschaften und Methoden.</p>
<p>Ein Objekt kann für folgende Dinge verwendet werden:</p>
<ul>
  <li>Um eine Sammlung von <em>Elementen</em> zu enthalten. Zum Beispiel enthält ein <a href="objects/Array.htm">Array</a> eine Reihe von Elementen, während ein <a href="objects/Map.htm">Map</a>-Objekt Keys mit Werten assoziiert. Objekte ermöglichen es, eine Gruppe von Werten als einen Wert zu behandeln, einer einzelnen Variable zuzuweisen, an eine Funktion zu übergeben oder von einer Funktion zurückzugeben, und so weiter.</li>
  <li>Um etwas in realer oder begrifflicher Form darzustellen. Zum Beispiel: eine Position auf dem Bildschirm, mit den Eigenschaften X und Y; ein Kontakt in einem Adressbuch, mit Name, Telefonnummer, EMailAdresse und so weiter. Objekte können genutzt werden, um komplexere Gruppen von Informationen darzustellen, indem sie mit anderen Objekten kombiniert werden.</li>
  <li>Um einen Dienst oder eine Reihe von Diensten zu bündeln, so dass sich andere Teile des Skripts auf eine Aufgabe konzentrieren können und nicht darauf, wie diese Aufgabe ausgeführt wird. Ein <a href="objects/File.htm">File</a>-Objekt bietet beispielsweise Methoden zum Lesen von Daten aus einer Datei oder zum Schreiben von Daten in eine Datei. Wenn eine Skriptfunktion, die Informationen in eine Datei schreibt, ein File-Objekt als Parameter akzeptiert, muss sie nicht wissen, wie die Datei geöffnet wurde. Die gleiche Funktion kann wiederverwendet werden, um Informationen in ein anderes Ziel zu schreiben, wie z. B. ein TCP/IP-Socket oder WebSocket (via benutzerdefinierte Objekte).</li>
  <li>Eine Kombination der oben genannten Punkte. Zum Beispiel ein <a href="objects/Gui.htm">Gui</a>-Objekt, das ein GUI-Fenster repräsentiert; es stellt die Mittel bereit, um eine grafische Benutzeroberfläche zu erstellen und anzuzeigen; es enthält eine Sammlung von Steuerelementen und bietet Informationen über das Fenster via Eigenschaften wie Title und FocusedCtrl.</li>
</ul>
<p>Die richtige Verwendung von Objekten (und insbesondere von <a href="Objects.htm#Custom_Classes">Klassen</a>) kann zu einem <em>modularen</em> und <em>wiederverwendbaren</em> Code verhelfen. Modularer Code ist in der Regel einfacher zu testen, zu verstehen und zu pflegen. So kann man z. B. einen Codeabschnitt verbessern oder modifizieren, ohne die Details anderer Abschnitte kennen zu müssen und ohne entsprechende Änderungen an diesen Abschnitten vornehmen zu müssen. Wiederverwendbarer Code spart Zeit, weil er das Schreiben und Testen von Code für gleiche oder ähnliche Aufgaben überflüssig macht.</p>

<h3 id="object-protocol">Objektorientierte Schnittstelle</h3>
<p class="note">Dieser Abschnitt baut auf folgenden Konzepten auf, die in späteren Abschnitten behandelt werden: <a href="#variables">Variablen</a>, <a href="#functions">Funktionen</a></p>
<p>Objekte arbeiten nach dem Prinzip der <em>Meldungsübermittlung</em>. Sie wissen nicht, wo sich der Code oder die Variablen eines Objekts tatsächlich befinden, also müssen Sie eine Meldung an das Objekt übergeben, wie z. B. "gib mir <em>foo</em>" oder "gehe zu <em>bar</em>", und sich darauf verlassen, dass das Objekt auf die Meldung reagiert. Objekte in AutoHotkey unterstützen die folgenden grundlegenden Meldungen:</p>
<ul>
  <li><strong>Get</strong> - Abrufen einer Eigenschaft.</li>
  <li><strong>Set</strong> - Setzen einer Eigenschaft via <code>:=</code>.</li>
  <li><strong>Call</strong> - Aufrufen einer <a href="#methods">Methode</a> via <code>()</code>.</li>
</ul>
<p>Eine <em>Eigenschaft</em> ist ein Aspekt des Objekts, der gesetzt und/oder abgerufen werden kann. Zum Beispiel hat <a href="objects/Array.htm">Array</a> eine <a href="objects/Array.htm#Length">Length</a>-Eigenschaft, die die Anzahl der Elemente im Array widerspiegelt. Wenn Sie eine Eigenschaft definieren, kann ihr eine beliebige Bedeutung zugeschrieben werden. Grundsätzlich verhält sich eine Eigenschaft wie eine <a href="#variables">Variable</a>, aber ihr Wert kann beim Abrufen geändert und beim Setzen nirgendwo gespeichert werden.</p>
<p>Jede Meldung enthält Folgendes, das in der Regel beim <a href="#call">Aufrufen</a> der Eigenschaft oder Methode verwendet wird:</p>
<ul>
  <li>Der Name der Eigenschaft oder Methode.</li>
  <li>Keine oder mehr <a href="#parameters">Parameter</a>, die Einfluss darauf haben können, welche Aktion ausgeführt wird, wie ein Wert gespeichert wird oder welcher Wert zurückgegeben wird. Eine Eigenschaft kann beispielsweise einen Array-Index oder Key annehmen.</li>
</ul>
<p>Zum Beispiel:</p>
<pre>
meinObj.Methodenname(Param1)
Wert := meinObj.Eigenschaftsname[Param1]
</pre>
<p>Ein Objekt kann auch eine <em>Standard</em>-Eigenschaft haben; um diese aufzurufen, muss der Eigenschaftsname weggelassen und eckige Klammern verwendet werden. Zum Beispiel:</p>
<pre>Wert := meinObj[Param1]</pre>
<p>Im Allgemeinen hat <strong>Set</strong> die gleiche Bedeutung wie eine Zuweisung und verwendet daher den gleichen Operator:</p>
<pre>
meinObj.Name := Wert
meinObj.Name[Param1, Param2, ..., ParamN] := Wert
meinObj[Param1, Param2, ..., ParamN] := Wert
</pre>

<h2 id="variables">Variablen</h2>
<p>Eine Variable ermöglicht es Ihnen, einen Namen als Platzhalter für einen Wert zu verwenden. Diesen Wert können Sie jederzeit ändern, während das Skript läuft. Ein Hotkey könnte z. B. eine Variable <code>press_count</code> verwenden, um zu zählen, wie oft er gedrückt wurde, und jedes Mal eine andere Taste senden, wenn <code>press_count</code> ein Vielfaches von 3 ist (jeder dritte Tastendruck). Auch eine Variable, der nur einmal ein Wert zugewiesen wird, kann nützlich sein. Zum Beispiel können Sie die Variable <code>WebBrowserTitle</code> nutzen, um die Aktualisierung Ihres Codes zu erleichtern, wenn Sie Ihren bevorzugten Webbrowser ändern oder wenn sich der <a href="misc/WinTitle.htm">Titel</a> oder die <a href="misc/WinTitle.htm#ahk_class">Fensterklasse</a> durch ein Software-Update ändert.</p>
<p>In AutoHotkey werden Variablen erstellt, sobald man sie verwendet. Jede Variable ist <em>nicht</em> permanent auf einen einzelnen <a href="#values">Datentyp</a> beschränkt, sondern kann stattdessen einen Wert beliebigen Typs enthalten: Zeichenkette, Zahl oder Objekt. Jede Variable ist zu Beginn leer; das heißt, dass jede neu erstellte Variable eine leere Zeichenkette enthält, bis ihr ein anderer Wert zugewiesen wird.</p>
<p>Eine Variable hat drei Hauptaspekte:</p>
<ul>
  <li>Der <em>Name</em> der Variable.</li>
  <li>Die Variable selbst.</li>
  <li>Der <em>Wert</em> der Variable.</li>
</ul>
<p>Einem Variablennamen sind Beschränkungen auferlegt - siehe <a href="#names">Namen</a> für Details. Kurz gesagt, es ist am sichersten, sich an Namen zu halten, die aus ASCII-Buchstaben (nicht Groß-/Kleinschreibung-sensitiv), Ziffern und Unterstrichen bestehen, und Namen zu vermeiden, die mit einer Ziffer beginnen.</p>
<p>Ein Variablenname hat einen <strong><em>Gültigkeitsbereich</em></strong>, der definiert, wo im Code dieser Name genutzt werden kann, um auf diese bestimmte Variable zu verweisen; mit anderen Worten, wo die Variable <em>sichtbar</em> ist. Wenn eine Variable innerhalb eines bestimmten Gültigkeitsbereichs nicht sichtbar ist, kann derselbe Name auf eine andere Variable verweisen. Beide Variablen können zur gleichen Zeit existieren, aber nur eine ist für jeden Teil des Skripts sichtbar. <a href="Functions.htm#Global">Globale Variablen</a> sind im "globalen Bereich" (also außerhalb von Funktionen) sichtbar, die aber in der Regel <a href="Functions.htm#Global">deklariert</a> werden müssen, um sie innerhalb einer Funktion sichtbar zu machen. <a href="Functions.htm#Local">Lokale Variablen</a> sind nur innerhalb der Funktion sichtbar, die sie erzeugt hat.</p>
<p>Eine Variable kann als Container oder Speicherort für einen Wert angesehen werden. In der Dokumentation werden Sie häufig darauf stoßen, dass der Wert einer Variable als <em>Inhalt der Variable</em> bezeichnet wird. Bei einer Variable <code>x := 42</code> kann man auch sagen, dass die Variable x die Zahl 42 als Wert hat, oder dass der Wert von x eine 42 ist.</p>
<p>Es ist wichtig zu wissen, dass eine Variable und ihr Wert nicht dasselbe sind. Zum Beispiel könnten wir sagen: "<code>meinArray</code> ist ein Array", aber was wir wirklich meinen ist, dass meinArray eine Variable ist, die eine Referenz zu einem Array enthält. Wir nehmen eine Abkürzung, indem wir den Namen der Variable verwenden, um auf ihren Wert zu verweisen, aber "meinArray" ist eigentlich nur der Name der Variable; das Array-Objekt weiß nicht, dass es einen Namen hat, und könnte von vielen verschiedenen Variablen (bzw. von vielen Namen) angesprochen werden.</p>

<h3 id="uninitialised-variables">Nicht initialisierte Variablen</h3>
<p>Eine Variable zu <em>initialisieren</em> bedeutet, ihr einen Startwert zuzuweisen. Obwohl das Programm automatisch alle Variablen initialisiert (standardmäßig mit einer leeren Zeichenkette), ist es empfehlenswert, dass ein Skript seine Variablen immer initialisiert, bevor sie eingesetzt werden. Auf diese Weise kann jeder, der das Skript liest, sehen, welche Variablen das Skript verwenden wird und welche Startwerte sie erwartungsgemäß haben werden.</p>
<p>Normalerweise ist es notwendig, dass das Skript jede Variable initialisiert, die eine Zahl enthalten soll. <code>x := x + 1</code> beispielsweise wird nicht funktionieren, wenn x noch nie einen Wert zugewiesen wurde, da die <em>leere Zeichenkette</em> als nicht-numerisch angesehen wird. Das Skript sollte ihr einen Startwert zuweisen, wie z. B. <code>x := 0</code>. Es gibt einige Fälle, wo leere Werte als 0 behandelt <em>werden</em>, aber es ist besser, sich nicht darauf zu verlassen.</p>
<p>Skript-Autoren können die <a href="commands/_Warn.htm">#Warn</a>-Direktive nutzen, um Instanzen zu finden, wo das Skript eine Variable noch nicht initialisiert hat. <a href="commands/IsSet.htm">IsSet</a> kann genutzt werden, um zu prüfen, ob eine Variable initialisiert wurde.</p>

<h3 id="built-in-variables">Interne Variablen</h3>
<p>Eine Vielzahl von Variablen ist fest in das Programm integriert und normal abrufbar. Solche Variablen sind schreibgeschützt, sofern nicht anders angegeben; das heißt, dass man ihren Inhalt nicht ändern kann. Gemäß der Konvention beginnen die meisten dieser Variablen mit dem Präfix <code>A_</code>, daher ist es am besten, dieses Präfix nicht für eigene Variablen zu verwenden.</p>
<p>Einige Variablen wie <a href="Variables.htm#KeyDelay">A_KeyDelay</a> und <a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a> spiegeln Einstellungen wider, die das Verhalten des Skripts steuern, und separate Werte für jeden <a href="misc/Threads.htm">Thread</a> aufbewahren. Dadurch können Subroutinen, die von neuen Threads gestartet werden (z.B. für Hotkeys, Menüs, Timer und so weiter), Einstellungen ändern, ohne andere Threads zu beeinflussen.</p>
<p>Einige spezielle Variablen werden nicht periodisch aktualisiert, sondern ihr Wert wird abgerufen oder berechnet, wenn das Skript auf die Variable verweist. Eine solche Variable ist zum Beispiel <a href="misc/Clipboard.htm">Clipboard</a>, die den aktuellen Inhalt der Zwischenablage abruft, oder <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a>, die die Anzahl der Millisekunden berechnet, die seit dem Drücken des Hotkeys vergangen sind.</p>
<p>Siehe auch: <a href="Variables.htm#BuiltIn">Liste von internen Variablen</a>.</p>

<h3 id="environment-variables">Umgebungsvariablen</h3>
<p>Umgebungsvariablen werden vom Betriebssystem verwaltet. Sie können sich eine Liste von Umgebungsvariablen anzeigen lassen, wenn Sie in der Windows-Konsole SET eingeben und ENTER drücken.</p>
<p>Mit <a href="commands/EnvSet.htm">EnvSet</a> kann eine neue Umgebungsvariable erstellt oder der Inhalt einer vorhandenen Umgebungsvariable geändert werden. Solche Ergänzungen und Änderungen sind nur für das Skript sichtbar und werden im restlichen System ignoriert. Allerdings erben alle Programme oder Skripte, die das Skript via <a href="commands/Run.htm">Run</a> oder <a href="commands/Run.htm">RunWait</a> startet, in der Regel eine Kopie der Umgebungsvariablen des übergeordneten Skripts.</p>
<p>Mit <a href="commands/EnvGet.htm">EnvGet</a> kann eine Umgebungsvariable abgerufen werden. Zum Beispiel:</p>
<pre>Pfad := EnvGet("PATH")</pre>

<h3 id="caching">Caching</h3>
<p>Obwohl eine Variable üblicherweise zum Speichern eines einzelnen Wertes gedacht ist, und dieser Wert einen bestimmten Typ (Zeichenkette, Zahl oder Objekt) hat, wandelt AutoHotkey automatisch zwischen Zahlen und Zeichenketten bei Fällen wie <code>"Wert ist " meineZahl</code> und <code>MsgBox meineZahl</code> um. Da solche Umwandlungen sehr häufig vorkommen können, wird jedes Mal, wenn eine Variable, die eine Zahl enthält, in eine Zeichenkette umgewandelt wird, das Ergebnis in der Variable <em>zwischengespeichert</em>.</p>
<p>Momentan wird AutoHotkey v2 eine reine Zahl nur zwischenspeichern, wenn eine reine Zahl in eine Variable gespeichert wird, nicht wenn sie gelesen wird. Dadurch bleibt die Möglichkeit erhalten, zwischen Zeichenketten und reinen Zahlen zu unterscheiden (z. B. bei der <a href="commands/Type.htm">Type</a>-Funktion oder bei der Übergabe von Werten an COM-Objekte).</p>

<h3>Siehe auch</h3>
<ul>
  <li><a href="Variables.htm#Intro">Variablen</a>: Grundlegende Verwendung und Beispiele.</li>
  <li><a href="Variables.htm#cap">Kapazität und Speicher einer Variable</a>: Einzelheiten über die Limitierungen.</li>
</ul>

<h2 id="functions">Funktionen</h2>
<p>Eine <em>Funktion</em> ist das Werkzeug des Skripts, um <em>etwas zu tun</em>.</p>
<p>Funktionen haben unterschiedliche Einsatzmöglichkeiten. Einige Funktionen führen lediglich eine einfache Berechnung durch, während andere sofort sichtbare Effekte erzielen, wie z. B. das Verschieben eines Fensters. Eine der Stärken von AutoHotkey ist die Leichtigkeit, mit der Skripte andere Programme automatisieren und viele andere häufige Aufgaben erledigen können, indem man einfach nur ein paar Funktionen aufruft. Beispiele finden Sie in der <a href="commands/index.htm">Funktionsliste</a>.</p>
<p>In dieser Dokumentation werden einige gebräuchliche Wörter auf eine Art und Weise verwendet, die für jemanden ohne Vorkenntnisse nicht offensichtlich ist. Nachfolgend finden Sie einige solcher Wörter/Phrasen, die häufig in Bezug auf Funktionen genutzt werden:</p>
<dl>
  <dt id="call">Eine Funktion aufrufen</dt>
  <dd><p>Der <em>Aufruf</em> einer Funktion veranlasst das Programm, diese Funktion zu starten, auszuführen oder auszuwerten. Das heißt, dass ein <em>Funktionsaufruf</em> die Kontrolle des Skripts vorübergehend an die Funktion übergibt. Wenn die Funktion ihren Zweck erfüllt hat, gibt sie die Kontrolle via <em>Return</em> wieder an das Skript zurück. Das heißt, dass jeglicher Code nach dem Funktionsaufruf erst ausgeführt wird, wenn die Funktion ihr Ende erreicht hat.</p>
  <p>Manchmal ist es jedoch so, dass eine Funktion abgeschlossen ist, bevor ihre Auswirkungen für den Benutzer sichtbar werden. Zum Beispiel könnte die <a href="commands/Send.htm">Send</a>-Funktion bereits ihre Tastendrücke <em>gesendet</em> haben, bevor sie überhaupt ihr Ziel erreicht und ihre gewollte Wirkung erzielt haben.</p></dd>
  <dt id="parameters">Parameter</dt>
  <dd><p>Normalerweise akzeptiert eine Funktion einen oder mehrere <em>Parameter</em>, die vorschreiben, wie oder womit sie agieren soll. Jeder Parameter ist ein <a href="#values">Wert</a>, z. B. eine Zeichenkette oder Zahl. Die Parameter von <a href="commands/WinMove.htm">WinMove</a> beispielsweise bestimmen, welches Fenster wohin verschoben werden soll.  Parameter werden auch als <em>Argumente</em> bezeichnet. Gängige Abkürzungen sind <em>Param</em> und <em>Arg</em>.</p></dd>
  <dt id="pass-parameters">Parameter übergeben</dt>
  <dd><p>Parameter werden an eine Funktion <em>übergeben</em>; das heißt, dass für jeden Parameter der Funktion beim Aufrufen ein Wert angegeben ist. Zum Beispiel kann man den Namen einer Taste an <a href="commands/GetKeyState.htm">GetKeyState</a> <em>übergeben</em>, um festzustellen, ob diese Taste gedrückt gehalten wird.</p></dd>
  <dt id="return-a-value">Einen Wert zurückgeben</dt>
  <dd><p>Funktionen geben ein Wert via <em>Return</em> zurück, deshalb wird das Ergebnis der Funktion oft als <em>Rückgabewert</em> bezeichnet. <a href="commands/StrLen.htm">StrLen</a> beispielsweise gibt die Anzahl der Zeichen zurück, die in einer Zeichenkette enthalten sind. Befehle geben ein Ergebnis nicht direkt zurück, sondern speichern das Ergebnis in eine <a href="#variables">Variable</a>. Funktionen können dies auch tun, wenn sie z. B. mehr als ein Ergebnis zurückgeben müssen.</p></dd>
  <dt id="command">Befehl</dt>
  <dd><p>Ein Funktionsaufruf wird manchmal auch als <em>Befehl</em> bezeichnet, weil quasi dem Programm <em>befohlen</em> wird, eine bestimmte Aktion auszuführen. (Aus historischen Gründen kann der Begriff <em>Befehl</em> auf eine bestimmte Form des Funktionsaufrufs bezogen werden, wo die Klammern weggelassen werden und der Rückgabewert verworfen wird. Aber technisch gesehen ist das eine <a href="Language.htm#function-call-statements">Funktionsaufrufanweisung</a>.)</p></dd>
</dl>
<p>Funktionen erwarten normalerweise, dass Parameter in einer bestimmten Reihenfolge geschrieben werden, deshalb ist die Bedeutung der einzelnen Parameterwerte abhängig von ihrer Position in der via Komma getrennten Parameterliste. Einige Parameter können weg bzw. leer gelassen werden - in diesem Fall aber kann das darauffolgende Komma nur weggelassen werden, wenn alle übrigen Parameter ebenfalls weggelassen werden. Die Syntax für <a href="commands/ControlSend.htm">ControlSend</a> lautet zum Beispiel:</p>
<pre class="Syntax"><span class="func">ControlSend</span> Tasten <span class="optional">, Steuerelement, Fenstertitel, Fenstertext, Titelausnahme, Textausnahme</span>
</pre>
<p>Die eckigen Klammern signalisieren, dass die darin enthaltenen Parameter optional sind (die Klammern selbst sollten nicht im eigentlichen Code erscheinen). In der Regel muss man aber auch das Zielfenster angeben. Zum Beispiel:</p>
<pre>
ControlSend "^{Home}", "Edit1", "A"  <em>; Korrekt. Steuerelement ist angegeben.</em>
ControlSend "^{Home}", "A"           <em>; Falsch: Parameter stimmen nicht überein.</em>
ControlSend "^{Home}",, "A"          <em>; Korrekt. Steuerelement wurde weggelassen.</em>
</pre>

<h3 id="methods">Methoden</h3>
<p>Eine <em>Methode</em> ist eine Funktion, die einem bestimmten <a href="#objects">Objekt</a> oder Objekttyp zugeordnet ist. Um eine Methode aufzurufen, muss man ein Objekt und einen Methodennamen angeben. Der Methodenname identifiziert die Funktion nicht eindeutig; es hängt vom Objekt ab, was beim Methodenaufruf passieren soll. Zum Beispiel könnte <code>x.Show()</code> <a href="objects/Menu.htm#Show">ein Menü anzeigen</a>, <a href="objects/Gui.htm#Show">eine GUI anzeigen</a>, einen Fehler auslösen oder etwas anderes tun, je nachdem, was <code>x</code> ist. Das heißt, dass ein Methodenaufruf einfach eine Meldung an das Objekt übergibt, damit es etwas tut. Weitere Informationen finden Sie unter <a href="#object-protocol">Objektorientierte Schnittstelle</a> und <a href="Language.htm#operators-for-objects">Operatoren für Objekte</a>.</p>

<h2 id="control-flow">Ablaufsteuerung</h2>
<p>Die <em>Ablaufsteuerung</em> ist die Reihenfolge, in der die einzelnen Anweisungen ausgeführt werden. Im Normalfall werden Anweisungen der Reihe nach von oben nach unten ausgeführt, allerdings kann dieses Verhalten mit einer Ablaufsteuerungsanweisung überschrieben werden, indem man Anweisungen z. B. wiederholt ausführen lässt, oder wenn eine bestimmte Bedingung erfüllt ist.</p>
<dl>
  <dt id="statement">Anweisung</dt>
  <dd><p>Eine <em>Anweisung</em> ist einfach gesagt das kleinste eigenständige Element der Sprache, das eine ausführende Aktion ausdrückt. In AutoHotkey sind Anweisungen Zuweisungen, Funktionsaufrufe und andere Ausdrücke. Direktiven, Label (einschließlich Hotkeys und Hotstrings) und Deklarationen ohne Zuweisungen sind hingegen keine Anweisungen; sie werden verarbeitet, sobald das Programm startet und bevor das Skript <em>ausgeführt</em> wird.</p></dd>
  <dt id="execute">Ausführen</dt>
  <dd><p>Ausführen, Durchführen, Auswerten, Umsetzen und so weiter. <em>Ausführen</em> hat grundsätzlich die gleiche Bedeutung wie im normalen Sprachgebrauch.</p></dd>
  <dt id="cf-body">Körper</dt>
  <dd><p>Der <em>Körper</em> einer Ablaufsteuerungsanweisung ist die Anweisung oder Anweisungsgruppe, zu der sie gehört. Zum Beispiel wird der Körper einer <a href="commands/If.htm">if-Anweisung</a> nur ausgeführt, wenn eine bestimmte Bedingung erfüllt ist.</p></dd>
</dl>
<p>Schauen Sie sich zum Beispiel die folgenden Instruktionen an:</p>
<ol>
  <li>Öffne Notepad</li>
  <li>Warte, bis Notepad auf dem Bildschirm erscheint</li>
  <li>Schreibe "Hallo, Welt!"</li>
</ol>
<p>Wir machen einen Schritt nach dem anderen, und wenn dieser Schritt beendet ist, gehen wir zum nächsten Schritt über. Auf die gleiche Weise funktioniert üblicherweise die Ablaufsteuerung in einem Programm oder Skript - sie geht die Anweisungen schrittweise durch. Aber was ist, wenn wir etwas in ein vorhandenes Notepad-Fenster schreiben wollen? Schauen Sie sich die folgenden überarbeiteten Instruktionen an:</p>
<ol>
  <li>Wenn Notepad nicht läuft:
<ol>
  <li>Öffne Notepad</li>
  <li>Warte, bis Notepad auf dem Bildschirm erscheint</li>
</ol>
</li>
  <li>Ansonsten:
<ol>
  <li>Aktiviere Notepad</li>
</ol>
</li>
  <li>Schreibe "Hallo, Welt!"</li>
</ol>
<p>Wir öffnen also entweder Notepad oder aktivieren Notepad, je nachdem, ob es bereits läuft. Punkt 1 ist eine <em>bedingte Anweisung</em>, auch bekannt als <em>if-Anweisung</em>; das heißt, dass wir ihren <em>Körper</em> (Punkt 1.1 bis Punkt 1.2) nur ausführen, wenn eine Bedingung erfüllt ist. Punkt 2 ist eine <em>else-Anweisung</em>; wir führen ihren Körper (Punkt 2.1) nur aus, wenn die Bedingung einer vorherigen <em>if-Anweisung</em> nicht erfüllt ist. Je nach Bedingung <em>läuft</em> die Steuerung auf zwei Arten ab: Punkt 1 (if true) → Punkt 1.1 → Punkt 1.2 → Punkt 3; oder Punkt 1 (if false) → Punkt 2 (else) → Punkt 2.1 → Punkt 3.</p>
<p>Die obigen Instruktionen können in den folgenden Code umgewandelt werden:</p>
<pre>if (not WinExist("ahk_class Notepad"))
{
    Run "Notepad"
    WinWait "ahk_class Notepad"
}
else
    WinActivate "ahk_class Notepad"
Send "Hallo, Welt!"
</pre>
<p>In unseren schriftlichen Instruktionen haben wir Einrückungen und Nummerierungen verwendet, um die Anweisungen zu gruppieren. Skripte funktionieren etwas anders. Obwohl die Einrückung den Code besser lesbar macht, hat sie in AutoHotkey keinen Einfluss auf die Gruppierung von Anweisungen. Stattdessen werden Anweisungen gruppiert, indem man sie, wie oben gezeigt, mit geschweiften Klammern umschließt. Dies wird als <a href="commands/Block.htm"><em>Block</em></a> bezeichnet.</p>
<p class="note">Details zur Syntax - also wie man Ablaufsteuerungsanweisungen in AutoHotkey schreibt oder erkennt - finden Sie unter <a href="Language.htm#control-flow">Ablaufsteuerung</a>.</p>

<h2 id="details">Details</h2>

<h3 id="string-encoding">Zeichenkettencodierung</h3>
<p>Jedes Zeichen in der Zeichenkette entspricht einer Zahl, auch <em>Ordinalzahl</em> genannt, oder einem <em>Zeichencode</em>. Der Wert "Abc" würde zum Beispiel wie folgt dargestellt werden:</p>
<table class="info" style="width: 8em; text-align: center">
  <tr><td>A</td><td>b</td><td>c</td></tr>
  <tr><td>65</td><td>98</td><td>99</td><td>0</td></tr>
</table>
<p><strong>Codierung:</strong> Die <em>Codierung</em> einer Zeichenkette definiert, wie Symbole mit den Ordinalzahlen und Ordinalzahlen mit den Bytes verknüpft werden. Es gibt viele verschiedene Codierungen, aber da alle Codierungen, die AutoHotkey unterstützt, ASCII als Untermenge enthalten, haben die Zeichencodes 0 bis 127 immer die gleiche Bedeutung. So hat zum Beispiel 'A' immer den Zeichencode 65.</p>
<p id="null-termination"><strong>Null-Terminierung:</strong> Jede Zeichenkette ist/wird mit einem "Nullzeichen" terminiert; solche Zeichen haben einen Binärwert von Null und markieren das Ende einer Zeichenkette. Die Länge der Zeichenkette muss nicht gespeichert werden, da die Länge anhand der Position des Null-Terminators abgeleitet werden kann. Aus Performance-Gründen speichert AutoHotkey manchmal die Länge, z. B. wenn eine Zeichenkette in einer Variable enthalten ist.</p>
<p class="warning"><strong>Hinweis:</strong> Aufgrund der Abhängigkeit von Null-Terminierung unterstützen viele interne Funktionen keine Zeichenketten mit eingebetteten Nullzeichen. Es wird jedoch eine grundlegende Manipulation solcher Zeichenketten unterstützt; z. B. Verkettung, <code>==</code>, <code>!==</code>, <code>Chr(0)</code>, <a href="commands/StrLen.htm">StrLen</a>, <a href="commands/SubStr.htm">SubStr</a>, Zuweisungen, Parameterwerte und <a href="commands/Return.htm">return</a>.</p>
<p id="native-encoding"><strong>Native Codierung:</strong> Obwohl AutoHotkey Möglichkeiten bereitstellt, Texte mit unterschiedlichen Codierungen zu bearbeiten, gehen die internen Funktionen -- und bis zu einem gewissen Grad auch die Sprache selbst -- davon aus, dass Zeichenkettenwerte in einer bestimmten Codierung vorliegen. Dies wird als <em>native</em> Codierung bezeichnet. Die native Kodierung hängt von der Version von AutoHotkey ab:</p>
<ul>
  <li>
<p>Unicode-Versionen von AutoHotkey verwenden UTF-16. Das kleinste Element in einer UTF-16-Zeichenkette ist zwei Bytes (16 Bit) groß. Unicode-Zeichen im Bereich von 0 bis 65535 (U+FFFF) werden von einer einzigen 16-Bit-Codeeinheit des gleichen Wertes repräsentiert, während Zeichen im Bereich von 65536 (U+10000) bis 1114111 (U+10FFFF) von einem <em>Ersatzzeichenpaar</em> repräsentiert werden; also exakt zwei 16-Bit-Codeeinheiten zwischen 0xD800 und 0xDFFF. (weitere Details zu Ersatzzeichenpaaren und Methoden zum Codieren oder Decodieren solcher finden Sie im Internet.)</p>
</li>
  <li>
<p>ANSI-Versionen von AutoHotkey verwenden den Standard-ANSI-Zeichensatz des Systems, abhängig von den Sprach- und Regionseinstellungen des Systems oder von der Systemeinstellung "Sprache für Unicode-inkompatible Programme". Das kleinste Element einer ANSI-Zeichenkette ist ein Byte groß. Einige Zeichensätze enthalten jedoch Zeichen, die durch Sequenzen von mehreren Bytes repräsentiert werden (das sind immer ASCII-fremde Zeichen).</p>
</li>
</ul>
<p class="note"><strong>Hinweis:</strong> Es gibt derzeit keine ANSI-Version von AutoHotkey v2.</p>
<p id="character"><strong>Zeichen:</strong> In der Regel verwenden andere Bereiche dieser Dokumentation den Begriff "Zeichen" für die kleinste Einheit einer Zeichenkette; Bytes für ANSI-Zeichenketten und 16-Bit-Codeeinheiten für Unicode-Zeichenketten (UTF-16). Aus praktischen Gründen werden die Länge einer Zeichenkette und die Positionen innerhalb einer Zeichenkette anhand dieser festen Größen gemessen, auch wenn es sich dabei möglicherweise nicht um vollständige Unicode-Zeichen handelt.</p>
<p><a href="commands/FileRead.htm">FileRead</a>, <a href="commands/FileAppend.htm">FileAppend</a>, <a href="commands/FileOpen.htm">FileOpen</a> und das <a href="objects/File.htm">File-Objekt</a> bieten Möglichkeiten, um den Text von Dateien mit einer bestimmten Codierung zu lesen und zu schreiben.</p>
<p>Die Funktionen <a href="commands/StrGet.htm">StrGet</a> und <a href="commands/StrPut.htm">StrPut</a> können genutzt werden, um Zeichenketten zwischen der nativen Codierung und einer anderen angegebenen Codierung umzuwandeln. Diese Funktionen sind jedoch in der Regel nur in Kombination mit Datenstrukturen und der <a href="commands/DllCall.htm">DllCall</a>-Funktion sinnvoll. Zeichenketten, die direkt an oder von <a href="commands/DllCall.htm">DllCall</a> übergeben werden, können mithilfe der Parametertypen <code>AStr</code> oder <code>WStr</code> in ANSI oder UTF-16 umgewandelt werden.</p>
<p>Techniken, wie man mit den Unterschieden zwischen ANSI- und Unicode-Versionen von AutoHotkey umgehen kann, finden Sie unter <a href="Compat.htm#Format">Unicode vs ANSI</a>.</p>

<h3 id="pure-numbers">Reine Zahlen</h3>
<p>Eine <em>reine</em> oder <em>binäre</em> Zahl ist eine im Speicher enthaltene Zahl, mit deren Format die CPU des Computers direkt umgehen kann, um z. B. Berechnungen durchzuführen. In den meisten Fällen wandelt AutoHotkey automatisch zwischen numerischen Zeichenketten und reinen Zahlen um, die nur selten unterschiedlich behandelt werden. AutoHotkey verwendet hauptsächlich zwei Datentypen für reine Zahlen:</p>
<ul>
  <li>vorzeichenfähige 64-Bit-Integer (<em>int64</em>).</li>
  <li>binäre 64-Bit-Floating-Point-Zahlen (das <em>Double</em>- oder <em>Binary64</em>-Format des internationalen Standards IEEE 754).</li>
</ul>
<p>Das heißt, dass Skripte von den folgenden Einschränkungen betroffen sind:</p>
<ul>
  <li>
<p>Integer müssen im vorzeichenfähigen 64-Bit-Bereich sein; also von -9223372036854775808 (-0x8000000000000000, oder -2<sup>63</sup>) bis 9223372036854775807 (0x7FFFFFFFFFFFFFFF, oder 2<sup>63</sup>-1). Wenn eine Integer-Konstante in einem Ausdruck außerhalb dieses Bereichs liegt, werden nur die niedrigen 64 Bit verwendet (der Wert wird gekürzt). Obwohl größere Werte in einer Zeichenkette enthalten sein können, wird jeder Versuch, die Zeichenkette in eine Zahl umzuwandeln (z. B. in einer mathematischen Operation), bewirken, dass sie auf die gleiche Weise gekürzt wird.</p>
</li>
  <li>
<p>Floating-Point-Zahlen unterstützen in der Regel eine Genauigkeit von 15 Nachkommastellen.</p>
</li>
</ul>
<p id="float-imprecision"><strong>Hinweis:</strong> Es gibt einige Nachkommastellen, die das binäre Floating-Point-Format nicht exakt darstellen kann und die Zahl deshalb auf die nächstliegende darstellbare Zahl rundet. Dies kann zu unerwarteten Ergebnissen führen. Zum Beispiel:</p>
<pre>
MsgBox 0.1 + 0           <em>; 0.10000000000000001</em>
MsgBox 0.1 + 0.2         <em>; 0.30000000000000004</em>
MsgBox 0.3 + 0           <em>; 0.29999999999999999</em>
MsgBox 0.1 + 0.2 = 0.3   <em>; 0 (nicht identisch)</em>
</pre>
<p>Eine Strategie zur Bewältigung dieses Problems besteht darin, den direkten Vergleich zu vermeiden und stattdessen die Differenz zu vergleichen. Zum Beispiel:</p>
<pre>MsgBox Abs((0.1 + 0.2) - (0.3)) &lt; 0.0000000000000001
</pre>
<p>Eine andere Strategie ist es, vor dem Vergleich explizit Rundungen vorzunehmen, indem man z. B. die Umwandlung in eine Zeichenkette durchführt. Es gibt in der Regel zwei Möglichkeiten, dies zu tun, während Sie die Genauigkeit angeben:</p>
<pre>MsgBox Round(0.1 + 0.2, 15) = Format("{:.15f}", 0.3)
</pre>

<h3 id="names">Namen</h3>
<p>AutoHotkey wendet die gleichen Regeln für die Benennung verschiedener Dinge an, inklusive Variablen, Funktionen, <a href="commands/GroupAdd.htm">Fenstergruppen</a>, Klassen, Eigenschaften und Methoden. Die Regeln lauten wie folgt.</p>
<p><strong>Groß- und Kleinschreibung:</strong> Für ASCII-Zeichen nicht relevant. Zum Beispiel ist <code>AktuellesDatum</code> das gleiche wie <code>aktuellesdatum</code>. ASCII-fremde Großbuchstaben wie "Ä" sind jedoch <em>nicht</em> identisch zu ihren Kleinbuchstaben, unabhängig von den aktuellen Sprach- und Regionseinstellungen des Benutzers. Dies hilft dem Skript, sich über mehrere Sprach- und Regionseinstellungen hinweg konsistent zu verhalten.</p>
<p><strong>Maximale Länge:</strong> 253 Zeichen.</p>
<p><strong>Erlaubte Zeichen:</strong> Buchstaben, Ziffern, Unterstrich und ASCII-fremde Zeichen; allerdings darf das erste Zeichen keine Ziffer sein.</p>
<p id="reserved-words"><strong>Reservierte Wörter:</strong> <code>and</code>, <code>contains</code>, <code>in</code>, <code>is</code>, <code>not</code> und <code>or</code>. Diese Wörter sind als <a href="Language.htm#operators">Operatoren</a> reserviert.</p>
<p>Schlüsselwörter von Deklarationen und Namen von Ablaufsteuerungsanweisungen sind auch reserviert, hauptsächlich um Fehler aufzuspüren. Dazu gehören: <code>Break</code>, <code>Catch</code>, <code>Continue</code>, <code>Else</code>, <code>Finally</code>, <code>For</code>, <code>Global</code>, <code>Gosub</code>, <code>Goto</code>, <code>If</code>, <code>Local</code>, <code>Loop</code>, <code>Return</code>, <code>Static</code>, <code>Throw</code>, <code>Try</code>, <code>Until</code>, <code>While</code></p>
<p>Namen von Eigenschaften, Methoden und Fenstergruppen dürfen als reservierte Wörter verwendet werden.</p>

<h3 id="variable-references">Variablenreferenzen vs. Werte</h3>
<p>Variablen haben gewisse Ausprägungen, die die Grenze zwischen einer Variable und ihrem Wert verwischen, aber es wichtig sie zu differenzieren. Insbesondere in Bezug auf <a href="#objects">Objekte</a> und ByRef-Parametern.</p>
<p>Obwohl wir sagen können, dass die Variable <code>meinArray</code> ein Array <em>enthält</em> (was ein Objekttyp ist), ist das, was die Variable enthält, nicht das Array selbst, sondern eher <em>eine Referenz bzw. ein Pointer</em> zum Array. Es können beliebig viele Variablen eine Referenz zum selben Objekt enthalten. In diesem Fall kann es hilfreich sein, sich eine Variable nur als Namen vorzustellen. Gibt man zum Beispiel einer Person einen Spitznamen, führt das nicht dazu, dass diese Person geklont wird.</p>
<p>Standardmäßig werden Variablen <em>via Wert</em> an benutzerdefinierte Funktionen übergeben. Das heißt, dass der in der Variable enthaltene Wert in eine Variable kopiert wird, die dem Parameter der Funktion entspricht. Ein <strong>ByRef</strong>-Parameter kann genutzt werden, um eine Variable <em>via Referenz</em> zu übergeben, oder anders gesagt, um einen Parameter der Funktion zu einem <em>Alias</em> für die Variable zu machen, so dass die Funktion der Variable einen neuen Wert zuweisen kann.</p>
<p>Da eine Variable nicht das Objekt selbst, sondern nur eine <em>Referenz</em> zu diesem Objekt enthält, empfängt die Funktion, während so eine Variable an einen ByRef-losen Parameter übergeben wird, eine Referenz zum selben Objekt. Diese Tatsache erlaubt es, dass die Funktion das Objekt modifizieren kann, aber sie verhindert auch, dass die Funktion die <em>Variable</em>, die der Funktionsaufrufer übergeben hat, modifizieren kann, weil die Funktion nicht die Variable, sondern nur eine Referenz zum Objekt hat.</p>

<h3 id="references-to-objects">Objektreferenzen</h3>
<p>Ein Skript interagiert mit einem Objekt nicht direkt, sondern via <em>Referenz</em> zum Objekt. Wenn Sie ein Objekt erstellen, wird das Objekt an einem Ort erstellt, den Sie nicht kontrollieren können, und eine Referenz an Sie übergeben. Wenn Sie diese Referenz an eine Funktion übergeben oder in eine Variable oder in einem anderen Objekt speichern, wird eine neue Referenz zum <em>selben</em> Objekt erstellt.</p>
<p>Wenn zum Beispiel <em>meinObj</em> eine Referenz zu einem Objekt enthält, erstellt <code>deinObj := meinObj</code> eine neue Referenz zum gleichen Objekt. Eine Änderung wie <code>meinObj.ans := 42</code> würde sich sowohl in <code>meinObj.ans</code> als auch in <code>deinObj.ans</code> widerspiegeln, da beide auf dasselbe Objekt verweisen. <code>meinObj := Object()</code> wirkt sich jedoch nur auf die <em>meinObj</em>-Variable aus, nicht auf die <em>deinObj</em>-Variable, die immer noch auf das ursprüngliche Objekt verweist.</p>
<p>Um eine Referenz freizugeben, nutzt man einfach eine Zuweisung und ersetzt sie mit einem anderen Wert. Ein Objekt wird erst gelöscht, wenn alle Referenzen freigegeben sind; das heißt, dass es weder möglich noch lohnenswert ist, ein Objekt explizit zu löschen. (Sie können jedoch die Eigenschaften, den Inhalt oder die zugehörigen Ressourcen eines Objekts löschen, wie z. B. die Elemente eines <a href="objects/Array.htm">Arrays</a>, das zugeordnete Fenster eines <a href="objects/Gui.htm">Gui</a>-Objekts, das Menü eines <a href="objects/Menu.htm">Menu</a> Objekts, und so weiter.)</p>
<pre>Ref1 := Object()  <em>; Erstellt ein Objekt und speichert die erste Referenz</em>
Ref2 := Ref1      <em>; Erstellt eine neue Referenz zum selben Objekt</em>
Ref1 := ""        <em>; Gibt die erste Referenz frei</em>
Ref2 := ""        <em>; Gibt die zweite Referenz frei; Objekt wird gelöscht</em>
</pre>
<p>Wenn das schwer zu verstehen ist, sollten Sie versuchen, sich ein Objekt als Mietwohnung vorzustellen. Wenn Sie eine Wohnung mieten, erhalten Sie einen Schlüssel, mit dem sie die Wohnung betreten können. Sie können mehr Schlüssel erhalten und sie benutzen, um die Wohnung zu betreten, aber sobald Sie vorhaben, die Wohnung endgültig zu verlassen, müssen Sie alle Schlüssel an den Vermieter zurückgeben. In der Regel wird eine Wohnung nicht <em>gelöscht</em>, aber vielleicht muss die Hausverwaltung jemanden beauftragen, der Ihren zurückgelassenen Müll wegräumt; genauso wie der Fall, dass die Werte, die Sie in ein Objekt gespeichert haben, freigegeben werden, wenn das Objekt gelöscht wird.</p>

</body>
</html>
