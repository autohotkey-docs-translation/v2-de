<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Skriptsprache | AutoHotkey v2</title>
<meta name="description" content="Erfahren Sie mehr über die Sprache wie Kommentare, Ausdrücke, Kontrollanweisungen, Aufbau eines Skripts, etc." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
</head>
<body>
<h1>Skriptsprache</h1>
<p>Ein AutoHotkey-Skript ist im Grunde eine Reihe von Instruktionen, die das Programm befolgen muss, geschrieben in einer benutzerdefinierten Sprache, die nur AutoHotkey versteht. Diese Sprache weist einige Ähnlichkeiten mit anderen Skriptsprachen auf, hat aber auch ihre eigenen Stärken und Schwächen. Dieses Dokument beschreibt die Sprache und versucht zudem, häufig auftretende Problemfälle aufzuzeigen.</p>
<p class="note">Unter <a href="Concepts.htm">Konzepte und Konventionen</a> finden Sie eine allgemeinere Erklärung der verschiedenen Konzepte, auf denen AutoHotkey basiert.</p>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#general-conventions">Allgemeine Konventionen</a></li>
  <li><a href="#comments">Kommentare</a></li>
  <li><a href="#expressions">Ausdrücke (Expressions)</a>
  <ul>
    <li><a href="#strings">Zeichenketten / Text</a></li>
    <li><a href="#variables">Variablen</a></li>
    <li><a href="#constants">Konstanten</a></li>
    <li><a href="#operators">Operatoren</a></li>
    <li><a href="#function-calls">Funktionsaufrufe</a>
    <ul>
      <li><a href="#function-call-statements">Funktionsaufrufanweisungen</a></li>
      <li><a href="#optional-parameters">Optionale Parameter</a></li>
    </ul></li>
    <li><a href="#operators-for-objects">Operatoren für Objekte</a></li>
    <li><a href="#expression-statements">Ausdrucksanweisungen</a></li>
  </ul></li>
  <li><a href="#control-flow">Kontrollanweisungen</a>
  <ul>
    <li><a href="#control-flow-vs">Kontrollfluss vs. andere Anweisungen</a></li>
    <li><a href="#loop-statement">Schleifenanweisung</a></li>
    <li><a href="#not-control-flow">Kein Kontrollfluss</a></li>
  </ul></li>
  <li><a href="#structure-of-a-script">Aufbau eines Skripts</a>
  <ul>
    <li><a href="#global-code">Globaler Code</a></li>
    <li><a href="#functions">Funktionen</a></li>
    <li><a href="#-include">#Include</a></li>
  </ul></li>
  <li><a href="#misc">Verschiedenes</a>
  <ul>
    <li><a href="#dynamic-variables">Dynamische Variablen</a>
    <ul>
      <li><a href="#pseudo-arrays">Pseudo-Arrays</a></li>
    </ul></li>
    <li><a href="#labels">Labels</a></li>
  </ul></li>
</ul>
<!-- TODO:
Directives
Declarations
Class definitions
Methods?
-->

<h2 id="general-conventions">Allgemeine Konventionen</h2>
<p><strong>Namen:</strong> Variablen- und Funktionsnamen sind nicht Groß-/Kleinschreibung-sensitiv (zum Beispiel ist <code>AktuellesDatum</code> dasselbe wie <code>aktuellesdatum</code>). Einzelheiten, einschließlich der maximalen Länge und der erlaubten Zeichen, finden Sie unter <a href="Concepts.htm#names">Namen</a>.</p>
<p><strong>Keine typisierten Variablen:</strong> Variablen haben keinen explizit definierten Typ; stattdessen kann jeder Variable (außer Konstanten und internen Variablen) ein beliebiger Wert zugewiesen werden. Es kann vorkommen, dass Zahlen je nach Situation automatisch in Zeichenketten (Text) umgewandelt werden und umgekehrt.</p>
<p><strong>Deklarationen sind optional:</strong> Im Normalfall müssen Variablen nicht deklariert werden (in <a href="Functions.htm">Funktionen</a> gibt es Ausnahmen). Allerdings wird der Versuch, eine Variable zu lesen, bevor ihr ein Wert zugewiesen wurde, als Fehler gewertet.</p>
<p><strong>Leer- und Tabulatorzeichen werden meist ignoriert:</strong> Einrückungen (Leer- und Tabulatorzeichen am Anfang) sind nur für die Lesbarkeit des Codes wichtig, nicht für die Ausführung. Sie werden vom Programm nicht benötigt und werden in der Regel ignoriert. Leer- und Tabulatorzeichen werden <em>grundsätzlich</em> am Ende einer Zeile und innerhalb eines Ausdrucks (außer zwischen Anführungszeichen) ignoriert. In einigen Fällen sind diese Zeichen jedoch von Bedeutung:</p>
<ul>
  <li><a href="#function-calls">Funktions</a>- und Methodenaufrufe erfordern, dass zwischen dem Funktions- bzw. Methodennamen und <code>(</code> kein Leerzeichen steht.</li>
  <li>Leerzeichen werden zum Verketten von Elementen benötigt.</li>
  <li>Zwischen zwei Operatoren sind eventuell Leerzeichen erforderlich, um Mehrdeutigkeiten zu vermeiden.</li>
  <li>Einzeilige <a href="#comments">Kommentare</a> müssen mit einem Leerzeichen beginnen, wenn sie nicht am Zeilenanfang stehen.</li>
</ul>
<p><strong>Zeilenumbrüche sind von Bedeutung:</strong> Zeilenumbrüche dienen in der Regel als Trennzeichen für Anweisungen und terminieren den vorherigen Funktionsaufruf oder andere Anweisung. (Eine <em>Anweisung</em> ist einfach gesagt das kleinste eigenständige Element der Sprache, das eine ausführende Aktion ausdrückt.) Die Ausnahme davon ist die Zeilenfortsetzung (siehe unten).</p>
<p><strong>Zeilenfortsetzung:</strong> Lange Zeilen können in mehrere kurze Zeilen aufgeteilt werden, um die Lesbarkeit und Wartbarkeit des Skripts zu verbessern. Dies erfolgt präprozedural, d.h. es ist nicht Teil der Sprache im eigentlichen Sinne. Es gibt drei Methoden:</p>
<ul>
  <li><a href="Scripts.htm#continuation-line">Fortsetzungspräfix</a>: Zeilen, die mit einem <a href="Variables.htm#operators">Ausdrucksoperator</a> (außer ++ und --) beginnen, werden mit der vorherigen Zeile zusammengeführt. Zeilen werden immer zusammengeführt, egal ob die Zeile tatsächlich einen Ausdruck enthält.</li>
  <li><a href="Scripts.htm#continuation-expr">Fortsetzung durch Umschließen</a>: Ein Teilausdruck, der mit (), [] oder {} umschlossen ist, kann in den meisten Fällen automatisch mehrere Zeilen umspannen.</li>
  <li><a href="Scripts.htm#continuation-section">Fortsetzungsbereich</a>: Ein mehrzeiliger Bereich, der mit <code>(</code> beginnt und mit <code>)</code> endet, wird mit der Zeile darüber zusammengeführt (beide Symbole müssen am Anfang einer Zeile stehen, mit oder ohne Leerzeichen).</li>
</ul>
 

<h2 id="comments">Kommentare</h2>
<p><em>Kommentare</em> sind Textbereiche innerhalb des Skripts, die vom Programm ignoriert werden. Sie werden in der Regel verwendet, um Erklärungen hinzuzufügen oder Teile des Codes zu deaktivieren.</p>
<p>Skripte können durch ein Semikolon am Anfang einer Zeile kommentiert werden. Zum Beispiel:</p>
<pre><em>; Diese ganze Zeile ist ein Kommentar.</em></pre>
<p>Kommentare können auch am Ende einer Zeile stehen – in diesem Fall muss links vom Semikolon mindestens ein Leer- oder Tabulatorzeichen stehen. Zum Beispiel:</p>
<pre>Run "Notepad"  <em>; Dieser Kommentar steht auf derselben Zeile wie der Funktionsaufruf.</em></pre>
<p>Mit den Symbolen <code><em>/*</em></code> und <code><em>*/</em></code> können ganze Bereiche auskommentiert werden. Zum Beispiel:</p>
<pre><em>/*
MsgBox "Diese Zeile ist auskommentiert (deaktiviert)."
MsgBox "Häufiger Fehler:" */ " Dies beendet nicht den Kommentar."
MsgBox "Diese Zeile ist auskommentiert."
*/</em>
MsgBox "Diese Zeile ist nicht auskommentiert."
<em>/* Dies ist auch gültig, aber auf dieser Zeile darf kein anderer Code stehen. */</em>
MsgBox "Diese Zeile ist nicht auskommentiert."
</pre>
<p>Unabhängig von Tabulator- und Leerzeichen muss <code><em>/*</em></code> am Anfang der Zeile stehen, während <code><em>*/</em></code> nur am Anfang oder Ende einer Zeile stehen kann. Es ist auch möglich, <code><em>*/</em></code> wegzulassen – in diesem Fall wird der Rest der Datei auskommentiert.</p>
<p>Kommentare werden herausgefiltert, wenn das Skript aus der Datei gelesen wird, und haben daher keinen Einfluss auf die Performanz oder Speicherauslastung.</p>

<h2 id="expressions">Ausdrücke (Expressions)</h2>
<p><em>Ausdrücke</em> sind Kombinationen beliebig vieler <a href="Concepts.htm#values">Werte</a>, <a href="Concepts.htm#variables">Variablen</a>, <a href="#operators">Operatoren</a> und <a href="#function-calls">Funktionsaufrufe</a>. Zum Beispiel sind <code>10</code>, <code>1+1</code> und <code>MeineVar</code> gültige Ausdrücke. Ein Ausdruck nimmt in der Regel einen oder mehrere Eingabewerte, führt eine oder mehrere Operationen durch, und erzeugt einen Ausgabewert. Die Prozedur, mit der der Wert eines Ausdrucks ermittelt wird, nennt sich <em>Auswertung</em>. Zum Beispiel wird der Ausdruck <code>1+1</code> zu der Zahl 2 <em>ausgewertet</em>.</p>
<p>Einfache Ausdrücke können zu immer komplexeren Ausdrücken zusammengesetzt werden. Wenn z.B. <code>Rabatt/100</code> einen Rabattprozentsatz in eine Bruchzahl umwandelt, berechnet <code>1 - Rabatt/100</code> eine Bruchzahl, die den Restbetrag darstellt, während <code>Preis * (1 - Rabatt/100)</code> diese Bruchzahl verwendet, um den Nettopreis zu berechnen.</p>
<p><em>Werte</em> sind <a href="Concepts.htm#numbers">Zahlen</a>, <a href="Concepts.htm#objects">Objekte</a> oder <a href="Concepts.htm#strings">Zeichenketten</a>. Ein <em>literaler</em> Wert ist ein Wert, der physisch in das Skript geschrieben wird; also ein Wert, den Sie direkt im Code sehen können.</p>

<h3 id="strings">Zeichenketten / Text</h3>
<p class="note">Eine allgemeinere Erklärung von Zeichenketten finden Sie unter <a href="Concepts.htm#strings">Zeichenketten (Strings)</a>.</p>
<p>Eine <em><em>Zeichenkette</em></em> ist einfach nur ein Textwert. In einem Ausdruck muss direkt geschriebener Text in einfachen oder doppelten Anführungszeichen gesetzt werden, um ihn von einem Variablennamen oder einem anderen Ausdruck zu unterscheiden. Dieser Zustand wird oft als <em>in Anführungszeichen gesetzte, direkt geschriebene Zeichenkette</em> oder einfach nur <em>in Anführungszeichen gesetzte Zeichenkette</em> bezeichnet. Zum Beispiel: <code>"Dies ist eine in Anführungszeichen gesetzte Zeichenkette."</code> oder <code>'diese auch'</code>.</p>
<p>Um ein <em>tatsächliches</em> Anführungszeichen in eine direkt geschriebene Zeichenkette einzufügen, verwenden Sie die <a href="misc/EscapeChar.htm#quote">Escapesequenz</a> <code class="no-highlight">`"</code> oder <code class="no-highlight">`'</code> oder umschließen Sie das Zeichen mit gegenteiligen Anführungszeichen. Zum Beispiel: <code>'Sie sagte: "Ein Apfel täglich."'</code>.</p>
<p>In Anführungszeichen gesetzte Zeichenketten können andere <a href="misc/EscapeChar.htm">Escapesequenzen</a> wie z.B. <code class="no-highlight">`t</code> (Tabulator), <code class="no-highlight">`n</code> (Zeilenvorschub) und <code class="no-highlight">`r</code> (Wagenrücklauf) enthalten.</p>

<h3 id="variables">Variablen</h3>
<p class="note">Eine grundlegende Erklärung und allgemeine Details zu Variablen finden Sie unter <a href="Concepts.htm#variables">Variablen</a>.</p>
<p>Um <em>Variablen</em> in einem Ausdruck zu verwenden, geben Sie einfach den Namen der Variable an. Zum Beispiel: <code>A_ScreenWidth/2</code>. Allerdings können Variablen nicht in einer in Anführungszeichen gesetzten Zeichenkette verwendet werden. Stattdessen greift man auf eine Vorgehensweise zurück, die sich <a href="Variables.htm#concat"><em>Verkettung</em></a> nennt, um Variablen und andere Werte zu kombinieren. Es gibt zwei Möglichkeiten, um Werte in einem Ausdruck zu <em>verketten</em>:</p>
<ul>
  <li>Implizite Verkettung: <code>"Der Wert ist " MeineVar</code></li>
  <li>Explizite Verkettung: <code>"Der Wert ist " . MeineVar</code></li>
</ul>
<p>Implizite Verkettung wird auch <em>Auto-Verkettung</em> genannt. In beiden Fällen sind die Leerzeichen vor der Variable und dem Punkt zwingend erforderlich.</p>
<p>Alternativ können Sie auch die <a href="lib/Format.htm">Format</a>-Funktion verwenden. Zum Beispiel:</p>
<pre>MsgBox Format("Sie verwenden AutoHotkey v{1} {2}-Bit.", A_AhkVersion, A_PtrSize*8)</pre>
<p>Um einer Variable einen Wert zuzuweisen, verwenden Sie den <a href="Variables.htm#AssignOp">Zuweisungsoperator</a> <code>:=</code>, wie in <code>MeineVar := "Beliebiger Text"</code>.</p>
<p><em>Prozentzeichen</em> innerhalb eines Ausdrucks werden verwendet, um <a href="#dynamic-variables">dynamische Variablenreferenzen</a> zu erzeugen, werden aber selten benötigt.</p>

<h3 id="constants">Konstanten</h3>
<p>Eine Konstante ist nichts anderes als ein unveränderlicher Wert mit einem symbolischen Namen. AutoHotkey verfügt derzeit über die folgenden Konstanten:</p>
<table class="info">
  <tr><th>Name</th><th>Wert</th><th>Type</th><th abbr="Beschr">Beschreibung</th></tr>
  <tr><td>False</td><td>0</td><td><a href="Concepts.htm#numbers">Integer</a></td><td><a href="Variables.htm#Boolean">Boolesches</a> Falsch/Unwahr, bedeutet manchmal "aus", "nein" usw.</td></tr>
  <tr><td>True</td><td>1</td><td><a href="Concepts.htm#numbers">Integer</a></td><td><a href="Variables.htm#Boolean">Boolesches</a> Wahr, bedeutet manchmal "an", "ja" usw.</td></tr>
</table>
<p>Im Gegensatz zu den schreibgeschützten <a href="Variables.htm#BuiltIn">internen Variablen</a>, können diese nicht von einer <a href="#dynamic-variables">dynamischen Referenz</a> zurückgegeben werden.</p>

<h3 id="operators">Operatoren</h3>
<p><em>Operatoren</em> haben die Form eines Symbols oder einer Gruppe von Symbolen, wie z.B. <code>+</code> oder <code>:=</code>, oder eines der Wörter <code>and</code>, <code>or</code>, <code>not</code>, <code>is</code>, <code class="no-highlight">in</code> oder <code class="no-highlight">contains</code>. Sie nehmen einen, zwei oder drei Eingabewerte und geben einen Ausgabewert zurück. Ein Wert oder Teilausdruck, der als Eingabe für einen Operator dient, nennt sich <em>Operand</em>.</p>
<ul>
  <li><em>Unäre</em> (einwertige) Operatoren werden je nach Operator entweder vor oder nach einem einzelnen Operanden geschrieben. Zum Beispiel: <code>-x</code> oder <code>not TasteIstUnten</code>.</li>
  <li><em>Binäre</em> (zweiwertige) Operatoren befinden sich zwischen zwei Operanden. Zum Beispiel: <code>1+1</code> oder <code>2 * 5</code>.</li>
  <li>AutoHotkey hat nur einen <em>ternären</em> (dreiwertigen) Operator, der die Form <a href="Variables.htm#ternary"><code>Bedingung ? WertWennTrue : WertWennFalse</code></a> hat.</li>
</ul>
<p>Einige unäre und binäre Operatoren teilen sich die gleichen Symbole – in diesem Fall hängt die Bedeutung des Operators davon ab, ob er vor, nach oder zwischen zwei Werten geschrieben wird. Zum Beispiel führt <code>x-y</code> eine Subtraktion durch, während <code>-x</code> das Vorzeichen von <code>x</code> invertiert (einen positiven Wert aus einem negativen Wert erzeugen und umgekehrt).</p>
<p>Operatoren gleicher Priorität wie Multiplizieren (<code>*</code>) und Dividieren (<code>/</code>) werden von links nach rechts ausgewertet, sofern in der <a href="Variables.htm#operators">Operatorentabelle</a> nichts anderes angegeben ist. Ein Operator mit niedrigerer Priorität wie Addieren (<code>+</code>) wird erst ausgewertet, wenn ein höherer Operator wie Multiplizieren (<code>*</code>) ausgewertet wurde. Zum Beispiel wird <code>3 + 2 * 2</code> als <code>3 + (2 * 2)</code> ausgewertet. Die Priorität kann mit runden Klammern überschrieben werden. Zum Beispiel: <code>(3 + 2) * 2</code></p>

<h3 id="function-calls">Funktionsaufrufe</h3>
<p class="note">Eine allgemeine Erläuterung von Funktionen und verwandten Begriffen finden Sie unter <a href="Concepts.htm#functions">Funktionen</a>.</p>
<p><em>Funktionen</em> akzeptieren eine beliebige Anzahl von Eingabewerten, führen eine Aktion oder Berechnung durch und geben dann ein Ergebnis via <a href="Concepts.htm#return-a-value"><em>Return</em></a> zurück. Die Eingabewerte einer Funktion werden als <a href="Concepts.htm#parameters"><em>Parameter</em></a> oder <em>Argumente</em> bezeichnet. Um eine Funktion <a href="Concepts.htm#call"><em>aufzurufen</em></a>, geben Sie einfach die Zielfunktion gefolgt von Parametern in runden Klammern an. <code>GetKeyState("Shift")</code> beispielsweise gibt 1 zurück (wird zu dieser Zahl ausgewertet), wenn <kbd>Umschalt</kbd> gedrückt gehalten wird, andernfalls 0.</p>
<p class="warning"><strong>Hinweis:</strong> Zwischen der Funktion und der runden Startklammer darf kein Leerzeichen stehen.</p>
<p>Für angehende Programmierer mag die Notwendigkeit von runden Klammern auf den ersten Blick kryptisch oder umständlich erscheinen, aber gerade sie ermöglichen es, einen Funktionsaufruf mit anderen Operationen zu kombinieren. Zum Beispiel wird der Ausdruck <code>GetKeyState("Shift", "P") and GetKeyState("Ctrl", "P")</code> nur dann 1 zurückgeben, wenn beide Tasten physisch gedrückt gehalten werden.</p>
<p>Obwohl ein Funktionsaufrufausdruck normalerweise mit einem direkt geschriebenen Funktionsnamen beginnt, kann das Ziel des Aufrufs ein beliebiger Ausdruck sein, der ein <a href="misc/Functor.htm">Funktionsobjekt</a> erzeugt. Im Ausdruck <code>GetKeyState("Shift")</code> ist <em>GetKeyState</em> eigentlich eine Variablenreferenz, obwohl sie üblicherweise auf eine schreibgeschützte Variable verweist, die eine interne Funktion enthält.</p>

<h4 id="function-call-statements">Funktionsaufrufanweisungen</h4>
<p>Wenn der Rückgabewert der Funktion nicht benötigt wird und der Funktionsname am Zeilenanfang steht (oder in einem anderen Kontext, wo eine <a href="Concepts.htm#statement">Anweisung</a> erlaubt ist, z.B. nach einem <code>else</code> oder einem <a href="Hotkeys.htm">Hotkey</a>), können die Klammern weggelassen werden. In diesem Fall wird der Rest der Zeile als Parameterliste der Funktion interpretiert. Zum Beispiel:</p>
<pre>Ergebnis := MsgBox("Dies benötigt runde Klammern.",, "OKCancel")
MsgBox "Dies nicht. Das Ergebnis war " Ergebnis "."</pre>
<p>Im gleichen Kontext können die runden Klammern auch bei einem <a href="Concepts.htm#methods">Methodenaufruf</a> weggelassen werden, aber nur, wenn das Zielobjekt entweder eine Variable oder eine direkt benannte Eigenschaft ist, z.B. <code>meineVar.meineMethode</code> oder <code>meineVar.meineEigenschaft.meineMethode</code>.</p>
<p>Wie bei Funktionsaufrufausdrücken muss das Ziel einer Funktionsaufrufanweisung keine vordefinierte Funktion sein; es kann stattdessen eine Variable sein, die ein <a href="misc/Functor.htm">Funktionsobjekt</a> enthält.</p>
<p>Eine Funktionsaufrufanweisung kann sich <a href="Scripts.htm#continuation">über mehrere Zeilen erstrecken</a>.</p>
<p>Für Funktionsaufrufanweisungen gelten die folgenden Einschränkungen:</p>
<ul>
  <li>Wenn es einen Rückgabewert gibt, wird dieser immer verworfen.</li>
  <li>Sie können wie <a href="#control-flow">Kontrollanweisungen</a> nicht innerhalb eines Ausdrucks verwendet werden.</li>
  <li>Wenn optionale Parameter weggelassen werden, müssen auch alle Kommas am <em>Ende</em> der Parameterliste weggelassen werden, um eine <a href="Scripts.htm#continuation-line">Zeilenfortsetzung</a> zu verhindern.</li>
  <li>Funktionsaufrufanweisungen können nicht <a href="Functions.htm#VariadicCall">variadisch</a> sein, aber sie können eine feste Anzahl von Parametern an eine variadische Funktion übergeben.</li>
</ul>

<h4 id="optional-parameters">Optionale Parameter</h4>
<p>Optionale Parameter können einfach leer gelassen werden, allerdings ist das Komma als Trennzeichen weiterhin notwendig, es sei denn, alle nachfolgenden Parameter werden ebenfalls weggelassen. Die <a href="lib/Run.htm">Run</a>-Funktion beispielsweise akzeptiert 1 bis 4 Parameter. Alle folgenden Zeilen sind gültig:</p>
<pre>
Run "notepad.exe", "C:\"
Run "notepad.exe",, "Min"
Run("notepad.exe", , , &amp;notepadPID)
</pre>
<p id="unset">Innerhalb eines <a href="#function-calls">Funktionsaufrufs</a>, eines <a href="Variables.htm#square-brackets">direkt geschriebenen Arrays</a> oder eines <a href="Variables.htm#curly-braces">direkt geschriebenen Objekts</a> kann das Schlüsselwort <code>unset</code> verwendet werden, um den Parameter oder Wert explizit wegzulassen. Ein ungesetzter Ausdruck hat eine der folgenden Auswirkungen:</p>
<ul>
  <li>Bei einer benutzerdefinierten Funktion wird der <a href="Functions.htm#optional">Standardwert</a> des Parameters verwendet.</li>
  <li>Bei einer internen Funktion wird der Parameter so behandelt, als wäre er weggelassen worden.</li>
  <li>Bei einem <a href="Variables.htm#square-brackets">direkt geschriebenen Array</a> wie <code>[var?]</code> wird das Element in die Länge des Arrays einbezogen, erhält aber keinen Wert.</li>
  <li>Bei einem <a href="Variables.htm#curly-braces">direkt geschriebenen Objekt</a> wie <code>{x: y?}</code> wird die Eigenschaft nicht zugewiesen.</li>
</ul>
<p>Das <code>unset</code>-Schlüsselwort kann auch <a href="Functions.htm#unset">in einer Funktionsdefinition verwendet werden</a>, um anzugeben, dass ein Parameter optional ist, aber keinen Standardwert hat. Bei der Ausführung der Funktion wird die lokale Variable des entsprechenden Parameters <a href="Concepts.htm#nothing">keinen Wert</a> haben, wenn der Parameter weggelassen wurde.</p>
<p>Mit dem <a href="Variables.htm#maybe">Vielleicht-Operator (<em>Var</em><strong>?</strong>)</a> kann eine Variable übergeben oder weggelassen werden, je nachdem, ob sie einen Wert hat oder nicht. Zum Beispiel ist <code>Array(MeineVar?)</code> äquivalent zu <code>Array(IsSet(MeineVar) ? MeineVar : unset)</code>.</p>

<h3 id="operators-for-objects">Operatoren für Objekte</h3>
<p>Es gibt noch andere Symbole, die in Ausdrücken verwendet werden, die nicht ganz in eine der oben genannten Kategorien passen oder die einen Einfluss auf die Bedeutung anderer Teile des Ausdrucks haben, wie unten beschrieben. Diese Symbole beziehen sich alle in irgendeiner Weise auf <em>Objekte</em>. Eine vollständige Erklärung dessen, was jedes Konstrukt tut, würde die Einführung weiterer Konzepte erfordern, die nicht in den Geltungsbereich dieses Abschnitts fallen.</p>
<p><code>Alpha.Beta</code> wird oft als <em>Objektelementzugriff</em> bezeichnet. <em>Alpha</em> ist eine gewöhnliche Variable und kann mit einem Funktionsaufruf oder einem anderen Teilausdruck, der ein Objekt zurückgibt, ersetzt werden. Beim Auswerten wird das Objekt mit der Anfrage konfrontiert, entweder den Wert oder die Eigenschaft <em>Beta</em> abzurufen, diesen Wert in die Eigenschaft <em>Beta</em> zu speichern oder die Methode namens <em>Beta</em> aufzurufen. Mit anderen Worten, <em>Beta</em> ist ein Name, der für das Objekt von Bedeutung ist; es ist keine lokale oder globale Variable.</p>
<p><code>Alpha.Beta()</code> ist ein <em>Methodenaufruf</em>. <em>Alpha</em> wird implizit als Parameter übergeben, allerdings ist dies normalerweise nicht sichtbar, da jede Methodendefinition implizit einen Parameter namens <code>this</code> definiert. Die runden Klammern können in bestimmten Fällen weggelassen werden; siehe <a href="#function-call-statements">Funktionsaufrufanweisungen</a>.</p>
<p><code>Alpha.Beta[Param]</code> ist eine spezielle Form des Objektelementzugriffs, die zusätzliche Parameter in die Anfrage einbezieht. Während <em>Beta</em> ein einfacher Name ist, ist <em>Param</em> eine gewöhnliche Variable oder ein Teilausdruck, oder eine Liste von Teilausdrücken, die durch Kommas getrennt sind (wie in der Parameterliste einer Funktion). <a href="Functions.htm#VariadicCall">Variadische Aufrufe</a> sind erlaubt.</p>
<p><code>Alpha.%vBeta%</code>, <code>Alpha.%vBeta%[Param]</code> und <code>Alpha.%vBeta%()</code> sind ebenfalls Objektelementzugriffe, aber <em>vBeta</em> ist eine Variable oder ein Teilausdruck. Auf diese Weise kann der Name der Eigenschaft oder Methode während der Skriptausführung ermittelt werden. Solche Methodenaufrufe benötigen runde Klammern.</p>
<p><code>Alpha[Index]</code> ruft indirekt die <a href="Objects.htm#__Item">__Item</a>-Eigenschaft von <code>Alpha</code> auf und übergibt <code>Index</code> als Parameter. Sowohl <em>Alpha</em> als auch <em>Index</em> sind in diesem Fall Variablen, die mit praktisch jedem Teilausdruck ersetzt werden können. Diese Syntax wird in der Regel verwendet, um ein Element eines <a href="lib/Array.htm">Arrays</a> oder eines <a href="lib/Map.htm">Map</a>-Objekts abzurufen. Bei COM-Objekten ruft dies die <em>Standardeigenschaft</em> per ID (DISPID_VALUE) auf und unterscheidet sich somit von der expliziten Angabe der __Item-Eigenschaft.</p>
<p id="array-literal"><code>[A, B, C]</code> erzeugt ein <a href="lib/Array.htm">Array</a> mit den anfänglichen Inhalten von A, B und C (in diesem Fall alle Variablen), wobei A das Element 1 ist.</p>
<p id="object-literal"><code>{Eigenschaft1: Wert1, Eigenschaft2: Wert2}</code> erstellt ein <a href="lib/Object.htm">Objekt</a> mit den direkt geschriebenen Eigenschaften <em>Eigenschaft1</em> und <em>Eigenschaft2</em>. Ein Wert kann später mit der oben beschriebenen <em>Objektelementzugriff</em>-Syntax abgerufen werden. Um einen Eigenschaftsnamen als Ausdruck auszuwerten, umschließen Sie ihn mit Prozentzeichen. Zum Beispiel: <code>{%NameVar%: WertVar}</code>.</p>
<p><code>MeineFunk(Params*)</code> ist ein <a href="Functions.htm#VariadicCall">variadischer Funktionsaufruf</a>. Das Sternchen muss unmittelbar vor der runden Endklammer am Ende der Parameterliste der Funktion stehen. <em>Params</em> muss eine Variable oder ein Teilausdruck, der ein enumerierbares Objekt wie z.B. <a href="lib/Array.htm">Array</a> zurückgibt, sein. Obwohl <code>Params*</code> nicht überall erlaubt ist, kann es in einem direkt geschriebenen Array (<code>[A, B, C, AnzufügendesArray*]</code>) oder in der Parameterliste einer Eigenschaft (<code>Alpha.Beta[Params*]</code> oder <code>Alpha[Params*]</code>) verwendet werden.</p>

<h3 id="expression-statements">Ausdrucksanweisungen</h3>
<p>Nicht alle Ausdrücke können allein in einer Zeile stehen. Zum Beispiel würde eine Zeile, die nur aus <code>21*2</code> oder <code>"Etwas Text"</code> besteht, keinen Sinn ergeben. Die <em>Ausdrucksanweisung</em> ist ein eigenständiger Ausdruck, der in der Regel für seine Nebenwirkungen verwendet wird. Die meisten Ausdrücke mit Nebenwirkungen können auf diese Weise verwendet werden, daher ist es grundsätzlich nicht notwendig, sich die Details dieses Abschnitts zu merken.</p>
<p>Die folgenden Typen von Ausdrücken können als Anweisungen verwendet werden:</p>
<p>Zuweisungen, wie in <code>x := y</code>, Verbundzuweisungen wie <code>x += y</code>, und Inkrement-/Dekrementoperatoren wie <code>++x</code> und <code>x--</code>.</p>
<p class="warning"><strong>Bekannte Einschränkung:</strong> Bei <code>x++</code> und <code>x--</code> darf derzeit kein Leerzeichen zwischen Variablenname und Operator stehen.</p>
<p>Funktionsaufrufe wie <code>MeineFunk(Params)</code>. Nach einem alleinstehenden Funktionsaufruf sollte jedoch keine geschweifte Startklammer <code>{</code> (am Zeilenende oder auf der nächsten Zeile) folgen, da dies als Funktionsdeklaration fehlinterpretiert werden würde.</p>
<p>Methodenaufrufe wie <code>MeinObj.MeineMethode()</code>.</p>
<p>Objektelementzugriff via eckige Klammern, wie z.B. <code>MeinObj[Index]</code>, das Nebenwirkungen wie ein Funktionsaufruf haben kann.</p>
<p>Ternäre Ausdrücke wie <code>x ? AufrufenWennTrue() : AufrufenWennFalse()</code>. Es ist jedoch sicherer, die unten beschriebene Regel anzuwenden; also den Ausdruck (oder nur die Bedingung) immer mit Klammern zu umschließen.</p>
<p class="warning"><strong>Bekannte Einschränkung:</strong> Aufgrund von Mehrdeutigkeiten bei <a href="#function-call-statements">Funktionsaufrufanweisungen</a> sollten Bedingungen, die mit einem Variablennamen und Leerzeichen beginnen (aber auch andere Operatoren enthalten), in runde Klammern gesetzt werden. Zum Beispiel sind <code>(x + 1) ? y : z</code> und <code>x+1 ? y : z </code> Ausdruckszuweisungen, während <code>x + 1 ? y : z</code> eine Funktionsaufrufanweisung ist.</p>
<p class="warning"><strong>Hinweis:</strong> Die Bedingung darf nicht mit <code>!</code> oder einem anderen Ausdrucksoperator beginnen, da sie sonst als <a href="Scripts.htm#continuation-line">Fortsetzungszeile</a> interpretiert werden würde.</p>
<p>Ausdrücke, die mit <code>(</code> beginnen. In der Regel muss jedoch auf der gleichen Zeile ein entsprechendes <code>)</code> stehen, sonst wird die Zeile als Beginn eines <a href="Scripts.htm#continuation">Fortsetzungsbereichs</a> interpretiert.</p>
<p>Ausdrücke, die mit einer Doppeldereferenz (double-deref) beginnen, wie z.B. <code>%VarName% := 1</code>. Dies ist in erster Linie auf die Komplexität der Implementierung zurückzuführen.</p>
<p>Ausdrücke, die mit den oben genannten Elementen beginnen (aber nicht mit den unten genannten), sind aus praktischen Gründen ebenfalls erlaubt. Zum Beispiel ist <code>MeineFunk()+1</code> derzeit erlaubt, obwohl <code>+1</code> keine Wirkung hat und das Ergebnis verworfen wird. Solche Ausdrücke können in Zukunft durch eine erweiterte Fehlerprüfung ungültig werden.</p>
<p><a href="#function-call-statements">Funktionsaufrufanweisungen</a> ähneln Ausdrucksanweisungen, sind aber technisch gesehen keine reinen Ausdrücke. Zum Beispiel: <code>MsgBox "Hallo, Welt!"</code>, <code>meineGui.Show</code> oder <code>x.y.z "meine Parameter"</code>.</p>

<h2 id="control-flow">Kontrollanweisungen</h2>
<p class="note">Eine allgemeine Erklärung des Kontrollflusses finden Sie unter <a href="Concepts.htm#control-flow">Kontrollfluss</a>.</p>
<p>Um <a href="Concepts.htm#statement">Anweisungen</a> zu einem <a href="lib/Block.htm"><em>Block</em></a> zusammenzufassen, umschließt man sie mit geschweiften Klammern <code>{}</code>, wie es auch in C, JavaScript und anderen ähnlichen Sprachen der Fall ist, allerdings müssen die Klammern in der Regel am Anfang einer Zeile stehen. Kontrollanweisungen können sich auf einen ganzen Block oder auf eine Einzelanweisung beziehen.</p>
<p>Der <a href="Concepts.htm#cf-body">Körper</a> einer Kontrollanweisung besteht immer aus einer <em>Gruppe</em> von Anweisungen. Ein Block zählt als eine Gruppe von Anweisungen, ebenso wie eine Kontrollanweisung und ihr Körper. Die folgenden verwandten Anweisungen werden ebenfalls mit ihren Körpern gruppiert: <code>If</code> mit <code>Else</code>; <code>Loop</code>/<code>For</code> mit <code>Until</code> oder <code>Else</code>; <code>Try</code> mit <code>Catch</code> und/oder <code>Else</code> und/oder <code>Finally</code>. Mit anderen Worten: Wenn eine Gruppe dieser Anweisungen als Ganzes verwendet wird, muss sie nicht immer mit geschweiften Klammern umschlossen werden (einige Programmierstile verwenden jedoch immer die geschweiften Klammern, aus Gründen der Übersichtlichkeit).</p>
<p>Kontrollanweisungen, die einen Körper haben und daher immer eine nachfolgende Anweisung oder eine Gruppe von Anweisungen haben müssen: <code>If</code>, <code>Else</code>, <code>Loop</code>, <code>While</code>, <code>For</code>, <code>Try</code>, <code>Catch</code> und <code>Finally</code>.</p>
<p id="control-flow-list">Es gibt folgende Kontrollanweisungen:</p>
<ul>
  <li>Ein <a href="lib/Block.htm">Block</a> (markiert durch ein Paar geschweifte Klammern) gruppiert beliebig viele Anweisungen, um als Einzelanweisung zu fungieren.</li>
  <li>Eine <a href="lib/If.htm">If-Anweisung</a> führt ihren Körper aus, wenn eine Bedingung erfüllt ist. Sie kann mit einer nachfolgenden <a href="lib/Else.htm">Else</a>-Anweisung verbunden werden, die nur ausgeführt wird, wenn eine Bedingung nicht erfüllt ist.</li>
  <li><a href="lib/Goto.htm">Goto</a> springt zu einem bestimmten Label und setzt dort die Ausführung fort.</li>
  <li><a href="lib/Return.htm">Return</a> lässt eine Funktion zu ihrem Aufrufer zurückkehren.</li>
  <li>Eine <a href="#loop-statement">Schleifenanweisung</a> (<a href="lib/Loop.htm">Loop</a>, <a href="lib/While.htm">While</a> oder <a href="lib/For.htm">For</a>) führt ihren Körper wiederholt aus.
  <ul>
    <li><a href="lib/Break.htm">Break</a> beendet (unterbricht) eine Schleife.</li>
    <li><a href="lib/Continue.htm">Continue</a> überspringt den Rest der aktuellen Schleifenwiederholung und beginnt eine neue.</li>
    <li><a href="lib/Until.htm">Until</a> unterbricht eine Schleife, wenn die Auswertung eines Ausdrucks False ergibt. Der Ausdruck wird nach jeder Wiederholung ausgewertet.</li>
  </ul></li>
  <li><a href="lib/Switch.htm">Switch</a> vergleicht einen Wert mit mehreren Cases und führt die Anweisungen der ersten Übereinstimmung aus.</li>
  <li>Ausnahmebehandlung:
  <ul>
    <li><a href="lib/Try.htm">Try</a> schützt seinen Körper vor Laufzeitfehlern und via Throw ausgelösten Werten.</li>
    <li><a href="lib/Catch.htm">Catch</a> wird ausgeführt, wenn innerhalb einer Try-Anweisung eine Ausnahme bestimmten Typs ausgelöst wird.</li>
    <li><a href="lib/Else.htm">Else</a> hinter einer Catch-Anweisung wird nur ausgeführt, wenn innerhalb einer Try-Anweisung keine Ausnahme ausgelöst wird.</li>
    <li><a href="lib/Finally.htm">Finally</a> führt seinen Körper aus, wenn die Kontrolle aus dem Körper einer Try- oder Catch-Anweisung heraustransferiert wird.</li>
    <li><a href="lib/Throw.htm">Throw</a> löst eine Ausnahme aus, um von Try/Catch oder <a href="lib/OnError.htm">OnError</a> behandelt zu werden oder um ein Fehlerdialogfenster anzuzeigen.</li>
  </ul></li>
</ul>

<h3 id="control-flow-vs">Kontrollfluss vs. andere Anweisungen</h3>
<p>Kontrollanweisungen unterscheiden sich von <a href="#function-call-statements">Funktionsaufrufanweisungen</a> in mehrfacher Hinsicht:</p>
<ul>
  <li>Die geschweifte Startklammer eines <a href="lib/Block.htm">Blocks</a> kann auf derselben Zeile am Ende von <a href="lib/If.htm">If</a>, <a href="lib/Else.htm">Else</a>, <a href="#loop-statement">Loop</a>, <a href="lib/While.htm">While</a>, <a href="lib/For.htm">For</a>, <a href="lib/Try.htm">Try</a>, <a href="lib/Catch.htm">Catch</a> oder <a href="lib/Finally.htm">Finally</a> stehen (im Prinzip jede Kontrollanweisung, die einen <a href="Concepts.htm#cf-body">Körper</a> hat). Dies wird als One True Brace (OTB) Style bezeichnet.</li>
  <li><a href="lib/Else.htm">Else</a>, <a href="lib/Try.htm">Try</a> und <a href="lib/Finally.htm">Finally</a> erlauben auf ihrer rechten Seite eine beliebige gültige Anweisung, da sie einen <a href="Concepts.htm#cf-body">Körper</a> benötigen, aber keine Parameter haben.</li>
  <li><a href="lib/If.htm">If</a>, <a href="lib/While.htm">While</a>, <a href="lib/Return.htm">Return</a>, <a href="lib/Until.htm">Until</a>, <a href="lib/Loop.htm">Loop <em>Anzahl</em></a>, <a href="lib/For.htm">For</a>, <a href="lib/Catch.htm">Catch</a>, <a href="lib/Break.htm">Break</a>, <a href="lib/Continue.htm">Continue</a>, <a href="lib/Throw.htm">Throw</a> und <a href="lib/Goto.htm">Goto</a> erlauben die Verwendung einer runden Startklammer direkt nach dem Namen, um die gesamte Parameterliste zu umschließen. Obwohl sie wie Funktionsaufrufe aussehen, sind sie keine und können nicht innerhalb eines Ausdrucks verwendet werden. Zum Beispiel: <code>if(Ausdruck)</code>.</li>
  <li>Kontrollanweisungen können nicht durch Definition einer gleichnamigen Funktion überschrieben werden.</li>
</ul>

<h3 id="loop-statement">Schleifenanweisung</h3>
<p>Es gibt verschiedene Varianten von Schleifenanweisungen:</p>
<ul>
  <li><a href="lib/Loop.htm">Loop <em>Anzahl</em></a> führt eine Anweisung wiederholt aus: Entweder eine bestimmte Anzahl oder bis ein Break auftritt.</li>
  <li><a href="lib/LoopReg.htm">Loop Reg</a> ruft die Inhalte eines bestimmten Registry-Unterschlüssels nacheinander ab.</li>
  <li><a href="lib/LoopFiles.htm">Loop Files</a> ruft bestimmte Dateien oder Ordner nacheinander ab.</li>
  <li><a href="lib/LoopParse.htm">Loop Parse</a> ruft Teile (Felder) einer Zeichenkette nacheinander ab.</li>
  <li><a href="lib/LoopRead.htm">Loop Read</a> ruft die Zeilen einer Textdatei nacheinander ab.</li>
  <li><a href="lib/While.htm">While</a> führt eine Anweisung wiederholt aus, bis die Auswertung eines bestimmten Ausdrucks False ergibt. Der Ausdruck wird vor jeder Wiederholung ausgewertet.</li>
  <li><a href="lib/For.htm">For</a> führt eine Anweisung einmal für jeden Wert oder jedes Wertepaar aus, das von einem Enumerator zurückgegeben wird, wie z.B. für jedes Schlüssel-Wert-Paar eines Objekts.</li>
</ul>
<p><a href="lib/Break.htm">Break</a> beendet (unterbricht) eine Schleife und springt zur nächsten Zeile nach dem Schleifenkörper.</p>
<p><a href="lib/Continue.htm">Continue</a> überspringt den Rest der aktuellen Schleifenwiederholung und beginnt eine neue.</p>
<p><a href="lib/Until.htm">Until</a> unterbricht eine Schleife, wenn die Auswertung eines Ausdrucks False ergibt. Der Ausdruck wird nach jeder Wiederholung ausgewertet.</p>
<p id="named-loops">Ein <a href="#labels">Label</a> kann verwendet werden, um eine Schleife für <a href="lib/Continue.htm">Continue</a> und <a href="lib/Break.htm">Break</a> zu "benennen". Dadurch kann das Skript von einer inneren Schleife heraus den aktuellen Durchlauf einer äußeren Schleife überspringen oder die äußere Schleife unterbrechen, ohne <a href="lib/Goto.htm">Goto</a> verwenden zu müssen.</p>
<p>Die interne Variable <strong>A_Index</strong> enthält die Nummer der aktuellen Schleifenwiederholung. Sie enthält 1, wenn der Körper der Schleife zum ersten Mal ausgeführt wurde. Beim zweiten Mal enthält sie 2 und so weiter. Wenn eine innere Schleife von einer äußeren Schleife umschlossen ist, hat die innere Schleife Vorrang. A_Index funktioniert in jeder Schleifenvariante, enthält aber außerhalb einer Schleife eine 0.</p>
<p>Einige Schleifenvarianten haben weitere interne Variablen, die Informationen über das aktuelle Schleifenelement liefern (Registry-Schlüssel/Wert, Datei, Teilzeichenkette oder Textzeile). Solche Variablen haben Namen, die mit <strong>A_Loop</strong> beginnen, wie z.B. A_LoopFileName und A_LoopReadLine. Ihre Werte gehören immer zur zuletzt gestarteten (aber noch nicht gestoppten) Schleife des entsprechenden Typs. Zum Beispiel gibt A_LoopField die aktuelle Teilzeichenkette der innersten Parsing-Schleife zurück, sogar wenn es innerhalb einer Datei- oder Registry-Schleife verwendet wird.</p>
<pre>t := "Spalte 1`tSpalte 2`nWert 1`tWert 2"
Loop Parse t, "`n"
{
    ZeileText := A_LoopField
    ZeileNummer := A_Index  <em>; Zur Verwendung in der zweiten Schleife unten speichern.</em>
    Loop Parse ZeileText, "`t"
    {
        MsgBox ZeileNummer ":" A_Index " = " A_LoopField
    }
}
</pre>
<p>Schleifenvariablen können auch außerhalb des Schleifenkörpers verwendet werden, z.B. in einer Funktion, die aus einer Schleife heraus aufgerufen wird.</p>

<h3 id="not-control-flow">Kein Kontrollfluss</h3>
<p>Da Direktiven, Labels, Zweifach-Doppelpunkt-Tags von Hotkeys und Hotstrings und Deklarationen ohne Zuweisungen bereits verarbeitet werden, während das Skript aus der Datei geladen wird, unterliegen sie nicht dem Kontrollfluss. Das heißt, dass sie bedingungslos wirksam werden, bevor das Skript überhaupt Kontrollanweisungen ausführt. Auch die <a href="lib/_HotIf.htm">#HotIf</a>-Direktive hat keinen Einfluss auf den Kontrollfluss; sie legt lediglich die Kriterien für die im Code angegebenen Hotkeys und Hotstrings fest. Die Kriterien eines Hotkeys werden jedes Mal ausgewertet, wenn er gedrückt wird, nicht wenn die Ausführung auf die #HotIf-Direktive trifft.</p>

<h2 id="structure-of-a-script">Aufbau eines Skripts</h2>

<h3 id="global-code">Globaler Code</h3>
<p>Nach dem Laden des Skripts beginnt der <em>Auto-Execute-Thread</em> mit der Ausführung der obersten Zeile des Skripts, bis er z.B. durch <a href="lib/Return.htm">Return</a>, <a href="lib/ExitApp.htm">ExitApp</a> oder <a href="lib/Exit.htm">Exit</a> zum Stoppen gebracht wird. Das physische Ende des Skripts fungiert ebenfalls als <a href="lib/Exit.htm">Exit</a>.</p>
<p>Globaler Code oder Code im globalen <a href="Concepts.htm#scope">Gültigkeitsbereich</a> ist ein ausführbarer Code, der sich nicht innerhalb einer Funktions- oder Klassendefinition befindet. Alle dortigen Variablenreferenzen gelten als <a href="Functions.htm#Global">global</a>, da jede Funktion auf sie zugreifen kann (mit der richtigen Deklaration). Ein solcher Code wird oft verwendet, um Einstellungen für alle neuen <a href="misc/Threads.htm">Threads</a> zu konfigurieren oder um globale Variablen zu <a href="Concepts.htm#uninitialized-variables">initialisieren</a>, die von Hotkeys und anderen Funktionen verwendet werden.</p>
<p>Auszuführender Code für die Startphase des Skripts (sofort wenn das Skript startet) wird oft am Anfang der Datei platziert. Dieser Code kann jedoch überall in der Datei platziert werden, zwischen (aber nicht innerhalb von) Funktions- und Klassendefinitionen. Der Grund dafür ist, dass der Körper jeder Funktions- oder Klassendefinition übersprungen wird, wann immer die Ausführung darauf stößt. In einigen Fällen kann das Skript vollständig aus globalem Code bestehen.</p>
<p><strong>Siehe auch:</strong> <a href="Scripts.htm#auto">Startphase des Skripts (der Auto-Execute-Thread)</a></p>

<h3 id="subroutines">Subroutinen</h3>
<p>Eine <em>Subroutine</em> (auch <em>Sub</em> oder <em>Prozedur</em> genannt) ist ein wiederverwendbarer Codeblock, der bei Bedarf ausgeführt werden kann. Um eine Subroutine zu erstellen, definieren Sie eine <em>Funktion</em> (siehe unten). Diese Begriffe sind in AutoHotkey v2 grundsätzlich austauschbar, da Funktionen die einzigen Subroutinen sind.</p>

<h3 id="functions">Funktionen</h3>
<p><strong>Siehe auch:</strong> <a href="Functions.htm">Funktionen</a> (alles über das Definieren von Funktionen)</p>
<p>Neben den vielen nützlichen <a href="lib/index.htm">vordefinierten Funktionen</a> kann ein Skript auch eigene Funktionen definieren. Diese Funktionen können grundsätzlich auf zwei verschiedene Arten verwendet werden:</p>
<ol>
  <li>Eine Funktion kann vom Skript selbst aufgerufen werden. Diese Art von Funktion kann verwendet werden, um z.B. Wiederholungen zu vermeiden oder die Wartbarkeit des Codes zu verbessern.</li>
  <li>Eine Funktion kann vom Programm als Reaktion auf ein Ereignis aufgerufen werden, z.B. wenn der Benutzer einen Hotkey drückt. Zum Beispiel ist jedem Hotkey eine Funktion zugeordnet, die beim Drücken des Hotkeys ausgeführt wird.</li>
</ol>
<p>Es gibt mehrere Möglichkeiten, eine Funktion zu definieren:</p>
<ul>
  <li>Eine <a href="Functions.htm">Funktionsdefinition</a>, die aus einem Namen, runden Klammern und einem <a href="lib/Block.htm">Codeblock</a> besteht. Dies definiert eine Funktion, die über ihren Namen via <a href="#function-calls">Funktionsaufruf</a> oder <a href="#function-call-statements">Funktionsaufrufanweisung</a> ausgeführt werden kann. Zum Beispiel:
<pre>SageHallo()  <em>; SageHallo-Funktion definieren.</em>
{
    MsgBox "Hallo!"
}

SageHallo  <em>; SageHallo-Funktion aufrufen.</em></pre>
  </li>
  <li>Eine <a href="Hotkeys.htm">Hotkey</a>- oder <a href="Hotstrings.htm">Hotstring</a>-Definition, die aus einem Hotkey oder Hotstring und einer einzelnen <a href="Concepts.htm#statement">Anweisung</a> oder einem <a href="lib/Block.htm">Block</a> besteht. Diese Art von Funktion kann nicht direkt aufgerufen werden, sondern wird immer dann ausgeführt, wenn der Hotkey oder Hotstring aktiviert wird. Zum Beispiel:
<pre>#w::Run "wordpad"  <em>; WIN+W drücken, um Wordpad zu starten.</em>
#n::  <em>; WIN+N drücken, um Notepad zu starten.</em>
{
    Run "notepad"
}</pre>
  </li>
  <li>Ein <a href="Variables.htm#fat-arrow">Fat-Arrow-Ausdruck</a> definiert eine Funktion, die einen <a href="#expressions">Ausdruck</a> auswertet und sein Ergebnis <a href="Concepts.htm#return-a-value">zurückgibt</a>, anstatt einen Codeblock auszuführen. Solche Funktionen haben normalerweise keinen Namen, da sie direkt an eine andere Funktion übergeben werden. Zum Beispiel:
    <pre>SetTimer () =&gt; MsgBox("Hallo!"), -1000  <em>; Sagt Hallo nach 1 Sekunde.</em></pre>
  </li>
  <li>Die Fat-Arrow-Syntax kann auch außerhalb von Ausdrücken als Kurzschreibweise für eine normale Funktions- oder Methodendefinition verwendet werden. Zum Beispiel ist das Folgende äquivalent zur obigen SageHallo-Definition, außer dass es "OK" zurückgibt:
    <pre>SageHallo() =&gt; MsgBox("Hallo!")</pre>
  </li>
</ul>
<p>Variablen in Funktionen sind standardmäßig <a href="Functions.htm#Local">lokal</a> für diese Funktion, außer in den folgenden Fällen:</p>
<ul>
  <li>Wenn die Funktion eine <a href="Functions.htm#AssumeGlobal">Assume-Global</a>-Funktion ist.</li>
  <li>Wenn eine Variable referenziert, aber nicht als Ziel einer <a href="Variables.htm#AssignOp">Zuweisung</a> oder des Referenzoperators (<code>&amp;var</code>) verwendet wird.</li>
  <li>Wenn auf eine lokale Variable einer äußeren Funktion innerhalb einer <a href="Functions.htm#nested">verschachtelten Funktion</a> verwiesen wird.</li>
</ul>
<p>Eine Funktion kann optional <a href="Concepts.htm#parameters">Parameter akzeptieren</a>. Die Parameter werden innerhalb von runden Klammern definiert. Zum Beispiel:</p>
<pre>MeineFunktion(ErsterParameter, Zweiter, &amp;Dritter, Vierter:="")
{
    <em>;...</em>
    return "ein Wert"
}
</pre>
<p>Wie bei Funktionsaufrufen darf zwischen dem Funktionsnamen und der runden Startklammer kein Leerzeichen stehen.</p>
<p>Der Zeilenumbruch zwischen der runden Endklammer und der geschweiften Startklammer ist optional. Zwischen der runden Endklammer und der geschweiften Startklammer können beliebig viele Leerraumzeichen oder Kommentare stehen.</p>
<p>Der <a href="Functions.htm#ByRef">ByRef-Marker (&amp;)</a> gibt an, dass der Aufrufer eine Variablenreferenz übergeben muss. Innerhalb der Funktion greift jede Referenz, die auf den Parameter verweist, eigentlich auf die Variable des Aufrufers zu. Dies ähnelt dem Weglassen von <code>&amp;</code> und der expliziten <a href="Variables.htm#deref">Dereferenzierung</a> des Parameters innerhalb der Funktion (z.B. <code>%Dritter%</code>), außer dass in diesem Fall die Prozentzeichen weggelassen werden. Wenn der Parameter optional ist und der Aufrufer ihn weglässt, verhält sich der Parameter wie eine normale lokale Variable.</p>
<p>Um einen <a href="Functions.htm#optional">optionalen</a> Parameter anzugeben, müssen Sie nach dem Parameternamen <code>:=</code> anfügen, gefolgt von einer direkt geschriebenen, in Anführungszeichen gesetzten Zeichenkette, einer Zahl, <code>true</code>, <code>false</code> oder <code>unset</code>.</p>
<p>Die Funktion kann <a href="Functions.htm#return">einen Wert via Return zurückgeben</a>. Wenn sie das nicht tut, gibt sie standardmäßig eine leere Zeichenkette zurück.</p>
<p>Eine Funktionsdefinition muss nicht vor dem Aufruf dieser Funktion stehen.</p>
<p class="note">Einzelheiten finden Sie unter <a href="Functions.htm">Funktionen</a>.</p>

<h3 id="-include">#Include</h3>
<p>Die <a href="lib/_Include.htm">#Include</a>-Direktive veranlasst das Skript, sich so zu verhalten, als wäre der Inhalt einer bestimmten Datei an genau dieser Stelle vorhanden. Dies wird oft verwendet, um Code in separate Dateien aufzuteilen oder um Skriptbibliotheken anderer Benutzer zu verwenden.</p>
<p>Eine #Include-Datei kann <a href="#global-code">globalen Code</a> für die <a href="Scripts.htm#auto">Startphase des Skripts</a> enthalten, allerdings wird solcher Code nur ausgeführt (analog zum Code in der Hauptskriptdatei), wenn der Auto-Execute-Thread nicht bereits vor der #Include-Direktive terminiert wird (z.B. mit einem bedingungslosen <code>return</code>). Standardmäßig wird eine <a href="lib/_Warn.htm#Unreachable">Warnung</a> angezeigt, wenn ein Code durch ein vorheriges <code>return</code> nicht ausgeführt werden kann.</p>
<p>Im Gegensatz zu C/C++ macht #Include nichts, wenn die Datei bereits durch eine frühere Direktive inkludiert wurde. Um den Inhalt einer Datei mehrfach zu inkludieren, verwenden Sie <a href="lib/_Include.htm">#IncludeAgain</a>.</p>
<p>Um die gemeinsame Nutzung von Skripten zu erleichtern, sucht #Include an vordefinierten Orten nach einem Bibliotheksskript. Weitere Informationen finden Sie unter <a href="Scripts.htm#lib">Skriptbibliotheksordner</a>.</p>

<h2 id="misc">Verschiedenes</h2>

<h3 id="dynamic-variables">Dynamische Variablen</h3>
<p>Eine <em>dynamische Variablenreferenz</em> nimmt einen Textwert und interpretiert ihn als den Namen einer Variable.</p>
<p class="note"><strong>Hinweis:</strong> Eine Variable kann nicht durch eine dynamische Referenz <em>erstellt</em> werden, aber existierende Variablen können zugewiesen werden. Dies schließt alle Variablen ein, zu denen das Skript nicht-dynamische Referenzen enthält, auch wenn ihnen keine Werte zugewiesen wurden.</p>
<p>Die bekannteste Form einer dynamischen Variablenreferenz nennt sich <em>Doppeldereferenz</em> oder <em>double-deref</em>. Bevor eine Doppeldereferenzierung erfolgt, muss der Name der Zielvariable in einer zweiten Variable gespeichert werden. Diese zweite Variable kann verwendet werden, um der Zielvariable indirekt einen Wert via Doppeldereferenzierung zuzuweisen. Zum Beispiel:</p>
<pre>Ziel := 42
ZweiteVar := "Ziel"
MsgBox  ZweiteVar   <em>; Normale (einfache) Variablenreferenz =&gt; Ziel</em>
MsgBox %ZweiteVar%  <em>; Doppeldereferenz =&gt; 42</em>
</pre>
<p>Momentan muss <code>ZweiteVar</code> im zweiten Fall immer einen Variablennamen enthalten; beliebige Ausdrücke werden nicht unterstützt.</p>
<p>Eine dynamische Variablenreferenz kann auch einen oder mehrere direkt geschriebene Texte und den Inhalt einer oder mehrerer Variablen zu einem einzigen Variablennamen zusammenfassen. Schreiben Sie einfach die Bestandteile des Namens und die mit Prozentzeichen umschlossenen Variablen der Reihe nach ohne Leerzeichen auf. Zum Beispiel: <code>MeinArray%A_Index%</code> oder <code>MeinRaster%X%_%Y%</code>. Dies ermöglicht den Zugriff auf <em>Pseudo-Arrays</em>, wie unten beschrieben.</p>
<p>Diese Techniken können auch auf Eigenschaften und Methoden von Objekten angewendet werden. Zum Beispiel:</p>
<pre>Farbe := {}
for n, Komponente in ["Rot", "Grün", "Blau"]
    Farbe.%Komponente% := Random(0, 255)
MsgBox Farbe.Rot "," Farbe.Grün "," Farbe.Blau</pre>

<h4 id="pseudo-arrays">Pseudo-Arrays</h4>
<p>Ein <em>Pseudo-Array</em> ist eigentlich nur ein Haufen einzelner Variablen, deren Namensmuster es aber möglich machen, sie wie Elemente eines Arrays zu verwenden. Zum Beispiel:</p>
<pre>
MeinArray1 := "A"
MeinArray2 := "B"
MeinArray3 := "C"
Loop 3
    MsgBox MeinArray%A_Index%  <em>; Zeigt A, dann B, dann C.</em>
</pre>
<p>Der "Index", mit dem der endgültige Variablenname gebildet wurde, muss nicht numerisch sein; er kann auch ein Buchstabe oder Schlüsselwort sein.</p>
<p>Aus diesen Gründen ist es in der Regel ratsam, ein <a href="Objects.htm#Usage_Simple_Arrays">Array</a> oder <a href="Objects.htm#Usage_Associative_Arrays">Map</a> anstelle eines Pseudo-Arrays zu verwenden:</p>
<ul>
  <li>Da es sich bei den einzelnen Elementen um normale Variablen handelt, kann man zwar einen Wert zuweisen oder abrufen, aber keine Elemente <em>entfernen</em> oder <em>einfügen</em>.</li>
  <li>Da das Pseudo-Array nur konzeptionell und kein Einzelwert ist, kann es nicht an eine Funktion übergeben oder von einer Funktion zurückgegeben werden, oder als Ganzes kopiert werden.</li>
  <li>Ein Pseudo-Array kann nicht als Ganzes deklariert werden, daher können einige "Elemente" in <a href="Functions.htm#Global">globale</a> (oder <a href="Functions.htm#capture-var">erfasste</a>) Variablen aufgelöst werden, andere jedoch nicht.</li>
  <li>Wenn eine Variable nicht-dynamisch referenziert, sondern nur dynamisch zugewiesen wird, kann eine <a href="lib/_Warn.htm#VarUnset">Ladezeitwarnung</a> angezeigt werden. Solche Warnungen sind eine effektive Hilfe bei der Fehlersuche und sollten daher nicht deaktiviert werden.</li>
  <li>Derzeit ist es nicht möglich, neue Variablen dynamisch zu erstellen. Dies dient einerseits der Förderung von Best Practices und andererseits der Vermeidung von Unstimmigkeiten zwischen dynamischen und nicht-dynamischen Variablenreferenzen in Funktionen.</li>
</ul>

<h3 id="labels">Labels</h3>
<p>Ein Label identifiziert eine Codezeile und kann als <a href="lib/Goto.htm">Goto</a>-Ziel oder zum <a href="#named-loops">Unterbrechen oder Fortsetzen einer bestimmten Schleife</a> verwendet werden. Ein Label besteht aus einem <a href="Concepts.htm#names">Namen</a> gefolgt von einem Doppelpunkt:</p>
<pre>das_ist_ein_Label:</pre>
<p>Abgesehen von Leerraumzeichen und Kommentaren darf kein weiterer Code auf der Zeile eines Labels stehen. Weitere Informationen finden Sie unter <a href="misc/Labels.htm">Labels</a>.</p>
</body>
</html>
