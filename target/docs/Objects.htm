<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Objekte - Definition &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Wie man Objekte verwendet, neue Objekttypen definiert und weitere Details zur Funktionsweise von Objekten in AutoHotkey." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p>Ein <i>Objekt</i> ist eine Kombination aus <em>Eigenschaften</em> und <a href="Concepts.htm#methods"><em>Methoden</em></a>.</p>
<p>Verwandte Themen:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objekte</a>: Allgemeine Erklärung von Objekten.</li>
  <li><a href="Concepts.htm#object-protocol">Objektorientierte Schnittstelle</a>: Einzelheiten darüber, wie ein Skript mit einem Objekt interagiert.</li>
  <li><a href="misc/Functor.htm">Funktionsobjekte</a>: Objekte, die <em>aufgerufen</em> werden können.</li>
</ul>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Eine Liste von Standardobjekttypen finden Sie unter <a href="ObjList.htm">Interne Klassen</a>. Es gibt zwei Grundtypen:</p>
<ul>
  <li><strong>AutoHotkey-Objekte</strong> sind Instanzen der <a href="lib/Object.htm">Object</a>-Klasse. Solche Objekte unterstützen Ad-hoc-Eigenschaften, und haben Methoden, um herauszufinden, welche Eigenschaften existieren. <a href="lib/Array.htm">Array</a>, <a href="lib/Map.htm">Map</a> und alle benutzerdefinierten und internen Klassen sind von der Object-Klasse abgeleitet.</li>
  <li><strong>COM-Objekte</strong>, wie solche, die via <a href="lib/ComObject.htm">ComObject</a> erstellt werden. Solche Objekte sind von externen Bibliotheken implementiert und haben daher oft ein anderes Verhalten als AutoHotkey-Objekte. ComObject repräsentiert typischerweise ein COM- oder "Automation"-Objekt, das die <a href="https://learn.microsoft.com/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch-Schnittstelle</a> implementiert, wird aber auch verwendet, um <a href="lib/ComValue.htm">Werte bestimmter Typen zu wrappen</a>, die an COM-Objekte und -Funktionen übergeben werden sollen.</li>
</ul>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlegende Verwendung</a>
    <ul>
      <li><a href="#Usage_Simple_Arrays">Arrays</a></li>
      <li><a href="#Usage_Associative_Arrays">Maps (assoziative Arrays)</a></li>
      <li><a href="#Usage_Objects">Objekte</a></li>
      <li><a href="#object-literal">Objektliteral</a></li>
      <li><a href="#Usage_Freeing_Objects">Objekte freigeben</a></li>
    </ul>
  </li>
  <li><a href="#Extended_Usage">Erweiterte Verwendung</a>
    <ul>
      <li><a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a></li>
    </ul>
  </li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a>
    <ul>
      <li><a href="#ad-hoc">Ad Hoc</a></li>
      <li><a href="#delegation">Delegation</a></li>
      <li><a href="#creating-a-base-object">Basisobjekt erstellen</a></li>
      <li><a href="#Custom_Classes">Klassen</a></li>
      <li><a href="#__Enum">__Enum-Methode</a></li>
      <li><a href="#__Item">__Item-Eigenschaft</a></li>
      <li><a href="#Custom_NewDelete">Konstruktion und Destruktion</a></li>
      <li><a href="#Meta_Functions">Metafunktionen</a></li>
    </ul>
  </li>
  <li><a href="#primitive">Primitive Werte</a>
    <ul>
      <li><a href="#primitive-extension">Eigenschaften und Methoden hinzufügen</a></li>
    </ul>
  </li>
  <li><a href="#Implementation">Implementierung</a>
    <ul>
      <li><a href="#Reference_Counting">Referenzzählung</a></li>
      <li><a href="#ObjPtr">Objektpointer</a></li>
    </ul>
  </li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Grundlegende Verwendung</h2>

<h3 id="Usage_Simple_Arrays">Arrays</h3>
<p>Erstellen eines <a href="lib/Array.htm">Arrays</a>:</p>
<pre>MeinArray := [Element1, Element2, ..., ElementN]
MeinArray := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements:<em></em></p>
<pre>Wert := MeinArray[Index]</pre>
<p>Ändern eines Elementwertes (<code>Index</code> muss zwischen 1 und Länge liegen oder ein äquivalenter umgekehrter Index sein):</p>
<pre>MeinArray[Index] := Wert</pre>
<p>Einfügen eines oder mehrerer Elemente ab einem bestimmten Index via <a href="lib/Array.htm#InsertAt">InsertAt</a>-Methode:</p>
<pre>MeinArray.InsertAt(Index, Wert, Wert2, ...)</pre>
<p>Anfügen eines oder mehrerer Elemente via <a href="lib/Array.htm#Push">Push</a>-Methode:</p>
<pre>MeinArray.Push(Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements via <a href="lib/Array.htm#RemoveAt">RemoveAt</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.RemoveAt(Index)</pre>
<p>Entfernen eines Elements via <a href="lib/Array.htm#Pop">Pop</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.Pop()</pre>
<p><a href="lib/Array.htm#Length">Length</a> gibt die Anzahl der Elemente im Array zurück. Um die Elemente eines Arrays einzeln durchzugehen, verwenden Sie entweder A_Index oder eine For-Schleife. Zum Beispiel:</p>
<pre>MeinArray := ["eins", "zwei", "drei"]

<em>; Von 1 bis zum Ende des Arrays iterieren:</em>
Loop MeinArray.Length
    MsgBox MeinArray[A_Index]

<em>; Den Inhalt des Arrays enumerieren:</em>
For Index, Wert in MeinArray
    MsgBox "Element " Index " ist '" Wert "'"
    
<em>; Dasselbe noch einmal:</em>
For Wert in MeinArray
    MsgBox "Element " A_Index " ist '" Wert "'"
</pre>

<h3 id="Usage_Associative_Arrays">Maps (assoziative Arrays)</h3>
<p>Ein <a href="lib/Map.htm">Map</a> oder assoziatives Array ist ein Objekt, das eine Sammlung von eindeutigen Schlüsseln und eine Sammlung von Werten enthält, wobei jeder Schlüssel mit einem Wert verbunden ist. Schlüssel können Zeichenketten, Integer oder Objekte sein, während Werte von beliebigem Typ sein können. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>MeinMap := Map("SchlüsselA", WertA, "SchlüsselB", WertB, ..., "SchlüsselZ", WertZ)</pre>
<p>Abrufen eines Elements, wobei <code>Schlüssel</code> eine <a href="Concepts.htm#variables">Variable</a> oder ein <a href="Language.htm#expressions">Ausdruck</a> ist:</p>
<pre>Wert := MeinMap[Schlüssel]</pre>
<p>Zuweisen eines Elements:</p>
<pre>MeinMap[Schlüssel] := Wert</pre>
<p>Entfernen eines Elements via <a href="lib/Array.htm#Delete">Delete</a>-Methode:</p>
<pre>EntfernterWert := MeinMap.Delete(Schlüssel)</pre>
<p>Enumerieren von Elementen:</p>
<pre>MeinMap := Map("zehn", 10, "zwanzig", 20, "dreißig", 30)
<a href="lib/For.htm">For</a> Schlüssel, Wert in MeinMap
    MsgBox Schlüssel ' = ' Wert</pre>

<h3 id="Usage_Objects">Objekte</h3>
<p>Ein Objekt kann <em>Eigenschaften</em> und <em>Elemente</em> (z.B. Array-Elemente) haben. Der Zugriff auf Elemente erfolgt über <code>[]</code>, wie in den vorherigen Abschnitten gezeigt. Der Zugriff auf Eigenschaften erfolgt durch Anfügen eines Punktes und einem Identifikator (einfach ein <a href="Concepts.htm#names">Name</a>). <em>Methoden</em> sind Eigenschaften, die aufgerufen werden können.</p>
<p><strong>Beispiele:</strong></p>
<p>Abrufen oder Setzen einer Eigenschaft mit dem direkt geschriebenen Namen <em>Eigenschaft</em>:</p>
<pre>Wert := MeinObjekt.Eigenschaft</pre>
<pre>MeinObjekt.Eigenschaft := Wert</pre>
<p>Abrufen oder Setzen einer Eigenschaft mit einem via <a href="Language.htm#expressions">Ausdruck</a> oder <a href="Concepts.htm#variables">Variable</a> ermittelten Namen:</p>
<pre>Wert := MeinObjekt.%Ausdruck%</pre>
<pre>MeinObjekt.%Ausdruck% := Wert</pre>
<p>Aufrufen einer Eigenschaft/Methode mit dem direkt geschriebenen Namen <em>Methode</em>:</p>
<pre>RückgabeWert := MeinObjekt.Methode(Params)</pre>
<p>Aufrufen einer Eigenschaft/Methode mit einem via Ausdruck oder Variable ermittelten Namen:</p>
<pre>RückgabeWert := MeinObjekt.%Ausdruck%(Params)</pre>
<p>Manchmal werden beim Abrufen oder Zuweisen von Eigenschaften Parameter akzeptiert:</p>
<pre>Wert := MeinObjekt.Eigenschaft[Params]
MeinObjekt.Eigenschaft[Params] := Wert</pre>
<p>Ein Objekt kann auch Indexierung unterstützen: <code>MeinArray[Index]</code> ruft indirekt die <a href="#__Item">__Item</a>-Eigenschaft von <code>MeinArray</code> auf und übergibt <code>Index</code> als Parameter.</p>

<h3 id="object-literal">Objektliteral</h3>
<p>Ein Objektliteral (direkt geschriebenes Objekt) kann in einem <a href="Language.htm#expressions">Ausdruck</a> verwendet werden, um ein improvisiertes Objekt zu erstellen. Ein Objektliteral besteht aus zwei geschweiften Klammern (<code>{}</code>), die eine Liste von kommagetrennten Name-Wert-Paaren umschließen. Jedes Paar besteht aus einem direkt geschriebenen (anführungszeichenlosen) <a href="Concepts.htm#names">Eigenschaftsnamen</a> und einem Wert (Teilausdruck), die mit einem Doppelpunkt (<code>:</code>) voneinander getrennt sind. Zum Beispiel:</p>
<pre>Koord := {X: 13, Y: 240}</pre>
<p>Folgendes ist äquivalent:</p>
<pre>Koord := Object()
Koord.X := 13
Koord.Y := 240</pre>
<p>Jedes Name-Wert-Paar definiert eine Werteigenschaft, mit der Ausnahme, dass <a href="lib/Object.htm#Base">Base</a> gesetzt werden kann (mit den gleichen Einschränkungen wie bei einer normalen Zuweisung).</p>
<p><a href="Variables.htm#deref">Namenssubstitution</a> ermöglicht die Bestimmung eines Eigenschaftsnamens durch Auswertung eines <a href="Language.htm#expressions">Ausdrucks</a> oder einer <a href="Concepts.htm#variables">Variable</a>. Zum Beispiel:</p>
<pre>Teile := StrSplit("Schlüssel = Wert", "=", " ")
Teil := {%Teile[1]%: Teile[2]}
MsgBox Teil.Schlüssel</pre>

<h3 id="Usage_Freeing_Objects">Objekte freigeben</h3>
<p>Skripte geben Objekte nicht explizit frei. Sobald die letzte Referenz zu einem Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Eine Referenz, die in einer Variable gespeichert ist, wird automatisch freigegeben, sobald dieser Variable ein anderer Wert zugewiesen wird. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt die letzte Referenz frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>Gleichermaßen wird eine Referenz, die in einer Eigenschaft oder einem Array-Element gespeichert ist, freigegeben, wenn diese Eigenschaft oder dieses Array-Element einen anderen Wert zugewiesen bekommt oder aus dem Objekt entfernt wird.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.RemoveAt(1)  <em>; Entfernt das zweite Objekt und gibt es frei.</em></pre>
<p id="Circular_References">Da alle Referenzen zu einem Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn z.B. <code>x.child</code> auf <code>y</code> und <code>y.parent</code> auf <code>x</code> verweist, genügt es nicht, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch eine Referenz zum Child-Objekt enthält, und umgekehrt. Um diese Situation zu lösen, entfernen Sie den Zirkelbezug.</p>
<pre>
x := {}, y := {}             <em>; Zwei Objekte erstellen.</em>
x.child := y, y.parent := x  <em>; Einen Zirkelbezug erstellen.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Ohne die obige Zeile würde dies die Objekte nicht freigeben.</em>
</pre>
<p>Eine ausführlichere Verwendung und Informationen finden Sie unter <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h2 id="Extended_Usage">Erweiterte Verwendung</h2>

<h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
<p>Obwohl "mehrdimensionale" Arrays nicht unterstützt werden, kann ein Skript mehrere Arrays oder Maps kombinieren. Zum Beispiel:</p>
<pre>
Gitter := [[1,2,3],
           [4,5,6],
           [7,8,9]]
MsgBox Gitter[1][3] <em>; 3</em>
MsgBox Gitter[3][2] <em>; 8</em>
</pre>
<p id="Array2D">Ein benutzerdefiniertes Objekt kann mehrdimensionale Unterstützung durch Definition einer <a href="#__Item">__Item</a>-Eigenschaft implementieren. Zum Beispiel:</p>
<pre>
class Array2D extends Array {
    __new(x, y) {
        this.Length := x * y
        this.Breite := x
        this.Höhe := y
    }
    __Item[x, y] {
        get =&gt; super.Has(this.i[x, y]) ? super[this.i[x, y]] : false
        set =&gt; super[this.i[x, y]] := value
    }
    i[x, y] =&gt; this.Breite * (y-1) + x
}

Gitter := Array2D(4, 3)
Gitter[4, 1] := "#"
Gitter[3, 2] := "#"
Gitter[2, 2] := "#"
Gitter[1, 3] := "#"
GitterText := ""
Loop Gitter.Höhe {
    y := A_Index
    Loop Gitter.Breite {
        x := A_Index
        GitterText .= Gitter[x, y] || "-"
    }
    GitterText .= "`n"
}
MsgBox GitterText
</pre>
<p>Ein echtes Skript sollte eine Fehlerprüfung durchführen und andere Methoden überschreiben, wie z.B. <a href="#__Enum">__Enum</a>, um die Enumeration zu unterstützen.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Es gibt zwei verschiedene Möglichkeiten, benutzerdefinierte Objekte zu erstellen:</p>
<ul>
  <li><em>Ad hoc</em>: Ein Objekt erstellen und Eigenschaften hinzufügen.</li>
  <li><em>Delegation</em>: Eigenschaften in einem <em>Basisobjekt</em> oder einer Klasse definieren.</li>
</ul>
<p><a href="#Meta_Functions">Metafunktionen</a> können verwendet werden, um das Verhalten eines Objekts genauer zu steuern.</p>
<p class="note"><strong>Hinweis:</strong> In diesem Abschnitt ist ein <em>Objekt</em> eine Instanz der <a href="lib/Object.htm">Object</a>-Klasse. Dieser Abschnitt gilt nicht für COM-Objekte.</p>

<h3 id="ad-hoc">Ad Hoc</h3>
<p>Grundsätzlich kann ein neues Objekt jederzeit um Eigenschaften und Methoden (aufrufbare Eigenschaften) erweitert werden. Das folgende Beispiel zeigt, wie ein Objekt mit einer Eigenschaft und einer Methode konstruiert werden kann:</p>
<pre><em>; Ein Objekt erstellen.</em>
obj := {}
<em>; Einen Wert speichern.</em>
obj.foo := "bar"
<em>; Eine Methode definieren.</em>
obj.test := obj_test
<em>; Die Methode aufrufen.</em>
obj.test()

obj_test(this) {
    MsgBox this.foo
}</pre>
<p>Das obige Objekt kann auch mit <code>obj := {foo: "bar"}</code> erstellt werden. Bei der {Eigenschaft:Wert}-Schreibweise dürfen die Eigenschaften nicht in Anführungszeichen gesetzt werden.</p>
<p>Beim Aufruf von <code>obj.test()</code> wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Konventionsgemäß setzt sich der Name der Funktion aus dem "Typ" des Objekts und dem Namen der Methode zusammen, kann aber auch anders lauten.</p>
<p>Im obigen Beispiel kann <em>test</em>, nachdem es definiert wurde, eine andere Funktion oder ein anderer Wert zugewiesen werden; in diesem Fall geht die ursprüngliche Funktion verloren und kann nicht über diese Eigenschaft aufgerufen werden. Alternativ kann eine schreibgeschützte Methode definiert werden:</p>
<pre>obj.DefineProp('test', {call: obj_test})</pre>
<p>Siehe auch: <a href="lib/Object.htm#DefineProp">DefineProp</a></p>

<h3 id="delegation">Delegation</h3>
<p>Objekte sind <em>prototypenbasiert</em>. Das heißt, dass alle Eigenschaften, die nicht im Objekt selbst definiert sind, stattdessen in der <a href="lib/Object.htm#Base">Basis</a> des Objekts definiert sein können. Dies wird als <em>Vererbung durch Delegation</em> oder <em>differentielle Vererbung</em> bezeichnet, da ein Objekt nur die Teile implementieren kann, die sich vom Objekt unterscheiden, und den Rest an seine Basis delegiert.</p>
<p>Obwohl ein Basisobjekt allgemein auch als Prototyp bekannt ist, verwenden wir "<a href="lib/Class.htm#Prototype">Prototyp</a> einer Klasse" für das Objekt, auf dem jede Instanz der Klasse basiert, und "Basis" für das Objekt, auf dem eine Instanz basiert.</p>
<p class="note">Das Objektdesign von AutoHotkey wurde hauptsächlich von JavaScript und Lua und ein wenig von C# beeinflusst. Wir verwenden <code><i>obj</i>.base</code> anstelle von JavaScripts <code><i>obj</i>.__proto__</code> und <code><i>cls</i>.Prototype</code> anstelle von JavaScripts <code><i>func</i>.prototype</code>. (Klassenobjekte werden anstelle von Konstruktorfunktionen verwendet.)</p>

<p>Die Basis eines Objekts wird auch verwendet, um seinen Typ oder seine Klasse zu identifizieren. Zum Beispiel erstellt <code>x := []</code> ein Objekt <em>basierend auf</em> <code>Array.Prototype</code>, d.h. die Ausdrücke <code>x is Array</code> und <code>x.HasBase(Array.Prototype)</code> sind True und <code>type(x)</code> gibt "Array" zurück. Der Prototyp jeder Klasse basiert auf dem Prototyp ihrer Basisklasse, daher ist <code>x.HasBase(Object.Prototype)</code> ebenfalls True.</p>
<p>Jede Instanz von Object oder eine abgeleitete Klasse kann ein Basisobjekt sein, aber ein Objekt kann nur <a href="lib/Object.htm#Base">als Basis</a> eines Objekts mit dem gleichen nativen Typ zugewiesen werden. Dadurch wird sichergestellt, dass interne Methoden immer den nativen Typ eines Objekts identifizieren können und dass sie nur mit Objekten arbeiten, die die korrekte binäre Struktur aufweisen.</p>
<p>Basisobjekte können auf zwei verschiedene Arten definiert werden:</p>
<ul>
  <li>Durch <a href="#creating-a-base-object">Erstellen eines normalen Objekts</a>.</li>
  <li>Durch <a href="#Custom_Classes">Definieren einer Klasse</a>. Jede Klasse hat eine <a href="lib/Class.htm#Prototype">Prototype</a>-Eigenschaft, die ein Objekt enthält, auf dem alle Instanzen dieser Klasse basieren, während die Klasse selbst zum Basisobjekt aller direkten Unterklassen wird.</li>
</ul>
<p>Ein Basisobjekt kann der <a href="lib/Object.htm#Base">Base</a>-Eigenschaft eines anderen Objekts zugewiesen werden, aber normalerweise wird die Basis eines Objekts implizit beim Erstellen festgelegt.</p>

<h3 id="creating-a-base-object">Basisobjekt erstellen</h3>
<p>Jedes Objekt kann als Basis eines anderen Objekts mit demselben nativen Typ verwendet werden. Das folgende Beispiel baut auf dem vorherigen Beispiel unter <a href="#ad-hoc">Ad Hoc</a> auf (kombinieren Sie beide vor der Ausführung):</p>
<pre>anderesObj := {}
anderesObj.base := obj
anderesObj.test()</pre>
<p><i>anderesObj</i> erbt in diesem Fall <i>foo</i> und <i>test</i> von <i>obj</i>. Diese Vererbung ist dynamisch, d.h. wenn <code>obj.foo</code> geändert wird, wird diese Änderung durch <code>anderesObj.foo</code> widergespiegelt. Wenn das Skript <code>anderesObj.foo</code> einen Wert zuweist, wird dieser Wert in <i>anderesObj</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Effekt auf <code>anderesObj.foo</code>. Beim Aufruf von <code>anderesObj.test()</code> enthält dessen <i>this</i>-Parameter eine Referenz zu <i>anderesObj</i> statt zu <i>obj</i>.</p>

<h3 id="Custom_Classes">Klassen</h3>
<blockquote>Unter einer Klasse (auch Objekttyp genannt) versteht man in der objektorientierten Programmierung ein abstraktes Modell bzw. einen Bauplan für eine Reihe von ähnlichen Objekten. <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)" class="source">Wikipedia</a></blockquote>
<p>Allgemein ausgedrückt ist eine <em>Klasse</em> eine Gruppe oder Kategorie von Dingen, die gemeinsame Eigenschaften oder Attribute haben. In AutoHotkey definiert <code>class</code> Eigenschaften, die von Instanzen der Klasse gemeinsam verwendet werden (und Methoden, die aufrufbare Eigenschaften sind). Eine <em>Instanz</em> ist schlicht ein Objekt, das Eigenschaften von der Klasse erbt und typischerweise auch als Teil dieser Klasse verstanden werden kann (z.B. mit dem Ausdruck <code><i>Instanz</i> is <i>KlasseName</i></code>). Instanzen werden typischerweise durch den Aufruf von <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erzeugt.</p>
<p>Da <a href="lib/Object.htm">Objekte</a> <a href="#ad-hoc">dynamisch</a> und <a href="#delegation">prototypenbasiert</a> sind, besteht jede Klasse aus zwei Teilen:</p>
<ul>
  <li>Die Klasse hat ein <a href="lib/Class.htm#Prototype">Prototypobjekt</a>, auf dem alle Instanzen der Klasse basieren. Alle Methoden und dynamischen Eigenschaften, die sich auf Instanzen der Klasse beziehen, sind im Prototypobjekt enthalten. Dazu gehören alle Eigenschaften und Methoden, denen das Schlüsselwort <code>static</code> fehlt.</li>
  <li>Die Klasse selbst ist ein Objekt, das nur statische Methoden und Eigenschaften enthält. Dazu gehören alle Eigenschaften und Methoden mit dem Schlüsselwort <code>static</code> und alle verschachtelten Klassen. Diese gelten nicht für eine bestimmte Instanz und können verwendet werden, indem via Name auf die Klasse selbst verwiesen wird.</li>
</ul>
<p>Das Folgende zeigt die meisten Elemente einer Klassendefinition:</p>
<pre>class KlasseName extends BasisklasseName
{
    InstanzVar := <i>Ausdruck</i>
    
    static KlasseVar := <i>Ausdruck</i>

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }
    
    static Methode()
    {
        ...
    }

    Eigenschaft[<i>Parameter</i>]  <em>; Eckige Klammern nur verwenden, wenn Parameter vorhanden sind.</em>
    {
        <span class="dec">get</span> {
            return <i>Eigenschaftswert</i>
        }
        <span class="dec">set</span> {
            <i>Speichere oder verarbeite</i> <span class="biv">value</span>
        }
    }
    
    KurzeEigenschaft
    {
        <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
        <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
    }
    
    KürzereEigenschaft =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
}
</pre>
<p>Dies bewirkt, dass beim Laden des Skripts ein <a href="lib/Class.htm">Class</a>-Objekt konstruiert und in eine <a href="Functions.htm#Global">globale</a> Konstante (schreibgeschützte Variable) namens <i>KlasseName</i> gespeichert wird. Wenn <code class="no-highlight">extends BasisklasseName</code> vorhanden ist, muss <i>BasisklasseName</i> der vollständige Name einer anderen Klasse sein. Der vollständige Name jeder Klasse ist in <code><i>KlasseName</i>.Prototype.__Class</code> gespeichert.</p>
<p>Da der Zugriff auf die Klasse selbst über eine Variable erfolgt, kann der Klassenname nicht verwendet werden, um im selben Kontext sowohl die Klasse zu referenzieren als auch eine separate Variable zu erstellen (um z.B. eine Instanz der Klasse zu enthalten). Zum Beispiel wird <code>box := Box()</code> nicht funktionieren, da sowohl <code>box</code> als auch <code>Box</code> in dasselbe aufgelöst werden. Der Versuch, eine Top-Level-Klasse (nicht verschachtelte Klasse) auf diese Weise neu zuzuweisen, führt zu einem Ladezeitfehler.</p>
<p>In dieser Dokumentation bezieht sich das Wort "Klasse" in der Regel auf ein Klassenobjekt, das mit dem Schlüsselwort <code>class</code> erstellt wurde.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen</h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert und verhalten sich auch wie solche, aber ohne Angabe des Präfixes <code>this.</code> (nur direkt im Körper der Klasse):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erstellt wird, nachdem alle Basisklassendeklarationen ausgewertet wurden, aber bevor <a href="#Custom_NewDelete">__New</a> aufgerufen wird. Dies wird erreicht, indem automatisch eine Methode namens <em>__Init</em> erstellt wird, die einen Aufruf von <code>super.__Init()</code> enthält, und jede Deklaration in diese eingefügt wird. Daher darf eine einzelne Klassendefinition weder eine __Init-Methode noch eine Instanzvariablendeklaration enthalten.</p>
<p><em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen. Globale Variablen können gelesen, aber nicht zugewiesen werden. Eine zusätzliche Zuweisung (oder die Verwendung des <a href="Variables.htm#ref">Referenzoperators</a>) innerhalb des Ausdrucks erzeugt in der Regel eine Variable, die lokal für die __Init-Methode ist. Zum Beispiel bewirkt <code>x := y := 1</code>, dass <code>this.x</code> und eine lokale Variable <code>y</code> gesetzt wird (die nach der Auswertung aller Initialisierungen wieder freigegeben wird).</p>
<p>Um auf eine Instanzvariable zuzugreifen (auch innerhalb einer Methode), geben Sie immer das Zielobjekt an, z.B. <code><b>this</b>.InstanzVar</code>.</p>
<p>Deklarationen wie <code>x.y := z</code> werden ebenfalls unterstützt, sofern vorher <code>x</code> in dieser Klasse definiert wurde. Zum Beispiel bewirkt <code>x := {}, x.y := 42</code>, dass <code>x</code> deklariert und außerdem <code>this.x.y</code> initialisiert wird.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen</h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, aber ihre Werte können von Unterklassen geerbt werden. Solche Variablen müssen mit dem Schlüsselwort "static" deklariert werden:</p>
<pre>static KlasseVar := Ausdruck</pre>
<p>Diese Deklarationen werden nur einmal beim <a href="#static__New">Initialisieren</a> der Klasse ausgewertet. Zu diesem Zweck wird automatisch eine statische Methode namens <em>__Init</em> definiert.</p>
<p>Jede Deklaration fungiert wie eine normale Eigenschaftszuweisung, mit dem Klassenobjekt als Ziel. <em>Ausdruck</em> wird genauso interpretiert wie die Instanzvariablen, außer dass <code>this</code> auf die Klasse selbst verweist.</p>
<p>Um einer Klassenvariable an anderer Stelle etwas zuzuweisen, geben Sie immer das Klassenobjekt an, z.B. <code><b>KlasseName</b>.KlasseVar := Wert</code>. Wenn eine Unterklasse keine Eigenschaft mit diesem Namen hat, kann auch mit <code><i>Unterklasse</i>.KlasseVar</code> der Wert abgerufen werden, d.h. wenn der Wert eine Referenz zu einem Objekt ist, teilen sich die Unterklassen standardmäßig dieses Objekt. Allerdings würde <code><i>Unterklasse</i>.KlasseVar := y</code> den Wert in <em>Unterklasse</em> speichern, nicht in <em>KlasseName</em>.</p>
<p>Deklarationen wie <code>static x.y := z</code> werden ebenfalls unterstützt, sofern vorher <code>x</code> in dieser Klasse definiert wurde. Zum Beispiel bewirkt <code>static x := {}, x.y := 42</code>, dass <code>x</code> deklariert und außerdem <code><i>KlasseName</i>.x.y</code> initialisiert wird. Da <a href="lib/Class.htm#Prototype">Prototype</a> implizit in jeder Klasse definiert ist, können mit <code>static Prototype.geteilterWert := 1</code> Werte gesetzt werden, die dynamisch von allen Instanzen der Klasse geerbt werden (bis sie durch eine Eigenschaft der Instanz selbst "überschrieben" werden).</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Verschachtelte Klassendefinitionen ermöglichen es, ein Klassenobjekt mit einer statischen bzw. Klassenvariable der äußeren Klasse zu assoziieren, anstatt mit einer separaten globalen Variablen. Im obigen Beispiel konstruiert <code>class VerschachtelteKlasse</code> ein <a href="lib/Class.htm">Class</a>-Objekt und speichert es in <code>KlasseName.VerschachtelteKlasse</code>. Unterklassen können <em>VerschachtelteKlasse</em> erben oder es mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall kann mit <code><i>WelcheKlasse</i>.VerschachtelteKlasse()</code> die entsprechende Klasse instanziiert werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>
<p>Das Verschachteln einer Klasse impliziert keine besondere Beziehung zur äußeren Klasse. Weder wird die verschachtelte Klasse automatisch instanziiert, noch haben Instanzen der verschachtelten Klasse eine Verbindung zu einer Instanz der äußeren Klasse, es sei denn, das Skript stellt diese Verbindung explizit her.</p>
<p>Jede verschachtelte Klassendefinition erzeugt eine dynamische Eigenschaft mit <em>Get</em>- und <em>Call</em>-Akzessorfunktionen anstelle einer einfachen Werteigenschaft. Damit soll das folgende Verhalten unterstützt werden (wobei die Klasse X die verschachtelte Klasse Y enthält):</p>
<ul>
<li><code>X.Y()</code> übergibt X nicht an <code>X.Y.Call</code> und letztlich an <code class="no-highlight">__New</code>, was sonst passieren würde, da dies das normale Verhalten für Funktionsobjekte ist, die als Methoden aufgerufen werden (so wie die verschachtelte Klasse hier verwendet wird).</li>
<li><code>X.Y := 1</code> ist standardmäßig ein Fehler (die Eigenschaft ist schreibgeschützt).</li>
<li>Die Klasse wird initialisiert, sobald sie das erste Mal referenziert oder aufgerufen wird.</li>
</ul>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methodendefinition erstellt ein <a href="lib/Func.htm">Func</a> mit einem versteckten ersten Parameter namens <code>this</code> und definiert eine Eigenschaft, die zum Aufrufen der Methode oder zum Abrufen ihres Funktionsobjekts verwendet wird.</p>
<p>Es gibt zwei Arten von Methoden:</p>
<ul>
  <li>Instanzmethoden werden wie folgt definiert und an den <a href="lib/Class.htm#Prototype">Prototyp</a> der Klasse gebunden, so dass sie über jede Instanz der Klasse zugänglich sind. Wenn die Methode aufgerufen wird, verweist <code>this</code> auf eine Instanz der Klasse.</li>
  <li>Um statische Methoden zu definieren, stellen Sie dem Methodennamen das separate Schlüsselwort <code>static</code> voran. Diese sind an das Klassenobjekt selbst gebunden, werden aber auch von Unterklassen geerbt, so dass <code>this</code> entweder auf die Klasse selbst oder auf eine Unterklasse verweist.</li>
</ul>
<p>Die Methodendefinition unten erstellt eine Eigenschaft vom gleichen Typ wie <code><i>Ziel</i>.DefineProp('Methode', {call: <i>funcObj</i>})</code>. Standardmäßig gibt <code><i>Ziel</i>.Methode</code> <em>funcObj</em> zurück, und der Versuch, <code><i>Ziel</i>.Methode</code> etwas zuzuweisen, löst einen Fehler aus. Diese Standardverhalten können durch <a href="#Custom_Classes_property">Definieren einer Eigenschaft</a> oder Aufrufen von <a href="lib/Object.htm#DefineProp">DefineProp</a> überschrieben werden.</p>
<pre>
Methode()
{
    ...
}
</pre>

<p>Mit der <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann eine einzeilige Methode definiert werden, die ein Ausdruck zurückgibt:</p>
<pre>Methode() =&gt; <i>Ausdruck</i></pre>

<h4 id="Custom_Classes_super">Super</h4>
<p>Innerhalb einer Methode oder eines Eigenschafts-Getters/Setters kann das Schlüsselwort <code>super</code> anstelle von <code>this</code> verwendet werden, um auf Superklassenversionen von Methoden oder Eigenschaften zuzugreifen, die in einer abgeleiteten Klasse überschrieben werden. Zum Beispiel würde <code>super.Methode()</code> in der oben definierten Klasse typischerweise eine Version von <em>Methode</em> aufrufen, die innerhalb von <em>BasisklasseName</em> definiert wurde. Hinweis:</p>
<ul>
  <li><code>super.Methode()</code> ruft immer indirekt die Basis der Klasse oder des Prototypobjekts auf, das mit der ursprünglichen Definition der aktuellen Methode assoziiert ist, auch dann, wenn <code>this</code> von einer <em>Unterklasse</em> dieser Klasse oder von einer ganz anderen Klasse abgeleitet wurde.</li>
  <li><code>super.Methode()</code> übergibt implizit <code>this</code> als ersten (versteckten) Parameter.</li>
  <li>Da nicht bekannt ist, wo (oder ob) <em>KlasseName</em> in der Kette von Basisobjekten existiert, wird <em>KlasseName</em> selbst als Ausgangspunkt verwendet. Daher ist <code>super.Methode()</code> meistens äquivalent zu <code>(<i>KlasseName</i>.Prototype.base.Methode)(this)</code> (aber ohne <em>Prototype</em>, wenn <em>Methode</em> statisch ist). Allerdings wird <code><i>KlasseName</i>.Prototype</code> beim Laden des Skripts aufgelöst.</li>
  <li>Es wird ein Fehler ausgelöst, wenn die Eigenschaft nicht in einer Superklasse definiert ist oder nicht indirekt aufgerufen werden kann.</li>
</ul>
<p>Nach dem Schlüsselwort <code>super</code> muss eines der folgenden Symbole folgen: <code>.[(</code></p>
<p><code>super()</code> ist äquivalent zu <code>super.call()</code>.</p>

<h4 id="Custom_Classes_property">Eigenschaften</h4>
<p>Eine Eigenschaftsdefinition erzeugt eine <a href="lib/Object.htm#DefineProp">dynamische Eigenschaft</a>, die eine Methode aufruft, anstatt nur einen Wert zu speichern oder zurückzugeben.</p>
<pre>Eigenschaft[<i>Parameter</i>]
{
    <span class="dec">get</span> {
        return <i>Eigenschaftswert</i>
    }
    <span class="dec">set</span> {
        <i>Speichere oder verarbeite</i> <span class="biv">value</span>
    }
}
</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, der für ihren indirekten Aufruf verwendet wird. Zum Beispiel bewirkt <code>obj.Eigenschaft</code>, dass <em>get</em> aufgerufen wird, und <code>obj.Eigenschaft := Wert</code>, dass <em>set</em> aufgerufen wird. Innerhalb von <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das gerade indirekt aufgerufen wird. Innerhalb von <em>set</em> enthält <code>value</code> den Wert, der gerade zugewiesen wird.</p>
<p>Die Definition und Übergabe von Parametern erfolgt rechts vom Eigenschaftsnamen in eckigen Klammern – diese sollten jedoch weggelassen werden, wenn keine Parameter vorhanden sind (siehe unten). Abgesehen von der Verwendung eckiger Klammern werden die Parameter von Eigenschaften genauso definiert wie die Parameter von Methoden – optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Wenn eine Eigenschaft mit Parametern indirekt aufgerufen wird, aber keine definiert sind, werden Parameter automatisch an die <a href="#__Item">__Item</a>-Eigenschaft des von <em>get</em> zurückgegebenen Objekts weitergeleitet. Zum Beispiel hätte <code>this.Eigenschaft[x]</code> denselben Effekt wie <code>(this.Eigenschaft)[x]</code> oder <code>y := this.Eigenschaft, y[x]</code>. Leere Klammern (<code>this.Eigenschaft[]</code>) führen dazu, dass die __Item-Eigenschaft des Wertes von <em>Eigenschaft</em> immer indirekt aufgerufen wird, aber ein variadischer Aufruf wie <code>this.Eigenschaft[Args*]</code> hat diesen Effekt nur, wenn die Anzahl der Parameter ungleich Null ist.</p>
<p>Um statische Eigenschaften zu definieren, stellen Sie dem Eigenschaftsnamen das separate Schlüsselwort <code>static</code> voran. In diesem Fall verweist <code>this</code> auf die Klasse selbst oder auf eine Unterklasse.</p>
<p>Der Rückgabewert von <em>set</em> wird ignoriert. Zum Beispiel wird <code>Wert := obj.Eigenschaft := 42</code> immer <code>Wert := 42</code> zuweisen, egal was die Eigenschaft macht, es sei denn, sie löst eine Ausnahme aus oder beendet den Thread.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie <code><a href="#Custom_Classes_super">super.Eigenschaft</a></code> verwenden, um auf die von ihrer Basisklasse definierte Eigenschaft zuzugreifen. Wenn <em>Get</em> oder <em>Set</em> nicht definiert ist, kann es von einem Basisobjekt geerbt werden. Wenn <em>Get</em> undefiniert ist, kann die Eigenschaft einen Wert zurückgeben, der von einer Basis geerbt wurde. Wenn <em>Set</em> in diesem und allen Basisobjekten undefiniert ist (oder von einer geerbten Werteigenschaft verschleiert wird), löst der Versuch, die Eigenschaft zu setzen, eine Ausnahme aus.</p>
<p>Eine Eigenschaftsdefinition mit sowohl <em>Get</em> als auch <em>Set</em> erstellt faktisch zwei separate Funktionen, die weder lokale oder statische Variablen noch verschachtelte Funktionen gemeinsam nutzen. Analog zu den Methoden hat jede Funktion einen versteckten Parameter namens <code>this</code>, und <em>Set</em> hat einen zweiten versteckten Parameter namens <code>value</code>. Explizit definierte Parameter erfolgen danach.</p>
<p>Während eine Eigenschaftsdefinition die <em>Get</em>- und <em>Set</em>-Akzessorfunktionen für eine Eigenschaft auf die gleiche Weise wie <a href="lib/Object.htm#DefineProp">DefineProp</a> definiert, definiert eine Methodendefinition die <em>Call</em>-Akzessorfunktion. Jede Klasse kann eine Eigenschaftsdefinition und eine Methodendefinition gleichen Namens enthalten. Wenn eine Eigenschaft ohne <em>Call</em>-Akzessorfunktion (eine Methode) aufgerufen wird, wird <em>Get</em> ohne Parameter indirekt aufgerufen und das Ergebnis anschließend als Methode aufgerufen.</p>

<h4 id="Custom_Classes_property_short">Fat-Arrow-Eigenschaften</h4>
<p>Mit der <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann ein <a href="#Custom_Classes_property">Eigenschaft</a>-Getter oder -Setter definiert werden, der ein Ausdruck zurückgibt:</p>
<pre>KurzeEigenschaft[<i>Parameter</i>]
{
    <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
    <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
}</pre>
<p>Wenn nur ein Getter definiert wird, können die geschweiften Klammern und <code>get</code> weggelassen werden:</p>
<pre>KürzereEigenschaft[<i>Parameter</i>] =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i></pre>
<p>In beiden Fällen müssen die eckigen Klammern weggelassen werden, es sei denn, Parameter sind definiert.</p>

<h3 id="__Enum">__Enum-Methode</h3>
<pre class="Syntax">__Enum(AnzahlVars)</pre>
<p>Die __Enum-Methode wird aufgerufen, wenn das Objekt an eine <a href="lib/For.htm">For-Schleife</a> übergeben wird. Diese Methode sollte einen <a href="lib/Enumerator.htm">Enumerator</a> zurückgeben, der Elemente im Objekt zurückgibt, wie z.B. Array-Elemente. Wenn es undefiniert bleibt, kann das Objekt nicht direkt an eine For-Schleife übergeben werden, es sei denn, es hat eine <a href="lib/Enumerator.htm#Call">Enumerator-kompatible Call-Methode</a>.</p>
<p><em>AnzahlVars</em> enthält die Anzahl der Variablen, die an die For-Schleife übergeben wurden. Wenn <em>AnzahlVars</em> 2 ist, wird erwartet, dass der Enumerator dem ersten Parameter den Schlüssel oder Index eines Elements und dem zweiten Parameter den Wert zuweist. Jeder Schlüssel oder Index sollte als Parameter der <a href="#__Item">__Item</a>-Eigenschaft akzeptiert werden. Dies befähigt <a href="AHKL_DBGPClients.htm">DBGp-basierte Debugger</a>, ein bestimmtes Element abzurufen oder zu setzen, nachdem sie durch indirekten Aufruf des Enumerators aufgelistet wurden.</p>

<h3 id="__Item">__Item-Eigenschaft</h3>
<p>Die __Item-Eigenschaft wird indirekt aufgerufen, wenn der Indexierungsoperator (Arraysyntax) in Verbindung mit dem Objekt verwendet wird. Im folgenden Beispiel wird die Eigenschaft als statisch deklariert, so dass der Indexierungsoperator auf die Env-Klasse selbst angewendet werden kann. Ein weiteres Beispiel finden Sie unter <a href="#Array2D">Array2D</a>.</p>
<pre>class Env {
    static __Item[name] {
        get =&gt; EnvGet(name)
        set =&gt; EnvSet(name, value)
    }
}

Env["PATH"] .= ";" A_ScriptDir  <em>; Betrifft nur dieses Skript und Unterprozesse.</em>
MsgBox Env["PATH"]</pre>
<p><code class="no-highlight">__Item</code> ist quasi ein Standardeigenschaftsname (falls eine solche Eigenschaft definiert wurde):</p>
<ul>
  <li><code><i>object</i>[<i>params</i>]</code> ist äquivalent zu <code><i>object</i>.__Item[<i>params</i>]</code>, wenn Parameter vorhanden sind.</li>
  <li><code><i>object</i>[]</code> ist äquivalent zu <code><i>object</i>.__Item</code>.</li>
</ul>
<p>Zum Beispiel:</p>
<pre>
obj := {}
obj[] := Map()     <em>; Äquivalent zu obj.__Item := Map()</em>
obj["base"] := 10
MsgBox obj.base = Object.prototype  <em>; True</em>
MsgBox obj["base"]                  <em>; 10</em>
</pre>
<p class="note"><strong>Hinweis:</strong> Wenn ein expliziter Eigenschaftsname mit leeren eckigen Klammern kombiniert wird, wie in <code>obj.prop[]</code>, wird dies als zwei separate Operationen behandelt: Zuerst <code>obj.prop</code> abrufen und dann die Standardeigenschaft des Ergebnisses indirekt aufrufen. Dies ist Teil der Sprachsyntax und somit objektunabhängig.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Jedes Mal, wenn ein Objekt mit der Standardimplementierung von <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erstellt wird, wird die __New-Methode des neuen Objekts aufgerufen, um eine benutzerdefinierte Initialisierung zu ermöglichen. Alle Parameter, die an <code><i>KlasseName</i>()</code> übergeben werden, werden an __New weitergeleitet, so dass sie den ursprünglichen Inhalt des Objekts oder die Art und Weise, wie es konstruiert wird, beeinflussen können. Bei Zerstörung des Objekts wird __Delete aufgerufen. Zum Beispiel:</p>
<pre>m1 := GMem(0, 10)
m2 := {base: GMem.Prototype}, m2.__New(0, 30)

<em>; Hinweis: Für allgemeine Speicherreservierungen stattdessen <a href="lib/Buffer.htm">Buffer</a>() verwenden.</em>
class GMem<span id="GMem"></span>
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aGröße, "Ptr")
        if !this.ptr
            throw MemoryError()
        MsgBox "Neues GMem von " aGröße " Bytes auf Adresse " this.ptr "."
    }

    __Delete()
    {
        MsgBox "GMem auf Adresse " this.ptr " löschen."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete wird nicht für Objekte aufgerufen, die eine Eigenschaft namens "__Class" haben. <a href="lib/Class.htm#Prototype">Prototypobjekte</a> haben diese Eigenschaft standardmäßig.</p>
<p>Wenn ein Ausnahme- oder Laufzeitfehler bei der Ausführung von __Delete ausgelöst und nicht innerhalb von __Delete behandelt wird, verhält es sich so, als wäre __Delete von einem neuen <a href="misc/Threads.htm">Thread</a> aufgerufen worden. Das heißt, dass ein Fehlerdialogfenster angezeigt wird und __Delete zurückkehrt, aber der Thread nicht beendet wird (es sei denn, er wurde bereits beendet).</p>
<p>Wenn das Skript auf irgendeine Weise direkt terminiert wird, z.B. über das Tray-Menü oder <a href="lib/ExitApp.htm">ExitApp</a>, bekommen alle Funktionen, die noch nicht zu ihrem Aufrufer zurückgekehrt sind, keine Chance, dies jemals zu tun. Daher werden alle Objekte, die von lokalen Variablen dieser Funktionen referenziert werden, nicht freigegeben, was dazu führt, dass __Delete nicht aufgerufen wird. Unter diesen Umständen werden auch temporäre Referenzen auf dem Stapel der Ausdrucksauswertung nicht freigegeben.</p>
<p>Bei Beendigung des Skripts werden Objekte, die in globalen und statischen Variablen enthalten sind, automatisch in einer willkürlichen, von der Implementierung festgelegten Reihenfolge freigegeben. Wenn __Delete während dieses Vorgangs aufgerufen wird, können einige globale oder statische Variablen bereits freigegeben worden sein, aber alle Referenzen, die das Objekt selbst enthält, sind noch gültig. Daher ist es am besten, wenn __Delete völlig eigenständig ist und nicht auf globale oder statische Variablen angewiesen ist.</p>

<h4 id="static__New">Klasseninitialisierung</h4>
<p>Jede Klasse wird automatisch initialisiert, wenn eine Referenz zur Klasse erstmals ausgewertet wird. Wenn z.B. <em>MeineKlasse</em> noch nicht initialisiert wurde, würde <code>MeineKlasse.MeineEigenschaft</code> bewirken, dass die Klasse initialisiert wird, bevor die Eigenschaft abgerufen wird. Die Initialisierung umfasst den Aufruf von zwei statischen Methoden: __Init und __New.</p>
<p><code>static __Init</code> wird automatisch für jede Klasse definiert und beginnt immer mit einer Referenz zur Basisklasse, falls angegeben, um sicherzustellen, dass sie initialisiert ist. <a href="#Custom_Classes_staticvar">Statische bzw. Klassenvariablen</a> und <a href="#Custom_Classes_class">verschachtelte Klassen</a> werden in der Reihenfolge initialisiert, in der sie definiert wurden, außer wenn eine verschachtelte Klasse während der Initialisierung einer vorherigen Variable oder Klasse referenziert wird.</p>
<p>Wenn die Klasse eine <code>static __New</code>-Methode definiert oder erbt, wird diese unmittelbar nach __Init aufgerufen. Es ist wichtig zu beachten, dass __New einmal für die Klasse, in der es definiert ist, <em>und</em> einmal für jede Unterklasse, die keine eigene definiert (oder die <code>super.__New()</code> aufruft), aufgerufen werden kann. Dies kann verwendet werden, um allgemeine Initialisierungsaufgaben für jede Unterklasse durchzuführen oder um Unterklassen vor ihrer Verwendung in irgendeiner Weise zu modifizieren.</p>
<p>Wenn <code>static __New</code> nicht mit abgeleiteten Klassen arbeiten soll, kann dies durch die Überprüfung des Wertes von <code>this</code> vermieden werden. In einigen Fällen kann es ausreichend sein, dass die Methode sich selbst löscht, wie z.B. bei <code>this.DeleteProp('__New')</code>; allerdings könnte die erste Ausführung von __New für eine Unterklasse sein, wenn diese in der Basisklasse verschachtelt ist oder bei der Initialisierung einer statischen bzw. Klassenvariable referenziert wird.</p>
<p>Eine Klassendefinition bewirkt auch, dass die Klasse referenziert wird. Mit anderen Worten, wenn die Ausführung während der <a href="Scripts.htm#auto">Startphase des Skripts</a> eine Klassendefinition erreicht, werden __Init und __New automatisch aufgerufen, es sei denn, die Klasse wurde bereits vom Skript referenziert. Wenn die Ausführung jedoch daran gehindert wird, die Klassendefinition zu erreichen, z.B. durch <code>return</code> oder eine Endlosschleife, wird die Klasse erst initialisiert, wenn sie referenziert wird.</p>
<p>Wenn die automatische Initialisierung einmal begonnen hat, wird sie für dieselbe Klasse nicht erneut durchgeführt. Dies ist grundsätzlich kein Problem, es sei denn, mehrere Klassen referenzieren sich gegenseitig. Nehmen wir zum Beispiel die folgenden zwei Klassen. Wenn <code>A</code> zuerst initialisiert wird, bewirkt die Auswertung von <code>B.SharedArray</code> (A1), dass <code>B</code> initialisiert wird, bevor der Wert abgerufen und zurückgegeben wird, aber <code>A.SharedValue</code> (A3) ist undefiniert und bewirkt keine Initialisierung von <code>A</code>, da diese bereits im Gange ist. Mit anderen Worten, wenn <code>A</code> erstmals verwendet oder initialisiert wird, ist die Reihenfolge A1 bis A3, sonst B1 bis B4:</p>
<pre>MsgBox A.SharedArray.Length
MsgBox B.SharedValue

class A {
    static SharedArray := B.SharedArray   <em>; A1          ; B3</em>
    static SharedValue := 42                            <em>; B4</em>
}

class B {
    static SharedArray := StrSplit("XYZ") <em>; A2          ; B1</em>
    static SharedValue := A.SharedValue   <em>; A3 (Error)  ; B2</em>
}</pre>

<h3 id="Meta_Functions">Metafunktionen</h3>
<pre class="Syntax">
class <i>KlasseName</i> {
    __Get(Name, Params)
    __Set(Name, Params, Wert)
    __Call(Name, Params)
}
</pre>
<dl>
  <dt>Name</dt>
  <dd><p>Der Name der Eigenschaft oder Methode.</p></dd>
  <dt>Params</dt>
  <dd><p>Ein <a href="lib/Array.htm">Array</a> von Parametern. Dies umfasst nur die Parameter zwischen <code>()</code> oder <code>[]</code>, kann also leer sein. Die Metafunktion soll Fälle wie <code>x.y[z]</code> behandeln, in denen <code>x.y</code> undefiniert ist.</p></dd>
  <dt>Wert</dt>
  <dd><p>Der Wert, der zugewiesen wird.</p></dd>
</dl>
<p>Metafunktionen definieren, was passieren soll, wenn eine undefinierte Eigenschaft oder Methode indirekt aufgerufen wird. Wenn z.B. <code>obj.unk</code> keinen Wert zugewiesen bekommen hat, ruft es indirekt die <i>__Get</i>-Metafunktion auf. <code>obj.unk := Wert</code> bewirkt dagegen den indirekten Aufruf von <i>__Set</i> und <code>obj.unk()</code> den indirekten Aufruf von <i>__Call</i>.</p>
<p>Eigenschaften und Methoden können im Objekt selbst oder in einem seiner <a href="#delegation">Basisobjekte</a> definiert werden. Damit für jede Eigenschaft eine Metafunktion aufgerufen wird, sollte die Definition von Eigenschaften grundsätzlich vermieden werden. Interne Eigenschaften wie <a href="lib/Object.htm#Base">Base</a> können mit einer <a href="#Custom_Classes_property">Eigenschaftsdefinition</a> oder <a href="lib/Object.htm#DefineProp">DefineProp</a> überschrieben werden.</p>
<p>Wenn eine Metafunktion definiert ist, muss sie die gewünschte Standardaktion ausführen. Zum Beispiel kann Folgendes erwartet werden:</p>
<ul>
  <li><i>Call</i>: Einen <a href="lib/Error.htm#MethodError">MethodError</a> auslösen.</li>
  <li>Wenn Parameter übergeben wurden, eine Ausnahme auslösen (es gibt kein Objekt, an das die Parameter weitergeleitet werden können).</li>
  <li><i>Get</i>: Einen <a href="lib/Error.htm#PropertyError">PropertyError</a> auslösen.</li>
  <li><i>Set</i>: Eine neue Eigenschaft mit dem angegebenen Wert definieren, z.B. durch Aufruf von <a href="lib/Object.htm#DefineProp">DefineProp</a>. </li>
</ul>
<p>Jedes <a href="misc/Functor.htm">aufrufbare Objekt</a> kann als Metafunktion verwendet werden, wenn es der entsprechenden Eigenschaft zugewiesen wird.</p>
<p>Metafunktionen werden in den folgenden Fällen nicht aufgerufen:</p>
<ul>
  <li><code>x[y]</code>: Die Verwendung von eckigen Klammern ohne Eigenschaftsnamen ruft indirekt nur die <a href="#__Item">__Item</a>-Eigenschaft auf.</li>
  <li><code>x()</code>: Der Aufruf des Objekts selbst ruft indirekt nur die Call-Methode auf. Dies umfasst interne Aufrufe durch interne Funktionen wie <a href="lib/SetTimer.htm">SetTimer</a> und <a href="lib/Hotkey.htm">Hotkey</a>.</li>
  <li>Interne Aufrufe von anderen Metafunktionen oder Doppel-Unterstrich-Methoden lösen <code class="no-highlight">__Call</code> nicht aus.</li>
</ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> und <a href="lib/Object.htm#DefineProp">DefineProp</a> ermöglichen die Definition von Eigenschaften, die bei jeder Auswertung einen Wert ermitteln, allerdings muss jede Eigenschaft im Voraus definiert sein. Mit <em>__Get</em> und <em>__Set</em> können hingegen Eigenschaften implementiert werden, die erst zum Zeitpunkt ihres indirekten Aufrufs bekannt sind.</p>
<p>Zum Beispiel kann ein "Proxy-Objekt" mit Eigenschaften erstellt werden, die den aktuellen Wert über das Netzwerk (oder über einen anderen Kanal) abfragen. Ein Remote-Server sendet eine Antwort zurück, die den Wert der Eigenschaft enthält, und das Proxy-Objekt übergibt den Wert an seinen Aufrufer. Selbst wenn der Name jeder Eigenschaft im Voraus bekannt wäre, würde es keinen Sinn machen, jede Eigenschaft einzeln in der Proxy-Klasse zu definieren, da jede Eigenschaft dasselbe bewirkt (eine Netzwerkanfrage senden). Metafunktionen empfangen den Namen der Eigenschaft als Parameter und sind daher eine gute Lösung für dieses Problem.</p>

<h2 id="primitive">Primitive Werte</h2>
<p>Primitive Werte wie Zeichenketten und Zahlen können keine eigenen Eigenschaften und Methoden haben. Allerdings unterstützen primitive Werte die gleiche Art der <a href="#delegation">Delegation</a> wie Objekte. Das heißt, dass jeder Eigenschafts- oder Methodenaufruf bei einem primitiven Wert an ein vordefiniertes Prototypobjekt delegiert wird, auf das auch über die <a href="lib/Class.htm#Prototype">Prototype</a>-Eigenschaft der entsprechenden Klasse zugegriffen werden kann. Die folgenden Klassen beziehen sich auf primitive Werte:</p>
<ul style="line-height: 1.5">
  <li>Primitive (extends <a href="lib/Any.htm">Any</a>) <ul style="padding-left: 1.7em">
    <li>Number <ul style="padding-left: 1.7em">
      <li>Float</li>
      <li>Integer</li>
    </ul></li>
    <li>String</li>
  </ul></li>
</ul>
<p>Obwohl die Überprüfung der <a href="lib/Type.htm">Type</a>-Zeichenkette in der Regel schneller ist, kann der Typ eines Wertes auch getestet werden, indem geprüft wird, ob der Wert eine Basis hat. Zum Beispiel ist <code>n.HasBase(Number.Prototype)</code> oder <code>n is Number</code> True, wenn <em>n</em> ein reiner Integer oder eine reine Floating-Point-Zahl ist, aber False, wenn <em>n</em> eine numerische Zeichenkette ist, da String nicht von Number ableitet. <code>IsNumber(n)</code> hingegen ist True, wenn <em>n</em> eine Zahl oder numerische Zeichenkette ist.</p>
<p><a href="lib/Any.htm#GetBase">ObjGetBase</a> und die <a href="lib/Any.htm#Base">Base</a>-Eigenschaft geben ggf. eines der vordefinierten Prototypobjekte zurück.</p>
<p>Beachten Sie, dass <code>x is Any</code> normalerweise True für jeden Wert innerhalb der Typenhierarchie von AutoHotkey ist, aber False für COM-Objekte ist.</p>

<h3 id="primitive-extension">Eigenschaften und Methoden hinzufügen</h3>
<p>Eigenschaften und Methoden können für alle Werte eines bestimmten Typs hinzugefügt werden, indem das Prototypobjekt dieses Typs geändert wird. Da jedoch ein primitiver Wert kein Object ist und keine eigenen Eigenschaften oder Methoden haben kann, werden die primitiven Prototypobjekte nicht von <code>Object.Prototype</code> ableiten. Mit anderen Worten, es ist standardmäßig nicht möglich, auf Methoden wie <a href="lib/Object.htm#DefineProp">DefineProp</a> und <a href="lib/Object.htm#HasOwnProp">HasOwnProp</a> zuzugreifen. Diese können indirekt aufgerufen werden. Zum Beispiel:</p>
<pre>
DefProp := {}.DefineProp
DefProp( "".base, "Length", { get: StrLen } )
MsgBox A_AhkPath.length " == " StrLen(A_AhkPath)
</pre>
<p>Obwohl primitive Werte Werteigenschaften von ihrem Prototyp erben können, wird eine Ausnahme ausgelöst, wenn das Skript versucht, eine Werteigenschaft bei einem primitiven Wert zu setzen. Zum Beispiel:</p>
<pre>"".base.test := 1  <em>; Bitte nicht nachmachen.</em>
MsgBox "".test  <em>; 1</em>
"".test := 2  <em>; Fehler: Eigenschaft ist schreibgeschützt.</em></pre>
<p>Obwohl __Set und Eigenschafts-Setter verwendet werden können, sind sie nicht nützlich, da primitive Werte als unveränderlich zu betrachten sind.</p>

<h2 id="Implementation">Implementierung</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet einen einfachen Referenzzählmechanismus, um belegte Ressourcen eines Objekts automatisch freizugeben, wenn es nicht länger im Skript referenziert wird. Es ist wichtig, diesen Mechanismus zu verstehen, um die Lebensdauer eines Objekts richtig zu verwalten, was die Löschung des Objekts ermöglicht, wenn es nicht mehr benötigt wird, und nicht vorher.</p>
<p>Die Referenzanzahl eines Objekts wird jedes Mal erhöht, wenn eine Referenz gespeichert wird. Bei der Freigabe einer Referenz wird die Anzahl verwendet, um festzustellen, ob diese Referenz die letzte ist. Ist dies der Fall, wird das Objekt gelöscht, andernfalls wird die Anzahl dekrementiert. Die folgenden einfachen Beispiele zeigen, wie Referenzen gezählt werden:</p>
<pre>
a := {Name: "Bob"}  <em>; Bobs Referenzanzahl ist anfangs 1</em>
b := [a]            <em>; Bobs Referenzanzahl erhöht sich auf 2</em>
a := ""             <em>; Bobs Referenzanzahl verringert sich auf 1</em>
c := b.Pop()        <em>; Bob transferiert, Referenzanzahl ist immer noch 1</em>
c := ""             <em>; Bob wurde gelöscht...</em>
</pre>
<p>Temporäre Referenzen, die von Funktionen, Methoden oder Operatoren innerhalb eines Ausdrucks zurückgegeben werden, werden erst freigegeben, wenn die Auswertung dieses Ausdrucks abgeschlossen oder abgebrochen wurde. Im folgenden Beispiel wird das neue <a href="#GMem">GMem</a>-Objekt erst nach Abschluss von MsgBox freigegeben:</p>
<pre>MsgBox <a href="lib/DllCall.htm">DllCall</a>("GlobalSize", "ptr", GMem(0, 20).ptr, "ptr")  <em>; 20</em></pre>
<p class="note"><strong>Hinweis:</strong> In diesem Beispiel kann <code>.ptr</code> weggelassen werden, da der <a href="lib/DllCall.htm#ptr">Ptr</a>-Argumenttyp Objekte mit einer Ptr-Eigenschaft zulässt. Allerdings funktioniert das oben gezeigte Muster auch mit anderen Eigenschaftsnamen.</p>
<p>Um Code beim Freigeben der letzten Referenz zu einem Objekt auszuführen, implementieren Sie die <a href="#Custom_NewDelete">__Delete</a>-Metafunktion.</p>
<h4 id="refs-problems">Probleme mit der Referenzzählung</h4>
<p>Wenn man sich ausschließlich auf die Referenzzählung verlässt, gerät man manchmal in eine Zwickmühle: Ein Objekt ist so konzipiert, dass es seine Ressourcen bei seiner Löschung freigibt, aber es wird erst gelöscht, wenn seine Ressourcen zuvor freigegeben wurden. Dies ist insbesondere dann der Fall, wenn es sich bei diesen Ressourcen um andere Objekte oder Funktionen handelt, die – oft indirekt – eine Referenz auf das Objekt aufrechterhalten.</p>
<p>Ein <em>Zirkelbezug</em> oder <em>Referenzzyklus</em> liegt vor, wenn ein Objekt direkt oder indirekt auf sich selbst verweist. Wenn jede Referenz, die Teil des Zyklus ist, in der Zählung enthalten ist, kann das Objekt erst gelöscht werden, wenn der Zyklus manuell unterbrochen wird. Zum Beispiel erzeugt Folgendes einen Referenzzyklus:</p>
<pre>parent := {}  <em>; parent: 1 (Referenzanzahl)</em>
child := {parent: parent}  <em>; parent: 2, child: 1</em>
parent.child := child  <em>; parent: 2, child: 2</em></pre>
<p>Wenn die Variablen <code>parent</code> und <code>child</code> neu zugewiesen werden, wird die Referenzanzahl für jedes Objekt auf 1 verringert. Beide Objekte wären für das Skript unzugänglich, würden aber nicht gelöscht werden, da die letzten Referenzen nicht freigegeben sind.</p>
<p>Ein Zyklus ist häufig weniger offensichtlich und kann mehrere Objekte umfassen. <a href="lib/Gui.htm#ExRefCycle">RefZyklusGuiZeigen</a> zeigt zum Beispiel einen Zyklus, der Gui, MenuBar, Menu und Closures beinhaltet. Die Verwendung eines separaten Objekts zur Behandlung von GUI-Ereignissen ist ebenfalls anfällig für Zyklen, wenn das Handler-Objekt eine Referenz auf die GUI hat.</p>
<p>Nichtzyklische Referenzen auf ein Objekt können ebenfalls Probleme verursachen. Zum Beispiel bewirken Objekte, die von internen Funktionen wie SetTimer oder OnMessage abhängig sind, in der Regel, dass das Programm eine indirekte Referenz auf das Objekt hält. Dies würde verhindern, dass das Objekt gelöscht wird, was bedeutet, dass es __New und __Delete nicht verwenden kann, um den Timer oder die Meldungsüberwachung zu verwalten.</p>
<p>Im Folgenden werden einige Strategien vorgestellt, die zur Lösung der oben beschriebenen Probleme beitragen können.</p>
<p id="ref-avoid-cycles"><strong>Zyklen vermeiden:</strong> Wenn Referenzzyklen ein Problem darstellen, sollten sie nicht erstellt werden. Zum Beispiel würde entweder <code>parent.child</code> oder <code>child.parent</code> nicht gesetzt werden. Dies ist oft nicht praktikabel, da verwandte Objekte in irgendeiner Weise aufeinander verweisen müssen.</p>
<p>Vermeiden Sie bei der Definition von Ereignishandlern für <a href="lib/GuiOnEvent.htm">OnEvent (Gui)</a>, die Quell-Gui in einer Closure- oder Bound-Funktion zu erfassen, und verwenden Sie stattdessen den Gui- oder Gui.Control-Parameter. Dasselbe gilt für <a href="lib/Menu.htm#Add">Add (Menu)</a> und den Menü-Parameter des Callbacks, aber natürlich kann ein Menüpunkt, der auf eine Gui verweisen muss, diesen Ansatz nicht verwenden.</p>
<p>In einigen Fällen kann das andere Objekt durch eine indirekte Methode abgerufen werden, die nicht auf einer gezählten Referenz beruht. Zum Beispiel können Sie eine HWND-Nummer speichern und <code>GuiFromHwnd(hwnd)</code> verwenden, um ein <a href="lib/Gui.htm">Gui</a>-Objekt abzurufen. Es ist nicht notwendig, eine Referenz aufrechtzuerhalten, um das Löschen zu verhindern, während das Fenster sichtbar ist, da die Gui dies selbst regelt.</p>
<p id="ref-break-cycles"><strong>Zyklen unterbrechen:</strong> Wenn das Skript die Referenzzählung vermeiden kann und stattdessen die Lebensdauer des Objekts direkt verwaltet, muss es den Zyklus nur unterbrechen, wenn die Objekte gelöscht werden sollen:</p>
<pre>child.parent := unset  <em>; parent: 1, child: 2</em>
child := unset  <em>; parent: 1, child: 1</em>
parent := unset  <em>; beide gelöscht</em></pre>
<p id="ref-dispose"><strong>Dispose</strong> (Entsorgen): __Delete wird genau dann aufgerufen, wenn die letzte Referenz freigegeben wird, so dass man sich eine einfache Zuweisung wie <code>meineGui := ""</code> als einen Bereinigungsschritt vorstellen kann, der das Löschen des Objekts auslöst. Manchmal wird dies explizit gemacht, wenn das Objekt nicht mehr benötigt wird, aber dies ist weder zuverlässig noch zeigt es wirklich die Absicht des Codes. Ein alternatives Muster besteht darin, eine Dispose- oder Destroy-Methode zu definieren, die die Ressourcen des Objekts freigibt, und sie so zu konzipieren, dass sie nichts tut, wenn sie ein zweites Mal aufgerufen wird. Sie kann dann zur Sicherheit auch von __Delete aus aufgerufen werden.</p>
<p>Ein Objekt, das diesem Muster folgt, muss dennoch alle Referenzzyklen unterbrechen, wenn es <em>entsorgt</em> wird, da sonst ein Teil des Speichers nicht freigegeben würde und __Delete für andere Objekte, die vom Objekt referenziert werden, nicht aufgerufen würde.</p>
<p>Zyklen, die durch die Ereignishandler eines Gui-Objekts, durch MenuBar oder durch ein Event-Sink-Objekt verursacht werden, werden automatisch "unterbrochen", wenn <a href="lib/Gui.htm#Destroy">Destroy</a> aufgerufen wird, da es diese Objekte freigibt. (Dies wird im <a href="lib/Gui.htm#ExRefCycle">RefZyklusGuiZeigen-Beispiel</a> gezeigt.) Allerdings würde dies keine Zyklen unterbrechen, die durch neu hinzugefügte Eigenschaften verursacht werden, da Destroy diese nicht löscht.</p>
<p>Ähnlich wie das Dispose-Muster hat <a href="lib/InputHook.htm">InputHook</a> eine Stop-Methode, die explizit aufgerufen werden muss und deshalb nicht auf __Delete angewiesen ist, um zu signalisieren, wann die Operation beendet werden soll. Während der Operation hält das Programm effektiv eine Referenz auf das Objekt, wodurch dessen Löschung verhindert wird, aber dies ist eher eine Stärke als eine Schwäche: Ereignisrückrufe können weiterhin aufgerufen werden und erhalten den InputHook als Parameter. Wenn die Operation beendet ist, wird die interne Referenz freigegeben und der InputHook gelöscht, wenn das Skript keine Referenz darauf hat.</p>
<p id="ref-ptr"><strong>Pointer:</strong> Das Speichern von beliebig vielen Pointerwerten hat keinen Einfluss auf die Referenzanzahl des Objekts, da ein Pointer nur ein Integer ist. Ein mit <a href="#ObjPtr">ObjPtr</a> abgerufener Pointer kann verwendet werden, um eine Referenz zu erzeugen, indem er an <a href="#ObjFromPtr">ObjFromPtrAddRef</a> übergeben wird. Die AddRef-Version der Funktion muss verwendet werden, da die Referenzanzahl dekrementiert wird, wenn die temporäre Referenz automatisch freigegeben wird.</p>
<p>Nehmen wir zum Beispiel an, dass ein Objekt einige Eigenschaften jede Sekunde aktualisieren muss. Ein Timer hält eine Referenz auf die Rückruffunktion, die das Objekt als gebundenen Parameter hat. Normalerweise würde dies verhindern, dass das Objekt gelöscht wird, bevor der Timer gelöscht wird. Das Speichern eines Pointers anstelle einer Referenz ermöglicht das Löschen des Objekts unabhängig vom Timer, so dass es automatisch von __New und __Delete verwaltet werden kann.</p>
<pre>a := EineKlasse()
Sleep 5500  <em>; Den Timer 5 Mal laufen lassen.</em>
a := ""
Sleep 3500  <em>; Exit temporär verhindern, um den Stop des Timers zu zeigen.</em>

class EineKlasse {
    __New() {
        <em>; Das Closure muss gespeichert werden, damit der Timer später
        ; gelöscht werden kann. Jedes Mal, wenn die Methode aufgerufen
        ; werden muss, wird eine gezählte Referenz synthetisiert.</em>
        this.Timer := (p =&gt; ObjFromPtrAddRef(p).Update()).Bind(ObjPtr(this))
        SetTimer this.Timer, 1000
    }
    __Delete() {
        SetTimer this.Timer, 0
        <em>; Wenn dieses Objekt wirklich gelöscht wird, werden alle Eigen-
        ; schaften gelöscht und die folgende __Delete-Methode aufgerufen.
        ; Dient nur zur Bestätigung und wird normalerweise nicht verwendet.</em>
        this.Test := {__Delete: test =&gt; ToolTip("Objekt gelöscht")}
    }
    <em>; Dies soll nur zeigen, dass der Timer läuft.
    ; Theoretisch könnte diese Klasse auch einen anderen Zweck haben.</em>
    count := 0
    Update() =&gt; ToolTip(++this.count)
}</pre>
<p>Ein Nachteil dieses Ansatzes ist, dass der Pointer nicht direkt als Objekt verwendbar ist und weder von <a href="lib/Type.htm">Type</a> noch vom <a href="AHKL_DBGPClients.htm">Debugger</a> als solches erkannt wird. Das Skript muss absolut sicher sein, dass der Pointer nach dem Löschen des Objekts nicht mehr verwendet wird, da dies ungültig ist und das Ergebnis undefiniert wäre.</p>
<p>Wenn die Pointerreferenz an mehreren Stellen benötigt wird, kann es sinnvoll sein, sie zu kapseln. Zum Beispiel würde <code>b := ObjFromPtrAddRef.Bind(ObjPtr(this))</code> eine <a href="misc/Functor.htm#BoundFunc">BoundFunc</a> erzeugen, die aufgerufen werden kann (<code>b()</code>), um die Referenz abzurufen, während <code>((this, p) =&gt; ObjFromPtrAddRef(p)).Bind(ObjPtr(this))</code> als Eigenschafts-Getter verwendet werden kann (die Eigenschaft würde eine Referenz zurückgeben).</p>
<p id="ref-uncounted"><strong>Ungezählte Referenzen:</strong> Wenn sich die Referenzanzahl des Objekts auf eine Referenz bezieht, sprechen wir von einer <em>gezählten Referenz</em>, andernfalls von einer <em>ungezählten Referenz</em>. Letzteres soll es dem Skript ermöglichen, eine Referenz zu speichern, die das Löschen des Objekts nicht verhindert.</p>
<p class="note"><strong>Hinweis:</strong> Hier geht es darum, wie sich die Referenzanzahl des Objekts gemäß Skriptlogik zu einer bestimmten Referenz verhält, nicht um die Art der Referenz selbst. Das Programm wird weiterhin versuchen, die Referenz automatisch zu einem bestimmten Zeitpunkt freizugeben, daher sind die Begriffe <em>schwache Referenz</em> und <em>starke Referenz</em> unpassend.</p>
<p>Eine gezählte Referenz kann in eine ungezählte Referenz umgewandelt werden, indem die Referenzanzahl des Objekts einfach dekrementiert wird. Dies <u>muss</u> rückgängig gemacht werden, bevor die Referenz freigegeben wird, was wiederum geschehen <u>muss</u>, bevor das Objekt gelöscht wird. Da der Zweck einer ungezählten Referenz darin besteht, die Löschung des Objekts zu ermöglichen, ohne zuerst die Referenz manuell ungesetzt zu machen, muss die Anzahl in der Regel innerhalb der eigenen <a href="#Custom_NewDelete">__Delete</a>-Methode des Objekts korrigiert werden.</p>
<p>Zum Beispiel können __New und __Delete aus dem vorherigen Beispiel durch die folgenden ersetzt werden.</p>
<pre>    __New() {
        <em>; Die BoundFunc muss gespeichert werden, damit der Timer später
        ; gelöscht werden kann.</em>
        SetTimer this.Timer := this.Update.Bind(this), 1000
        <em>; Referenzanzahl dekrementieren, um das von Bind erfolgte AddRef
        ; zu kompensieren.</em>
        ObjRelease(ObjPtr(this))
    }
    __Delete() {
        <em>; Referenzanzahl inkrementieren, damit die Referenz innerhalb der
        ; BoundFunc sicher freigegeben werden kann.</em>
        ObjPtrAddRef(this)
        <em>; Timer löschen, um die Referenz auf die BoundFunc freizugeben.</em>
        SetTimer this.Timer, 0
        <em>; BoundFunc freigeben. Dies geschieht evtl. nicht automatisch
        ; aufgrund des Referenzzyklus, der jetzt besteht,
        ; da die Referenz in der BoundFunc erneut gezählt wurde.</em>
        this.Timer := unset
        <em>; Wenn dieses Objekt wirklich gelöscht wird, werden alle Eigen-
        ; schaften gelöscht und die folgende __Delete-Methode aufgerufen.
        ; Dient nur zur Bestätigung und wird normalerweise nicht verwendet.</em>
        this.Test := {__Delete: test =&gt; ToolTip("Objekt gelöscht")}
    }</pre>
<p>Dies kann generell angewendet werden, unabhängig davon, wo die ungezählte Referenz gespeichert ist und wofür sie verwendet wird. Die wichtigsten Punkte sind:</p>
<ul>
  <li>Die Referenzanzahl dekrementieren (Release), <em>nachdem</em> die Referenz gespeichert wird.</li>
  <li>Die Referenzanzahl inkrementieren (AddRef), <em>bevor</em> die Referenz ungesetzt gemacht wird.</li>
  <li>Die Referenz explizit ungesetzt machen, bevor __Delete zurückkehrt (es reicht, wenn dies vor dem Aufruf geschieht).</li>
</ul>
<p>Die Referenzanzahl muss so oft inkrementiert und dekrementiert werden, wie es Referenzen gibt, die als ungezählt gelten sollen. Dies kann unpraktisch sein, wenn das Skript nicht genau vorhersagen kann, wie viele Referenzen von einer Funktion gespeichert werden.</p>

<h3 id="ObjPtr">Objektpointer</h3>
<p>Bei der Erstellung eines Objekts wird ein Teil des Speichers reserviert, um die Grundstruktur des Objekts zu speichern. Diese Struktur ist im Wesentlichen das Objekt selbst, weshalb wir ihre Adresse als <em>Objektpointer</em> bezeichnen. Eine Adresse ist ein Integerwert, der einer Stelle im virtuellen Speicher des aktuellen Prozesses entspricht und nur solange gültig ist, bis das Objekt gelöscht wird.</p>
<p>In seltenen Fällen kann es erforderlich sein, dass ein Objekt via DllCall an einen externen Code übergeben werden muss oder dass ein Objekt in eine binäre Datenstruktur für späteren Gebrauch gespeichert werden muss. Die Adresse eines Objekts kann via <code>Adresse := ObjPtr(meinObjekt)</code> abgerufen werden, allerdings werden dadurch effektiv zwei Referenzen zum Objekt erzeugt, während das Programm selbst nur die eine Referenz in <em>meinObjekt</em> kennt. Das Objekt wird gelöscht, sobald die letzte <em>bekannte</em> Referenz zum Objekt freigegeben wird. Folglich muss das Skript dem Objekt mitteilen, dass es eine Referenz erhalten hat. Dies kann wie folgt erreicht werden (die folgenden zwei Zeilen sind äquivalent):</p>
<pre>
ObjAddRef(Adresse := ObjPtr(meinObjekt))
Adresse := ObjPtrAddRef(meinObjekt)
</pre>
<p>Außerdem muss das Objekt informiert werden, wenn das Skript mit dieser Referenz fertig ist:</p>
<pre>ObjRelease(Adresse)</pre>
<p>Generell sollte jede neue Kopie einer Objektadresse als separate Referenz zum Objekt behandelt werden, d.h. das Skript sollte <a href="lib/ObjAddRef.htm">ObjAddRef</a> aufrufen, wenn es eine Kopie erhält, und sofort <a href="lib/ObjAddRef.htm">ObjRelease</a> aufrufen, bevor es eine Kopie verliert. Zum Beispiel sollte immer <a href="lib/ObjAddRef.htm">ObjAddRef</a> aufgerufen werden, wenn eine Adresse mit so etwas wie <code>x := Adresse</code> kopiert wird. Ebenso sollte das Skript <a href="lib/ObjAddRef.htm">ObjRelease</a> aufrufen, wenn es mit <em>x</em> fertig ist (oder dabei ist, den Wert von <em>x</em> zu überschreiben).</p>
<p id="ObjFromPtr">Mit der ObjFromPtr-Funktion kann eine Adresse in eine geeignete Referenz umgewandelt werden:</p>
<pre>meinObjekt := ObjFromPtr(Adresse)</pre>
<p>ObjFromPtr vermutet, dass <em>Adresse</em> eine gezählte Referenz ist, und nimmt sie in Besitz. Mit anderen Worten, <code>meinObjekt := ""</code> bewirkt, dass die Referenz, ursprünglich durch <em>Adresse</em> repräsentiert, freigegeben wird. Danach muss <em>Adresse</em> als ungültig betrachtet werden. Um stattdessen eine neue Referenz zu erstellen, verwenden Sie eine der folgenden Möglichkeiten:</p>
<pre>
ObjAddRef(Adresse), meinObjekt := ObjFromPtr(Adresse)
meinObjekt := ObjFromPtrAddRef(Adresse)
</pre>

</body>
</html>
