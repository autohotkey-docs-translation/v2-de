<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Objekte - Definition &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Wie man Objekte verwendet, neue Objekttypen definiert und weitere Details zur Funktionsweise von Objekten in AutoHotkey." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p>Ein <i>Objekt</i> ist eine Kombination aus <em>Eigenschaften</em> und <a href="Concepts.htm#methods"><em>Methoden</em></a>.</p>
<p>Verwandte Themen:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objekte</a>: Allgemeine Erklärung von Objekten.</li>
  <li><a href="Concepts.htm#object-protocol">Objektorientierte Schnittstelle</a>: Einzelheiten darüber, wie ein Skript mit einem Objekt interagiert.</li>
  <li><a href="misc/Functor.htm">Funktionsobjekte</a>: Objekte, die <em>aufgerufen</em> werden können.</li>
</ul>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Eine Liste von Standardobjekttypen finden Sie unter <a href="ObjList.htm">Interne Klassen</a>. Es gibt zwei Grundtypen:</p>
<ul>
  <li><strong>AutoHotkey-Objekte</strong> sind Instanzen der <a href="lib/Object.htm">Object</a>-Klasse. Solche Objekte unterstützen Ad-hoc-Eigenschaften, und haben Methoden, um herauszufinden, welche Eigenschaften existieren. <a href="lib/Array.htm">Array</a>, <a href="lib/Map.htm">Map</a> und alle benutzerdefinierten und internen Klassen sind von der Object-Klasse abgeleitet.</li>
  <li><strong>COM-Objekte</strong>, wie solche, die via <a href="lib/ComObject.htm">ComObject</a> erstellt werden. Solche Objekte sind von externen Bibliotheken implementiert und haben daher oft ein anderes Verhalten als AutoHotkey-Objekte. ComObject repräsentiert typischerweise ein COM- oder "Automation"-Objekt, das die <a href="https://learn.microsoft.com/windows/win32/api/oaidl/nn-oaidl-idispatch">IDispatch-Schnittstelle</a> implementiert, wird aber auch verwendet, um <a href="lib/ComValue.htm">Werte bestimmter Typen zu wrappen</a>, die an COM-Objekte und -Funktionen übergeben werden sollen.</li>
</ul>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlegende Verwendung</a> - <a href="#Usage_Simple_Arrays">Arrays</a>, <a href="#Usage_Associative_Arrays">Maps (assoziative Arrays)</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Objekte freigeben</a></li>
  <li><a href="#Extended_Usage">Erweiterte Verwendung</a> - <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#creating-a-base-object">Basisobjekt erstellen</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Metafunktionen</a></li>
  <li><a href="#primitive">Primitive Werte</a></li>
  <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzzählung</a>, <a href="#ObjPtr">Objektpointer</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Grundlegende Verwendung</h2>

<h3 id="Usage_Simple_Arrays">Arrays</h3>
<p>Erstellen eines <a href="lib/Array.htm">Arrays</a>:</p>
<pre>MeinArray := [Element1, Element2, ..., ElementN]
MeinArray := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements:<em></em></p>
<pre>Wert := MeinArray[Index]</pre>
<p>Ändern eines Elementwertes (<code>Index</code> muss zwischen 1 und Länge liegen oder ein äquivalenter umgekehrter Index sein):</p>
<pre>MeinArray[Index] := Wert</pre>
<p>Einfügen eines oder mehrerer Elemente ab einem bestimmten Index via <a href="lib/Array.htm#InsertAt">InsertAt</a>-Methode:</p>
<pre>MeinArray.InsertAt(Index, Wert, Wert2, ...)</pre>
<p>Anfügen eines oder mehrerer Elemente via <a href="lib/Array.htm#Push">Push</a>-Methode:</p>
<pre>MeinArray.Push(Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements via <a href="lib/Array.htm#RemoveAt">RemoveAt</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.RemoveAt(Index)</pre>
<p>Entfernen eines Elements via <a href="lib/Array.htm#Pop">Pop</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.Pop()</pre>
<p><a href="lib/Array.htm#Length">Length</a> gibt die Anzahl der Elemente im Array zurück. Um die Elemente eines Arrays einzeln durchzugehen, verwenden Sie entweder A_Index oder eine For-Schleife. Zum Beispiel:</p>
<pre>MeinArray := ["eins", "zwei", "drei"]

<em>; Von 1 bis zum Ende des Arrays iterieren:</em>
Loop MeinArray.Length
    MsgBox MeinArray[A_Index]

<em>; Den Inhalt des Arrays enumerieren:</em>
For Index, Wert in MeinArray
    MsgBox "Element " Index " ist '" Wert "'"
    
<em>; Dasselbe noch einmal:</em>
For Wert in MeinArray
    MsgBox "Element " A_Index " ist '" Wert "'"
</pre>

<h3 id="Usage_Associative_Arrays">Maps (assoziative Arrays)</h3>
<p>Ein <a href="lib/Map.htm">Map</a> oder assoziatives Array ist ein Objekt, das eine Sammlung von eindeutigen Schlüsseln und eine Sammlung von Werten enthält, wobei jeder Schlüssel mit einem Wert verbunden ist. Schlüssel können Zeichenketten, Integer oder Objekte sein, während Werte von beliebigem Typ sein können. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>MeinMap := Map("SchlüsselA", WertA, "SchlüsselB", WertB, ..., "SchlüsselZ", WertZ)</pre>
<p>Abrufen eines Elements, wobei <code>Schlüssel</code> eine <a href="Concepts.htm#variables">Variable</a> oder ein <a href="Language.htm#expressions">Ausdruck</a> ist:</p>
<pre>Wert := MeinMap[Schlüssel]</pre>
<p>Zuweisen eines Elements:</p>
<pre>MeinMap[Schlüssel] := Wert</pre>
<p>Entfernen eines Elements via <a href="lib/Array.htm#Delete">Delete</a>-Methode:</p>
<pre>EntfernterWert := MeinMap.Delete(Schlüssel)</pre>
<p>Enumerieren von Elementen:</p>
<pre>MeinMap := Map("zehn", 10, "zwanzig", 20, "dreißig", 30)
<a href="lib/For.htm">For</a> Schlüssel, Wert in MeinMap
    MsgBox Schlüssel ' = ' Wert</pre>

<h3 id="Usage_Objects">Objekte</h3>
<p>Ein Objekt kann <em>Eigenschaften</em> und <em>Elemente</em> (z.B. Array-Elemente) haben. Der Zugriff auf Elemente erfolgt über <code>[]</code>, wie in den vorherigen Abschnitten gezeigt. Der Zugriff auf Eigenschaften erfolgt durch Anfügen eines Punktes und einem Identifikator (einfach ein <a href="Concepts.htm#names">Name</a>). <em>Methoden</em> sind Eigenschaften, die aufgerufen werden können.</p>
<p><strong>Beispiele:</strong></p>
<p>Abrufen oder Setzen einer Eigenschaft mit dem direkt geschriebenen Namen <em>Eigenschaft</em>:</p>
<pre>Wert := MeinObjekt.Eigenschaft</pre>
<pre>MeinObjekt.Eigenschaft := Wert</pre>
<p>Abrufen oder Setzen einer Eigenschaft mit einem via <a href="Language.htm#expressions">Ausdruck</a> oder <a href="Concepts.htm#variables">Variable</a> ermittelten Namen:</p>
<pre>Wert := MeinObjekt.%Ausdruck%</pre>
<pre>MeinObjekt.%Ausdruck% := Wert</pre>
<p>Aufrufen einer Eigenschaft/Methode mit dem direkt geschriebenen Namen <em>Methode</em>:</p>
<pre>RückgabeWert := MeinObjekt.Methode(Params)</pre>
<p>Aufrufen einer Eigenschaft/Methode mit einem via Ausdruck oder Variable ermittelten Namen:</p>
<pre>RückgabeWert := MeinObjekt.%Ausdruck%(Params)</pre>
<p>Manchmal werden beim Abrufen oder Zuweisen von Eigenschaften Parameter akzeptiert:</p>
<pre>Wert := MeinObjekt.Eigenschaft[Params]
MeinObjekt.Eigenschaft[Params] := Wert</pre>
<p>Ein Objekt kann auch Indexierung unterstützen: <code>MeinArray[Index]</code> ruft indirekt die <a href="#__Item">__Item</a>-Eigenschaft von <code>MeinArray</code> auf und übergibt <code>Index</code> als Parameter.</p>

<h3 id="object-literal">Direkt geschriebenes Objekt</h3>
<p>Ein direkt geschriebenes Objekt kann in einem <a href="Language.htm#expressions">Ausdruck</a> verwendet werden, um ein improvisiertes Objekt zu erstellen. Ein direkt geschriebenes Objekt besteht aus zwei geschweiften Klammern (<code>{}</code>), die eine Liste von kommagetrennten Name-Wert-Paaren umschließen. Jedes Paar besteht aus einem direkt geschriebenen (in Anführungszeichen gesetzten) <a href="Concepts.htm#names">Eigenschaftsnamen</a> und einem Wert (Teilausdruck), die mit einem Doppelpunkt (<code>:</code>) voneinander getrennt sind. Zum Beispiel:</p>
<pre>Koord := {X: 13, Y: 240}</pre>
<p>Folgendes ist äquivalent:</p>
<pre>Koord := Object()
Koord.X := 13
Koord.Y := 240</pre>
<p>Jedes Name-Wert-Paar definiert eine Werteigenschaft, mit der Ausnahme, dass <a href="lib/Object.htm#Base">Base</a> gesetzt werden kann (mit den gleichen Einschränkungen wie bei einer normalen Zuweisung).</p>
<p><a href="Variables.htm#deref">Namenssubstitution</a> ermöglicht die Bestimmung eines Eigenschaftsnamens durch Auswertung eines <a href="Language.htm#expressions">Ausdrucks</a> oder einer <a href="Concepts.htm#variables">Variable</a>. Zum Beispiel:</p>
<pre>Teile := StrSplit("Schlüssel = Wert", "=", " ")
Teil := {%Teile[1]%: Teile[2]}
MsgBox Teil.Schlüssel</pre>

<h3 id="Usage_Freeing_Objects">Objekte freigeben</h3>
<p>Skripte geben Objekte nicht explizit frei. Sobald die letzte Referenz zu einem Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Eine Referenz, die in einer Variable gespeichert ist, wird automatisch freigegeben, sobald dieser Variable ein anderer Wert zugewiesen wird. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt die letzte Referenz frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>Gleichermaßen wird eine Referenz, die in einer Eigenschaft oder einem Array-Element gespeichert ist, freigegeben, wenn diese Eigenschaft oder dieses Array-Element einen anderen Wert zugewiesen bekommt oder aus dem Objekt entfernt wird.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.RemoveAt(1)  <em>; Entfernt das zweite Objekt und gibt es frei.</em></pre>
<p id="Circular_References">Da alle Referenzen zu einem Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn z.B. <code>x.child</code> auf <code>y</code> und <code>y.parent</code> auf <code>x</code> verweist, genügt es nicht, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch eine Referenz zum Child-Objekt enthält, und umgekehrt. Um diese Situation zu lösen, entfernen Sie den Zirkelbezug.</p>
<pre>
x := {}, y := {}             <em>; Zwei Objekte erstellen.</em>
x.child := y, y.parent := x  <em>; Einen Zirkelbezug erstellen.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Ohne die obige Zeile würde dies die Objekte nicht freigeben.</em>
</pre>
<p>Eine ausführlichere Verwendung und Informationen finden Sie unter <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h2 id="Extended_Usage">Erweiterte Verwendung</h2>

<h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
<p>Obwohl "mehrdimensionale" Arrays nicht unterstützt werden, kann ein Skript mehrere Arrays oder Maps kombinieren. Zum Beispiel:</p>
<pre>
Gitter := [[1,2,3],
           [4,5,6],
           [7,8,9]]
MsgBox Gitter[1][3] <em>; 3</em>
MsgBox Gitter[3][2] <em>; 8</em>
</pre>
<p id="Array2D">Ein benutzerdefiniertes Objekt kann mehrdimensionale Unterstützung durch Definition einer <a href="#__Item">__Item</a>-Eigenschaft implementieren. Zum Beispiel:</p>
<pre>
class Array2D extends Array {
    __new(x, y) {
        this.Length := x * y
        this.Breite := x
        this.Höhe := y
    }
    __Item[x, y] {
        get =&gt; super.Has(this.i[x, y]) ? super[this.i[x, y]] : false
        set =&gt; super[this.i[x, y]] := value
    }
    i[x, y] =&gt; this.Width * (y-1) + x
}

Gitter := Array2D(4, 3)
Gitter[4, 1] := "#"
Gitter[3, 2] := "#"
Gitter[2, 2] := "#"
Gitter[1, 3] := "#"
GitterText := ""
Loop Gitter.Höhe {
    y := A_Index
    Loop Gitter.Breite {
        x := A_Index
        GitterText .= Gitter[x, y] || "-"
    }
    GitterText .= "`n"
}
MsgBox GitterText
</pre>
<p>Ein echtes Skript sollte eine Fehlerprüfung durchführen und andere Methoden überschreiben, wie z.B. <a href="#__Enum">__Enum</a>, um die Enumeration zu unterstützen.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Es gibt zwei verschiedene Möglichkeiten, benutzerdefinierte Objekte zu erstellen:</p>
<ul>
  <li><em>Ad hoc</em>: Ein Objekt erstellen und Eigenschaften hinzufügen.</li>
  <li><em>Delegation</em>: Eigenschaften in einem <em>Basisobjekt</em> oder einer Klasse definieren.</li>
</ul>
<p><a href="#Meta_Functions">Metafunktionen</a> können verwendet werden, um das Verhalten eines Objekts genauer zu steuern.</p>
<p class="note"><strong>Hinweis:</strong> In diesem Abschnitt ist ein <em>Objekt</em> eine Instanz der <a href="lib/Object.htm">Object</a>-Klasse. Dieser Abschnitt gilt nicht für COM-Objekte.</p>

<h3 id="ad-hoc">Ad Hoc</h3>
<p>Grundsätzlich kann ein neues Objekt jederzeit um Eigenschaften und Methoden (aufrufbare Eigenschaften) erweitert werden. Das folgende Beispiel zeigt, wie ein Objekt mit einer Eigenschaft und einer Methode konstruiert werden kann:</p>
<pre><em>; Ein Objekt erstellen.</em>
obj := {}
<em>; Einen Wert speichern.</em>
obj.foo := "bar"
<em>; Eine Methode definieren.</em>
obj.test := obj_test
<em>; Die Methode aufrufen.</em>
obj.test()

obj_test(this) {
    MsgBox this.foo
}</pre>
<p>Das obige Objekt kann auch mit <code>obj := {foo: "bar"}</code> erstellt werden. Bei der {Eigenschaft:Wert}-Schreibweise dürfen die Eigenschaften nicht in Anführungszeichen gesetzt werden.</p>
<p>Beim Aufruf von <code>obj.test()</code> wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Konventionsgemäß setzt sich der Name der Funktion aus dem "Typ" des Objekts und dem Namen der Methode zusammen, kann aber auch anders lauten.</p>
<p>Im obigen Beispiel kann <em>test</em>, nachdem es definiert wurde, eine andere Funktion oder ein anderer Wert zugewiesen werden; in diesem Fall geht die ursprüngliche Funktion verloren und kann nicht über diese Eigenschaft aufgerufen werden. Alternativ kann eine schreibgeschützte Methode definiert werden:</p>
<pre>obj.DefineProp 'test', {call: obj_test}</pre>
<p>Siehe auch: <a href="lib/Object.htm#DefineProp">DefineProp</a></p>

<h3 id="delegation">Delegation</h3>
<p>Objekte sind <em>prototypenbasiert</em>. Das heißt, dass alle Eigenschaften, die nicht im Objekt selbst definiert sind, stattdessen in der <a href="lib/Object.htm#Base">Basis</a> des Objekts definiert sein können. Dies wird als <em>Vererbung durch Delegation</em> oder <em>differentielle Vererbung</em> bezeichnet, da ein Objekt nur die Teile implementieren kann, die sich vom Objekt unterscheiden, und den Rest an seine Basis delegiert.</p>
<p>Obwohl ein Basisobjekt allgemein auch als Prototyp bekannt ist, verwenden wir "<a href="lib/Class.htm#Prototype">Prototyp</a> einer Klasse" für das Objekt, auf dem jede Instanz der Klasse basiert, und "Basis" für das Objekt, auf dem eine Instanz basiert.</p>
<p class="note">Das Objektdesign von AutoHotkey wurde hauptsächlich von JavaScript und Lua und ein wenig von C# beeinflusst. Wir verwenden <code><i>obj</i>.base</code> anstelle von JavaScripts <code><i>obj</i>.__proto__</code> und <code><i>cls</i>.Prototype</code> anstelle von JavaScripts <code><i>func</i>.prototype</code>. (Klassenobjekte werden anstelle von Konstruktorfunktionen verwendet.)</p>

<p>Die Basis eines Objekts wird auch verwendet, um seinen Typ oder seine Klasse zu identifizieren. Zum Beispiel erstellt <code>x := []</code> ein Objekt <em>basierend auf</em> <code>Array.Prototype</code>, d.h. die Ausdrücke <code>x is Array</code> und <code>x.HasBase(Array.Prototype)</code> sind True und <code>type(x)</code> gibt "Array" zurück. Der Prototyp jeder Klasse basiert auf dem Prototyp ihrer Basisklasse, daher ist <code>x.HasBase(Object.Prototype)</code> ebenfalls True.</p>
<p>Jede Instanz von Object oder eine abgeleitete Klasse kann ein Basisobjekt sein, aber ein Objekt kann nur <a href="lib/Object.htm#Base">als Basis</a> eines Objekts mit dem gleichen nativen Typ zugewiesen werden. Dadurch wird sichergestellt, dass interne Methoden immer den nativen Typ eines Objekts identifizieren können und dass sie nur mit Objekten arbeiten, die die korrekte binäre Struktur aufweisen.</p>
<p>Basisobjekte können auf zwei verschiedene Arten definiert werden:</p>
<ul>
  <li>Durch <a href="#creating-a-base-object">Erstellen eines normalen Objekts</a>.</li>
  <li>Durch <a href="#Custom_Classes">Definieren einer Klasse</a>. Jede Klasse hat eine <a href="lib/Class.htm#Prototype">Prototype</a>-Eigenschaft, die ein Objekt enthält, auf dem alle Instanzen dieser Klasse basieren, während die Klasse selbst zum Basisobjekt aller direkten Unterklassen wird.</li>
</ul>
<p>Ein Basisobjekt kann der <a href="lib/Object.htm#Base">Base</a>-Eigenschaft eines anderen Objekts zugewiesen werden, aber normalerweise wird die Basis eines Objekts implizit beim Erstellen festgelegt.</p>

<h3 id="creating-a-base-object">Basisobjekt erstellen</h3>
<p>Jedes Objekt kann als Basis eines anderen Objekts mit demselben nativen Typ verwendet werden. Das folgende Beispiel baut auf dem vorherigen Beispiel unter <a href="#ad-hoc">Ad Hoc</a> auf (kombinieren Sie beide vor der Ausführung):</p>
<pre>anderesObj := {}
anderesObj.base := obj
anderesObj.test()</pre>
<p><i>anderesObj</i> erbt in diesem Fall <i>foo</i> und <i>test</i> von <i>obj</i>. Diese Vererbung ist dynamisch, d.h. wenn <code>obj.foo</code> geändert wird, wird diese Änderung durch <code>anderesObj.foo</code> widergespiegelt. Wenn das Skript <code>anderesObj.foo</code> einen Wert zuweist, wird dieser Wert in <i>anderesObj</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Effekt auf <code>anderesObj.foo</code>. Beim Aufruf von <code>anderesObj.test()</code> enthält dessen <i>this</i>-Parameter eine Referenz zu <i>anderesObj</i> statt zu <i>obj</i>.</p>

<h3 id="Custom_Classes">Klassen</h3>
<blockquote>Unter einer Klasse (auch Objekttyp genannt) versteht man in der objektorientierten Programmierung ein abstraktes Modell bzw. einen Bauplan für eine Reihe von ähnlichen Objekten. <a href="https://en.wikipedia.org/wiki/Class_(computer_programming)" class="source">Wikipedia</a></blockquote>
<p>Allgemein ausgedrückt ist eine <em>Klasse</em> eine Gruppe oder Kategorie von Dingen, die gemeinsame Eigenschaften oder Attribute haben. In AutoHotkey definiert <code>class</code> Eigenschaften, die von Instanzen der Klasse gemeinsam verwendet werden (und Methoden, die aufrufbare Eigenschaften sind). Eine <em>Instanz</em> ist schlicht ein Objekt, das Eigenschaften von der Klasse erbt und typischerweise auch als Teil dieser Klasse verstanden werden kann (z.B. mit dem Ausdruck <code><i>Instanz</i> is <i>KlasseName</i></code>). Instanzen werden typischerweise durch den Aufruf von <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erzeugt.</p>
<p>Da <a href="lib/Object.htm">Objekte</a> <a href="#ad-hoc">dynamisch</a> und <a href="#delegation">prototypenbasiert</a> sind, besteht jede Klasse aus zwei Teilen:</p>
<ul>
  <li>Die Klasse hat ein <a href="lib/Class.htm#Prototype">Prototypobjekt</a>, auf dem alle Instanzen der Klasse basieren. Alle Methoden und dynamischen Eigenschaften, die sich auf Instanzen der Klasse beziehen, sind im Prototypobjekt enthalten. Dazu gehören alle Eigenschaften und Methoden, denen das Schlüsselwort <code>static</code> fehlt.</li>
  <li>Die Klasse selbst ist ein Objekt, das nur statische Methoden und Eigenschaften enthält. Dazu gehören alle Eigenschaften und Methoden mit dem Schlüsselwort <code>static</code> und alle verschachtelten Klassen. Diese gelten nicht für eine bestimmte Instanz und können verwendet werden, indem via Name auf die Klasse selbst verwiesen wird.</li>
</ul>
<p>Das Folgende zeigt die meisten Elemente einer Klassendefinition:</p>
<pre>class KlasseName extends BasisklasseName
{
    InstanzVar := <i>Ausdruck</i>
    
    static KlasseVar := <i>Ausdruck</i>

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }
    
    static Methode()
    {
        ...
    }

    Eigenschaft[<i>Parameter</i>]  <em>; Eckige Klammern nur verwenden, wenn Parameter vorhanden sind.</em>
    {
        <span class="dec">get</span> {
            return <i>Eigenschaftswert</i>
        }
        <span class="dec">set</span> {
            <i>Speichere oder verarbeite</i> <span class="biv">value</span>
        }
    }
    
    KurzeEigenschaft
    {
        <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
        <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
    }
    
    KürzereEigenschaft =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
}
</pre>
<p>Dies bewirkt, dass beim Laden des Skripts ein <a href="lib/Class.htm">Class</a>-Objekt konstruiert und in eine <a href="Functions.htm#Global">globale</a> Konstante (schreibgeschützte Variable) namens <i>KlasseName</i> gespeichert wird. Wenn <code>extends BasisklasseName</code> vorhanden ist, muss <i>BasisklasseName</i> der vollständige Name einer anderen Klasse sein. Der vollständige Name jeder Klasse ist in <code><i>KlasseName</i>.Prototype.__Class</code> gespeichert.</p>
<p>Da der Zugriff auf die Klasse selbst über eine Variable erfolgt, kann der Klassenname nicht verwendet werden, um im selben Kontext sowohl die Klasse zu referenzieren als auch eine separate Variable zu erstellen (um z.B. eine Instanz der Klasse zu enthalten). Zum Beispiel wird <code>box := Box()</code> nicht funktionieren, da sowohl <code>box</code> als auch <code>Box</code> in dasselbe aufgelöst werden. Der Versuch, eine Top-Level-Klasse (nicht verschachtelte Klasse) auf diese Weise neu zuzuweisen, führt zu einem Ladezeitfehler.</p>
<p>In dieser Dokumentation bezieht sich das Wort "Klasse" in der Regel auf ein Klassenobjekt, das mit dem Schlüsselwort <code>class</code> erstellt wurde.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen</h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert und verhalten sich auch wie solche, aber ohne Angabe des Präfixes <code>this.</code> (nur direkt im Körper der Klasse):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erstellt wird, nachdem alle Basisklassendeklarationen ausgewertet wurden, aber bevor <a href="#Custom_NewDelete">__New</a> aufgerufen wird. Dies wird erreicht, indem automatisch eine Methode namens <em>__Init</em> erstellt wird, die einen Aufruf von <code>super.__Init()</code> enthält, und jede Deklaration in diese eingefügt wird. Daher darf eine einzelne Klassendefinition weder eine __Init-Methode noch eine Instanzvariablendeklaration enthalten.</p>
<p><em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen. Globale Variablen können gelesen, aber nicht zugewiesen werden. Eine zusätzliche Zuweisung (oder die Verwendung des <a href="Variables.htm#ref">Referenzoperators</a>) innerhalb des Ausdrucks erzeugt in der Regel eine Variable, die lokal für die __Init-Methode ist. Zum Beispiel bewirkt <code>x := y := 1</code>, dass <code>this.x</code> und eine lokale Variable <code>y</code> gesetzt wird (die nach der Auswertung aller Initialisierungen wieder freigegeben wird).</p>
<p>Um auf eine Instanzvariable zuzugreifen (auch innerhalb einer Methode), geben Sie immer das Zielobjekt an, z.B. <code><b>this</b>.InstanzVar</code>.</p>
<p>Deklarationen wie <code>x.y := z</code> werden ebenfalls unterstützt, sofern vorher <code>x</code> in dieser Klasse definiert wurde. Zum Beispiel bewirkt <code>x := {}, x.y := 42</code>, dass <code>x</code> deklariert und außerdem <code>this.x.y</code> initialisiert wird.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen</h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, aber ihre Werte können von Unterklassen geerbt werden. Solche Variablen müssen mit dem Schlüsselwort "static" deklariert werden:</p>
<pre>static KlasseVar := Ausdruck</pre>
<p>Diese Deklarationen werden nur einmal beim <a href="#static__New">Initialisieren</a> der Klasse ausgewertet. Zu diesem Zweck wird automatisch eine statische Methode namens <em>__Init</em> definiert.</p>
<p>Jede Deklaration fungiert wie eine normale Eigenschaftszuweisung, mit dem Klassenobjekt als Ziel. <em>Ausdruck</em> wird genauso interpretiert wie die Instanzvariablen, außer dass <code>this</code> auf die Klasse selbst verweist.</p>
<p>Um einer Klassenvariable an anderer Stelle etwas zuzuweisen, geben Sie immer das Klassenobjekt an, z.B. <code><b>KlasseName</b>.KlasseVar := Wert</code>. Wenn eine Unterklasse keine Eigenschaft mit diesem Namen hat, kann auch mit <code><i>Unterklasse</i>.KlasseVar</code> der Wert abgerufen werden, d.h. wenn der Wert eine Referenz zu einem Objekt ist, teilen sich die Unterklassen standardmäßig dieses Objekt. Allerdings würde <code><i>Unterklasse</i>.KlasseVar := y</code> den Wert in <em>Unterklasse</em> speichern, nicht in <em>KlasseName</em>.</p>
<p>Deklarationen wie <code>static x.y := z</code> werden ebenfalls unterstützt, sofern vorher <code>x</code> in dieser Klasse definiert wurde. Zum Beispiel bewirkt <code>static x := {}, x.y := 42</code>, dass <code>x</code> deklariert und außerdem <code><i>KlasseName</i>.x.y</code> initialisiert wird. Da <a href="lib/Class.htm#Prototype">Prototype</a> implizit in jeder Klasse definiert ist, können mit <code>static Prototype.geteilterWert := 1</code> Werte gesetzt werden, die dynamisch von allen Instanzen der Klasse geerbt werden (bis sie durch eine Eigenschaft der Instanz selbst "überschrieben" werden).</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Verschachtelte Klassendefinitionen ermöglichen es, ein Klassenobjekt mit einer statischen bzw. Klassenvariable der äußeren Klasse zu assoziieren, anstatt mit einer separaten globalen Variablen. Im obigen Beispiel konstruiert <code>class VerschachtelteKlasse</code> ein <a href="lib/Class.htm">Class</a>-Objekt und speichert es in <code>KlasseName.VerschachtelteKlasse</code>. Unterklassen können <em>VerschachtelteKlasse</em> erben oder es mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall kann mit <code>(<i>WelcheKlasse</i>.VerschachtelteKlasse)()</code> die entsprechende Klasse instanziiert werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>
<p>Das Verschachteln einer Klasse impliziert keine besondere Beziehung zur äußeren Klasse. Weder wird die verschachtelte Klasse automatisch instanziiert, noch haben Instanzen der verschachtelten Klasse eine Verbindung zu einer Instanz der äußeren Klasse, es sei denn, das Skript stellt diese Verbindung explizit her.</p>
<p>Aufgrund der Funktionsweise der Methoden bei <a href="lib/Object.htm">Objekten</a> übergibt <code><i>WelcheKlasse</i>.VerschachtelteKlasse()</code> jedoch implizit <em>WelcheKlasse</em> als ersten Parameter, äquivalent zu <code><i>WelcheKlasse</i>.VerschachtelteKlasse.Call(<i>WelcheKlasse</i>)</code>. Sofern <code>static Call()</code> nicht überschrieben ist, wird dieser Parameter automatisch an <a href="#Custom_NewDelete">__New</a> übergeben.</p>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methodendefinition erstellt ein <a href="lib/Func.htm">Func</a> mit einem versteckten ersten Parameter namens <code>this</code> und definiert eine Eigenschaft, die zum Aufrufen der Methode oder zum Abrufen ihres Funktionsobjekts verwendet wird.</p>
<p>Es gibt zwei Arten von Methoden:</p>
<ul>
  <li>Instanzmethoden werden wie folgt definiert und an den <a href="lib/Class.htm#Prototype">Prototyp</a> der Klasse gebunden, so dass sie über jede Instanz der Klasse zugänglich sind. Wenn die Methode aufgerufen wird, verweist <code>this</code> auf eine Instanz der Klasse.</li>
  <li>Um statische Methoden zu definieren, stellen Sie dem Methodennamen das separate Schlüsselwort <code>static</code> voran. Diese sind an das Klassenobjekt selbst gebunden, werden aber auch von Unterklassen geerbt, so dass <code>this</code> entweder auf die Klasse selbst oder auf eine Unterklasse verweist.</li>
</ul>
<p>Die Methodendefinition unten erstellt eine Eigenschaft vom gleichen Typ wie <code><i>Ziel</i>.DefineProp('Methode', {call: <i>funcObj</i>})</code>. Standardmäßig gibt <code><i>Ziel</i>.Methode</code> <em>funcObj</em> zurück, und der Versuch, <code><i>Ziel</i>.Methode</code> etwas zuzuweisen, löst einen Fehler aus. Diese Standardverhalten können durch <a href="#Custom_Classes_property">Definieren einer Eigenschaft</a> oder Aufrufen von <a href="lib/Object.htm#DefineProp">DefineProp</a> überschrieben werden.</p>
<pre>
Methode()
{
    ...
}
</pre>

<p>Mit der <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann eine einzeilige Methode definiert werden, die ein Ausdruck zurückgibt:</p>
<pre>Methode() =&gt; <i>Ausdruck</i></pre>

<h4 id="Custom_Classes_super">Super</h4>
<p>Innerhalb einer Methode oder eines Eigenschafts-Getters/Setters kann das Schlüsselwort <code>super</code> anstelle von <code>this</code> verwendet werden, um auf Superklassenversionen von Methoden oder Eigenschaften zuzugreifen, die in einer abgeleiteten Klasse überschrieben werden. Zum Beispiel würde <code>super.Methode()</code> in der oben definierten Klasse typischerweise eine Version von <em>Methode</em> aufrufen, die innerhalb von <em>BasisklasseName</em> definiert wurde. Hinweis:</p>
<ul>
  <li><code>super.Methode()</code> ruft immer indirekt die Basis der Klasse oder des Prototypobjekts auf, das mit der ursprünglichen Definition der aktuellen Methode assoziiert ist, auch dann, wenn <code>this</code> von einer <em>Unterklasse</em> dieser Klasse oder von einer ganz anderen Klasse abgeleitet wurde.</li>
  <li><code>super.Methode()</code> übergibt implizit <code>this</code> als ersten (versteckten) Parameter.</li>
  <li>Da nicht bekannt ist, wo (oder ob) <em>KlasseName</em> in der Kette von Basisobjekten existiert, wird <em>KlasseName</em> selbst als Ausgangspunkt verwendet. Daher ist <code>super.Methode()</code> meistens äquivalent zu <code>(<i>KlasseName</i>.Prototype.base.Methode)(this)</code> (aber ohne <em>Prototype</em>, wenn <em>Methode</em> statisch ist). Allerdings wird <code><i>KlasseName</i>.Prototype</code> beim Laden des Skripts aufgelöst.</li>
  <li>Es wird ein Fehler ausgelöst, wenn die Eigenschaft nicht in einer Superklasse definiert ist oder nicht indirekt aufgerufen werden kann.</li>
</ul>
<p>Nach dem Schlüsselwort <code>super</code> muss eines der folgenden Symbole folgen: <code>.[(</code></p>
<p><code>super()</code> ist äquivalent zu <code>super.call()</code>.</p>

<h4 id="Custom_Classes_property">Eigenschaften</h4>
<p>Eine Eigenschaftsdefinition erzeugt eine <a href="lib/Object.htm#DefineProp">dynamische Eigenschaft</a>, die eine Methode aufruft, anstatt nur einen Wert zu speichern oder zurückzugeben.</p>
<pre>Eigenschaft[<i>Parameter</i>]
{
    <span class="dec">get</span> {
        return <i>Eigenschaftswert</i>
    }
    <span class="dec">set</span> {
        <i>Speichere oder verarbeite</i> <span class="biv">value</span>
    }
}
</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, der für ihren indirekten Aufruf verwendet wird. Zum Beispiel bewirkt <code>obj.Eigenschaft</code>, dass <em>get</em> aufgerufen wird, und <code>obj.Eigenschaft := Wert</code>, dass <em>set</em> aufgerufen wird. Innerhalb von <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das gerade indirekt aufgerufen wird. Innerhalb von <em>set</em> enthält <code>value</code> den Wert, der gerade zugewiesen wird.</p>
<p>Die Definition und Übergabe von Parametern erfolgt rechts vom Eigenschaftsnamen in eckigen Klammern - diese sollten jedoch weggelassen werden, wenn keine Parameter vorhanden sind (siehe unten). Abgesehen von der Verwendung eckiger Klammern werden die Parameter von Eigenschaften genauso definiert wie die Parameter von Methoden - optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Wenn eine Eigenschaft mit Parametern indirekt aufgerufen wird, aber keine definiert sind, werden Parameter automatisch an die <a href="#__Item">__Item</a>-Eigenschaft des von <em>get</em> zurückgegebenen Objekts weitergeleitet. Zum Beispiel hätte <code>this.Eigenschaft[x]</code> denselben Effekt wie <code>(this.Eigenschaft)[x]</code> oder <code>y := this.Eigenschaft, y[x]</code>. Leere Klammern (<code>this.Eigenschaft[]</code>) führen dazu, dass die __Item-Eigenschaft des Wertes von <em>Eigenschaft</em> immer indirekt aufgerufen wird, aber ein variadischer Aufruf wie <code>this.Eigenschaft[Args*]</code> hat diesen Effekt nur, wenn die Anzahl der Parameter ungleich Null ist.</p>
<p>Um statische Eigenschaften zu definieren, stellen Sie dem Eigenschaftsnamen das separate Schlüsselwort <code>static</code> voran. In diesem Fall verweist <code>this</code> auf die Klasse selbst oder auf eine Unterklasse.</p>
<p>Der Rückgabewert von <em>set</em> wird ignoriert. Zum Beispiel wird <code>Wert := obj.Eigenschaft := 42</code> immer <code>Wert := 42</code> zuweisen, egal was die Eigenschaft macht, es sei denn, sie löst eine Ausnahme aus oder beendet den Thread.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie <code><a href="#Custom_Classes_super">super.Eigenschaft</a></code> verwenden, um auf die von ihrer Basisklasse definierte Eigenschaft zuzugreifen. Wenn <em>Get</em> oder <em>Set</em> nicht definiert ist, kann es von einem Basisobjekt geerbt werden. Wenn <em>Get</em> undefiniert ist, kann die Eigenschaft einen Wert zurückgeben, der von einer Basis geerbt wurde. Wenn <em>Set</em> in diesem und allen Basisobjekten undefiniert ist (oder von einer geerbten Werteigenschaft verschleiert wird), löst der Versuch, die Eigenschaft zu setzen, eine Ausnahme aus.</p>
<p>Eine Eigenschaftsdefinition mit sowohl <em>Get</em> als auch <em>Set</em> erstellt faktisch zwei separate Funktionen, die weder lokale oder statische Variablen noch verschachtelte Funktionen gemeinsam nutzen. Analog zu den Methoden hat jede Funktion einen versteckten Parameter namens <code>this</code>, und <em>Set</em> hat einen zweiten versteckten Parameter namens <code>value</code>. Explizit definierte Parameter erfolgen danach.</p>
<p>Während eine Eigenschaftsdefinition die <em>Get</em>- und <em>Set</em>-Akzessorfunktionen für eine Eigenschaft auf die gleiche Weise wie <a href="lib/Object.htm#DefineProp">DefineProp</a> definiert, definiert eine Methodendefinition die <em>Call</em>-Akzessorfunktion. Jede Klasse kann eine Eigenschaftsdefinition und eine Methodendefinition gleichen Namens enthalten. Wenn eine Eigenschaft ohne <em>Call</em>-Akzessorfunktion (eine Methode) aufgerufen wird, wird <em>Get</em> ohne Parameter indirekt aufgerufen und das Ergebnis anschließend als Methode aufgerufen.</p>

<h4 id="Custom_Classes_property_short">Fat-Arrow-Eigenschaften</h4>
<p>Mit der <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann ein <a href="#Custom_Classes_property">Eigenschaft</a>-Getter oder -Setter definiert werden, der ein Ausdruck zurückgibt:</p>
<pre>KurzeEigenschaft[<i>Parameter</i>]
{
    <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
    <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
}</pre>
<p>Wenn nur ein Getter definiert wird, können die geschweiften Klammern und <code>get</code> weggelassen werden:</p>
<pre>KürzereEigenschaft[<i>Parameter</i>] =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i></pre>
<p>In beiden Fällen müssen die eckigen Klammern weggelassen werden, es sei denn, Parameter sind definiert.</p>

<h3 id="__Enum">__Enum-Methode</h3>
<pre class="Syntax">__Enum(AnzahlVars)</pre>
<p>Die __Enum-Methode wird aufgerufen, wenn das Objekt an eine <a href="lib/For.htm">For-Schleife</a> übergeben wird. Diese Methode sollte einen <a href="lib/Enumerator.htm">Enumerator</a> zurückgeben, der Elemente im Objekt zurückgibt, wie z.B. Array-Elemente. Wenn es undefiniert bleibt, kann das Objekt nicht direkt an eine For-Schleife übergeben werden, es sei denn, es hat eine <a href="lib/Enumerator.htm#Call">Enumerator-kompatible Call-Methode</a>.</p>
<p><em>AnzahlVars</em> enthält die Anzahl der Variablen, die an die For-Schleife übergeben wurden. Wenn <em>AnzahlVars</em> 2 ist, wird erwartet, dass der Enumerator dem ersten Parameter den Schlüssel oder Index eines Elements und dem zweiten Parameter den Wert zuweist. Jeder Schlüssel oder Index sollte als Parameter der <a href="#__Item">__Item</a>-Eigenschaft akzeptiert werden. Dies befähigt <a href="AHKL_DBGPClients.htm">DBGp-basierte Debugger</a>, ein bestimmtes Element abzurufen oder zu setzen, nachdem sie durch indirekten Aufruf des Enumerators aufgelistet wurden.</p>

<h3 id="__Item">__Item-Eigenschaft</h3>
<p>Die __Item-Eigenschaft wird indirekt aufgerufen, wenn der Indexierungsoperator (Arraysyntax) in Verbindung mit dem Objekt verwendet wird. Im folgenden Beispiel wird die Eigenschaft als statisch deklariert, so dass der Indexierungsoperator auf die Env-Klasse selbst angewendet werden kann. Ein weiteres Beispiel finden Sie unter <a href="#Array2D">Array2D</a>.</p>
<pre>class Env {
    static __Item[name] {
        get =&gt; EnvGet(name)
        set =&gt; EnvSet(name, value)
    }
}

Env["PATH"] .= ";" A_ScriptDir  <em>; Betrifft nur dieses Skript und Unterprozesse.</em>
MsgBox Env["PATH"]</pre>
<p><code>__Item</code> ist quasi ein Standardeigenschaftsname (falls eine solche Eigenschaft definiert wurde):</p>
<ul>
  <li><code><i>object</i>[<i>params</i>]</code> ist äquivalent zu <code><i>object</i>.__Item[<i>params</i>]</code>, wenn Parameter vorhanden sind.</li>
  <li><code><i>object</i>[]</code> ist äquivalent zu <code><i>object</i>.__Item</code>.</li>
</ul>
<p>Zum Beispiel:</p>
<pre>
obj := {}
obj[] := Map()     <em>; Äquivalent zu obj.__Item := Map()</em>
obj["base"] := 10
MsgBox obj.base = Object.prototype  <em>; True</em>
MsgBox obj["base"]                  <em>; 10</em>
</pre>
<p class="note"><strong>Hinweis:</strong> Wenn ein expliziter Eigenschaftsname mit leeren eckigen Klammern kombiniert wird, wie in <code>obj.prop[]</code>, wird dies als zwei separate Operationen behandelt: Zuerst <code>obj.prop</code> abrufen und dann die Standardeigenschaft des Ergebnisses indirekt aufrufen. Dies ist Teil der Sprachsyntax und somit objektunabhängig.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Jedes Mal, wenn ein Objekt mit der Standardimplementierung von <a href="lib/Class.htm#Call"><em>KlasseName</em>()</a> erstellt wird, wird die <code>__New</code>-Methode des neuen Objekts aufgerufen, um eine benutzerdefinierte Initialisierung zu ermöglichen. Alle Parameter, die an <code><i>KlasseName</i>()</code> übergeben werden, werden an <code>__New</code> weitergeleitet, so dass sie den ursprünglichen Inhalt des Objekts oder die Art und Weise, wie es konstruiert wird, beeinflussen können. Bei Zerstörung des Objekts wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
<pre>m1 := GMem(0, 10)
m2 := {base: GMem.Prototype}, m2.__New(0, 30)

<em>; Hinweis: Für allgemeine Speicherreservierungen stattdessen <a href="lib/Buffer.htm">Buffer</a>() verwenden.</em>
class GMem<span id="GMem"></span>
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aGröße, "Ptr")
        if !this.ptr
            throw MemoryError()
        MsgBox "Neues GMem von " aGröße " Bytes auf Adresse " this.ptr "."
    }

    __Delete()
    {
        MsgBox "GMem auf Adresse " this.ptr " löschen."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete wird nicht für Objekte aufgerufen, die eine Eigenschaft namens "__Class" haben. <a href="lib/Class.htm#Prototype">Prototypobjekte</a> haben diese Eigenschaft standardmäßig.</p>
<p>Wenn ein Ausnahme- oder Laufzeitfehler bei der Ausführung von __Delete ausgelöst und nicht innerhalb von __Delete behandelt wird, verhält es sich so, als wäre __Delete von einem neuen <a href="misc/Threads.htm">Thread</a> aufgerufen worden. Das heißt, dass ein Fehlerdialogfenster angezeigt wird und __Delete zurückkehrt, aber der Thread nicht beendet wird (es sei denn, er wurde bereits beendet).</p>
<p>Wenn das Skript auf irgendeine Weise direkt terminiert wird, z.B. über das Tray-Menü oder <a href="lib/ExitApp.htm">ExitApp</a>, bekommen alle Funktionen, die noch nicht zu ihrem Aufrufer zurückgekehrt sind, keine Chance, dies jemals zu tun. Daher werden alle Objekte, die von lokalen Variablen dieser Funktionen referenziert werden, nicht freigegeben, was dazu führt, dass __Delete nicht aufgerufen wird.</p>
<p>Bei Beendigung des Skripts werden Objekte, die in globalen und statischen Variablen enthalten sind, automatisch in einer willkürlichen, von der Implementierung festgelegten Reihenfolge freigegeben. Wenn __Delete während dieses Vorgangs aufgerufen wird, können einige globale oder statische Variablen bereits freigegeben worden sein, aber alle Referenzen, die das Objekt selbst enthält, sind noch gültig. Daher ist es am besten, wenn __Delete völlig eigenständig ist und nicht auf globale oder statische Variablen angewiesen ist.</p>

<h4 id="static__New">Klasseninitialisierung</h4>
<p>Jede Klasse wird automatisch initialisiert, wenn eine Referenz zur Klasse erstmals ausgewertet wird. Wenn z.B. <em>MeineKlasse</em> noch nicht initialisiert wurde, würde <code>MeineKlasse.MeineEigenschaft</code> bewirken, dass die Klasse initialisiert wird, bevor die Eigenschaft abgerufen wird. Die Initialisierung umfasst den Aufruf von zwei statischen Methoden: __Init und __New.</p>
<p><code>static __Init</code> wird automatisch für jede Klasse definiert und beginnt immer mit einer Referenz zur Basisklasse, falls angegeben, um sicherzustellen, dass sie initialisiert ist. <a href="#Custom_Classes_staticvar">Statische bzw. Klassenvariablen</a> und <a href="#Custom_Classes_class">verschachtelte Klassen</a> werden in der Reihenfolge initialisiert, in der sie definiert wurden, außer wenn eine verschachtelte Klasse während der Initialisierung einer vorherigen Variable oder Klasse referenziert wird.</p>
<p>Wenn die Klasse eine <code>static __New</code>-Methode definiert oder erbt, wird diese unmittelbar nach __Init aufgerufen. Es ist wichtig zu beachten, dass __New einmal für die Klasse, in der es definiert ist, <em>und</em> einmal für jede Unterklasse, die keine eigene definiert (oder die <code>super.__New()</code> aufruft), aufgerufen werden kann. Dies kann verwendet werden, um allgemeine Initialisierungsaufgaben für jede Unterklasse durchzuführen oder um Unterklassen vor ihrer Verwendung in irgendeiner Weise zu modifizieren.</p>
<p>Wenn <code>static __New</code> nicht mit abgeleiteten Klassen arbeiten soll, kann dies durch die Überprüfung des Wertes von <code>this</code> vermieden werden. In einigen Fällen kann es ausreichend sein, dass die Methode sich selbst löscht, wie z.B. bei <code>this.DeleteProp('__New')</code>; allerdings könnte die erste Ausführung von __New für eine Unterklasse sein, wenn diese in der Basisklasse verschachtelt ist oder bei der Initialisierung einer statischen bzw. Klassenvariable referenziert wird.</p>
<p>Eine Klassendefinition bewirkt auch, dass die Klasse referenziert wird. Mit anderen Worten, wenn die Ausführung während der <a href="Scripts.htm#auto">Startphase des Skripts</a> eine Klassendefinition erreicht, werden __Init und __New automatisch aufgerufen, es sei denn, die Klasse wurde bereits vom Skript referenziert. Wenn die Ausführung jedoch daran gehindert wird, die Klassendefinition zu erreichen, z.B. durch <code>return</code> oder eine Endlosschleife, wird die Klasse erst initialisiert, wenn sie referenziert wird.</p>
<p>Wenn die automatische Initialisierung einmal begonnen hat, wird sie für dieselbe Klasse nicht erneut durchgeführt. Dies ist grundsätzlich kein Problem, es sei denn, mehrere Klassen referenzieren sich gegenseitig. Nehmen wir zum Beispiel die folgenden zwei Klassen. Wenn <code>A</code> zuerst initialisiert wird, bewirkt die Auswertung von <code>B.SharedArray</code> (A1), dass <code>B</code> initialisiert wird, bevor der Wert abgerufen und zurückgegeben wird, aber <code>A.SharedValue</code> (A3) ist undefiniert und bewirkt keine Initialisierung von <code>A</code>, da diese bereits im Gange ist. Mit anderen Worten, wenn <code>A</code> erstmals verwendet oder initialisiert wird, ist die Reihenfolge A1 bis A3, sonst B1 bis B4:</p>
<pre>MsgBox A.SharedArray.Length
MsgBox B.SharedValue

class A {
    static SharedArray := B.SharedArray   <em>; A1          ; B3</em>
    static SharedValue := 42                            <em>; B4</em>
}

class B {
    static SharedArray := StrSplit("XYZ") <em>; A2          ; B1</em>
    static SharedValue := A.SharedValue   <em>; A3 (Error)  ; B2</em>
}</pre>

<h3 id="Meta_Functions">Metafunktionen</h3>
<pre class="Syntax">
class <i>KlasseName</i> {
    __Get(Name, Params)
    __Set(Name, Params, Wert)
    __Call(Name, Params)
}
</pre>
<dl>
  <dt>Name</dt>
  <dd><p>Der Name der Eigenschaft oder Methode.</p></dd>
  <dt>Params</dt>
  <dd><p>Ein <a href="lib/Array.htm">Array</a> von Parametern. Dies umfasst nur die Parameter zwischen <code>()</code> oder <code>[]</code>, kann also leer sein. Die Metafunktion soll Fälle wie <code>x.y[z]</code> behandeln, in denen <code>x.y</code> undefiniert ist.</p></dd>
  <dt>Wert</dt>
  <dd><p>Der Wert, der zugewiesen wird.</p></dd>
</dl>
<p>Metafunktionen definieren, was passieren soll, wenn eine undefinierte Eigenschaft oder Methode indirekt aufgerufen wird. Wenn z.B. <code>obj.unk</code> keinen Wert zugewiesen bekommen hat, ruft es indirekt die <i>__Get</i>-Metafunktion auf. <code>obj.unk := Wert</code> bewirkt dagegen den indirekten Aufruf von <i>__Set</i> und <code>obj.unk()</code> den indirekten Aufruf von <i>__Call</i>.</p>
<p>Eigenschaften und Methoden können im Objekt selbst oder in einem seiner <a href="#delegation">Basisobjekte</a> definiert werden. Damit für jede Eigenschaft eine Metafunktion aufgerufen wird, sollte die Definition von Eigenschaften grundsätzlich vermieden werden. Interne Eigenschaften wie <a href="lib/Object.htm#Base">Base</a> können mit einer <a href="#Custom_Classes_property">Eigenschaftsdefinition</a> oder <a href="lib/Object.htm#DefineProp">DefineProp</a> überschrieben werden.</p>
<p>Wenn eine Metafunktion definiert ist, muss sie die gewünschte Standardaktion ausführen. Zum Beispiel kann Folgendes erwartet werden:</p>
<ul>
  <li><i>Call</i>: Einen <a href="lib/Error.htm#MethodError">MethodError</a> auslösen.</li>
  <li>Wenn Parameter übergeben wurden, eine Ausnahme auslösen (es gibt kein Objekt, an das die Parameter weitergeleitet werden können).</li>
  <li><i>Get</i>: Einen <a href="lib/Error.htm#PropertyError">PropertyError</a> auslösen.</li>
  <li><i>Set</i>: Eine neue Eigenschaft mit dem angegebenen Wert definieren, z.B. durch Aufruf von <a href="lib/Object.htm#DefineProp">DefineProp</a>. </li>
</ul>
<p>Jedes <a href="misc/Functor.htm">aufrufbare Objekt</a> kann als Metafunktion verwendet werden, wenn es der entsprechenden Eigenschaft zugewiesen wird.</p>
<p>Metafunktionen werden in den folgenden Fällen nicht aufgerufen:</p>
<ul>
  <li><code>x[y]</code>: Die Verwendung von eckigen Klammern ohne Eigenschaftsnamen ruft indirekt nur die <a href="#__Item">__Item</a>-Eigenschaft auf.</li>
  <li><code>x()</code>: Der Aufruf des Objekts selbst ruft indirekt nur die <code>Call</code>-Methode auf. Dies umfasst interne Aufrufe durch interne Funktionen wie <a href="lib/SetTimer.htm">SetTimer</a> und <a href="lib/Hotkey.htm">Hotkey</a>.</li>
  <li>Interne Aufrufe von anderen Metafunktionen oder Doppel-Unterstrich-Methoden lösen <code>__Call</code> nicht aus.</li>
</ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Die <a href="#Custom_Classes_property">Eigenschaftssyntax</a> und <a href="lib/Object.htm#DefineProp">DefineProp</a> ermöglichen die Definition von Eigenschaften, die bei jeder Auswertung einen Wert ermitteln, allerdings muss jede Eigenschaft im Voraus definiert sein. Mit <em>__Get</em> und <em>__Set</em> können hingegen Eigenschaften implementiert werden, die erst zum Zeitpunkt ihres indirekten Aufrufs bekannt sind.</p>
<p>Zum Beispiel kann ein "Proxy-Objekt" mit Eigenschaften erstellt werden, die den aktuellen Wert über das Netzwerk (oder über einen anderen Kanal) abfragen. Ein Remote-Server sendet eine Antwort zurück, die den Wert der Eigenschaft enthält, und das Proxy-Objekt übergibt den Wert an seinen Aufrufer. Selbst wenn der Name jeder Eigenschaft im Voraus bekannt wäre, würde es keinen Sinn machen, jede Eigenschaft einzeln in der Proxy-Klasse zu definieren, da jede Eigenschaft dasselbe bewirkt (eine Netzwerkanfrage senden). Metafunktionen empfangen den Namen der Eigenschaft als Parameter und sind daher eine gute Lösung für dieses Problem.</p>

<h2 id="primitive">Primitive Werte</h2>
<p>Primitive Werte wie Zeichenketten und Zahlen können keine eigenen Eigenschaften und Methoden haben. Allerdings unterstützen primitive Werte die gleiche Art der <a href="#delegation">Delegation</a> wie Objekte. Das heißt, dass jeder Eigenschafts- oder Methodenaufruf bei einem primitiven Wert an ein vordefiniertes Prototypobjekt delegiert wird, auf das auch über die <a href="lib/Class.htm#Prototype">Prototype</a>-Eigenschaft der entsprechenden Klasse zugegriffen werden kann. Die folgenden Klassen beziehen sich auf primitive Werte:</p>
<ul style="line-height: 1.5">
  <li>Primitive (extends <a href="lib/Any.htm">Any</a>) <ul style="padding-left: 1.7em">
    <li>Number <ul style="padding-left: 1.7em">
      <li>Float</li>
      <li>Integer</li>
    </ul></li>
    <li>String</li>
  </ul></li>
</ul>
<p>Obwohl die Überprüfung der <a href="lib/Type.htm">Type</a>-Zeichenkette in der Regel schneller ist, kann der Typ eines Wertes auch getestet werden, indem geprüft wird, ob der Wert eine Basis hat. Zum Beispiel ist <code>n.HasBase(Number.Prototype)</code> oder <code>n is Number</code> True, wenn <em>n</em> ein reiner Integer oder eine reine Floating-Point-Zahl ist, aber False, wenn <em>n</em> eine numerische Zeichenkette ist, da String nicht von Number ableitet. <code>IsNumber(n)</code> hingegen ist True, wenn <em>n</em> eine Zahl oder numerische Zeichenkette ist.</p>
<p><a href="lib/Any.htm#GetBase">ObjGetBase</a> und die <a href="lib/Any.htm#Base">Base</a>-Eigenschaft geben ggf. eines der vordefinierten Prototypobjekte zurück.</p>
<p>Beachten Sie, dass <code>x is Any</code> normalerweise True für jeden Wert innerhalb der Typenhierarchie von AutoHotkey ist, aber False für COM-Objekte ist.</p>

<h3 id="primitive-extension">Eigenschaften und Methoden hinzufügen</h3>
<p>Eigenschaften und Methoden können für alle Werte eines bestimmten Typs hinzugefügt werden, indem das Prototypobjekt dieses Typs geändert wird. Da jedoch ein primitiver Wert kein Object ist und keine eigenen Eigenschaften oder Methoden haben kann, werden die primitiven Prototypobjekte nicht von <code>Object.Prototype</code> ableiten. Mit anderen Worten, es ist standardmäßig nicht möglich, auf Methoden wie <a href="lib/Object.htm#DefineProp">DefineProp</a> und <a href="lib/Object.htm#HasOwnProp">HasOwnProp</a> zuzugreifen. Diese können indirekt aufgerufen werden. Zum Beispiel:</p>
<pre>
DefProp := {}.DefineProp
DefProp( "".base, "Length", { get: StrLen } )
MsgBox A_AhkPath.length " == " StrLen(A_AhkPath)
</pre>
<p>Obwohl primitive Werte Werteigenschaften von ihrem Prototyp erben können, wird eine Ausnahme ausgelöst, wenn das Skript versucht, eine Werteigenschaft bei einem primitiven Wert zu setzen. Zum Beispiel:</p>
<pre>"".base.test := 1  <em>; Bitte nicht nachmachen.</em>
MsgBox "".test  <em>; 1</em>
"".test := 2  <em>; Fehler: Eigenschaft ist schreibgeschützt.</em></pre>
<p>Obwohl __Set und Eigenschafts-Setter verwendet werden können, sind sie nicht nützlich, da primitive Werte als unveränderlich zu betrachten sind.</p>

<h2 id="Implementation">Implementierung</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet einen einfachen Referenzzählmechanismus, um belegte Ressourcen eines Objekts automatisch freizugeben, wenn es nicht länger im Skript referenziert wird. Skriptautoren sollten diesen Mechanismus nicht explizit aufrufen, es sei denn, sie arbeiten direkt mit unverwalteten <a href="#ObjPtr">Objektpointern</a>.</p>
<p>Temporäre Referenzen, die von Funktionen, Methoden oder Operatoren innerhalb eines Ausdrucks zurückgegeben werden, werden erst freigegeben, wenn die Auswertung dieses Ausdrucks abgeschlossen oder abgebrochen wurde. Im folgenden Beispiel wird das neue <a href="#GMem">GMem</a>-Objekt erst nach Abschluss von MsgBox freigegeben:</p>
<pre>MsgBox <a href="lib/DllCall.htm">DllCall</a>("GlobalSize", "ptr", GMem(0, 20).ptr, "ptr")  <em>; 20</em></pre>
<p class="note"><strong>Hinweis:</strong> In diesem Beispiel kann <code>.ptr</code> weggelassen werden, da der <a href="lib/DllCall.htm#ptr">Ptr</a>-Argumenttyp Objekte mit einer <code>Ptr</code>-Eigenschaft zulässt. Allerdings funktioniert das oben gezeigte Muster auch mit anderen Eigenschaftsnamen.</p>
<p>Um Code beim Freigeben der letzten Referenz zu einem Objekt auszuführen, implementieren Sie die <a href="#Custom_NewDelete">__Delete</a>-Metafunktion.</p>
<p><b>Bekannte Einschränkungen:</b></p>
<ul>
  <li>Zirkelbezüge müssen unterbrochen werden, bevor ein Objekt freigegeben werden kann. Weitere Informationen und ein Beispiel finden Sie unter <a href="#Circular_References">Objekte freigeben</a>.</li>
  <li>Referenzen in statischen und globalen Variablen werden bei Beendigung des Programms automatisch freigegeben. Dies gilt jedoch nicht für Referenzen in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel. Solche Referenzen werden erst freigegeben, wenn die Funktion oder der Ausdruck regulär beendet werden kann.</li>
</ul>
<p>Obwohl das Betriebssystem den vom Objekt belegten Speicher bei Beendigung des Programms zurückfordern wird, wird <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen, wenn alle Referenzen zum Objekt freigegeben wurden. Dies kann wichtig sein, wenn es andere Ressourcen freigibt, die nicht automatisch vom Betriebssystem zurückgefordert werden, wie z.B. temporäre Dateien.</p>

<h3 id="ObjPtr">Objektpointer</h3>
<p>In seltenen Fällen kann es erforderlich sein, dass ein Objekt via DllCall an einen externen Code übergeben werden muss oder dass ein Objekt in eine binäre Datenstruktur für späteren Gebrauch gespeichert werden muss. Die Adresse eines Objekts kann via <code>Adresse := ObjPtr(meinObjekt)</code> abgerufen werden, allerdings werden dadurch effektiv zwei Referenzen zum Objekt erzeugt, während das Programm selbst nur die eine Referenz in <em>meinObjekt</em> kennt. Das Objekt wird gelöscht, sobald die letzte <em>bekannte</em> Referenz zum Objekt freigegeben wird. Folglich muss das Skript dem Objekt mitteilen, dass es eine Referenz erhalten hat. Dies kann wie folgt erreicht werden (die folgenden zwei Zeilen sind äquivalent):</p>
<pre>
ObjAddRef(Adresse := ObjPtr(meinObjekt))
Adresse := ObjPtrAddRef(meinObjekt)
</pre>
<p>Außerdem muss das Objekt informiert werden, wenn das Skript mit dieser Referenz fertig ist:</p>
<pre>ObjRelease(Adresse)</pre>
<p>Generell sollte jede neue Kopie einer Objektadresse als separate Referenz zum Objekt behandelt werden, d.h. das Skript sollte <a href="lib/ObjAddRef.htm">ObjAddRef</a> aufrufen, wenn es eine Kopie erhält, und sofort <a href="lib/ObjAddRef.htm">ObjRelease</a> aufrufen, bevor es eine Kopie verliert. Zum Beispiel sollte immer <a href="lib/ObjAddRef.htm">ObjAddRef</a> aufgerufen werden, wenn eine Adresse mit so etwas wie <code>x := Adresse</code> kopiert wird. Ebenso sollte das Skript <a href="lib/ObjAddRef.htm">ObjRelease</a> aufrufen, wenn es mit <em>x</em> fertig ist (oder dabei ist, den Wert von <em>x</em> zu überschreiben).</p>
<p id="ObjFromPtr">Mit der ObjFromPtr-Funktion kann eine Adresse in eine geeignete Referenz umgewandelt werden:</p>
<pre>meinObjekt := ObjFromPtr(Adresse)</pre>
<p>ObjFromPtr vermutet, dass <em>Adresse</em> eine gezählte Referenz ist, und nimmt sie in Besitz. Mit anderen Worten, <code>meinObjekt := ""</code> bewirkt, dass die Referenz, ursprünglich durch <em>Adresse</em> repräsentiert, freigegeben wird. Danach muss <em>Adresse</em> als ungültig betrachtet werden. Um stattdessen eine neue Referenz zu erstellen, verwenden Sie eine der folgenden Möglichkeiten:</p>
<pre>
ObjAddRef(Adresse), meinObjekt := ObjFromPtr(Adresse)
meinObjekt := ObjFromPtrAddRef(Adresse)
</pre>

</body>
</html>
