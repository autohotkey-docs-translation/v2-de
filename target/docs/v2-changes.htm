<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Änderungen von v1.1 bis v2.0 | AutoHotkey v2</title>
<meta name="description" content="Änderungen zwischen v1.1 und v2.0." />
<meta name="ahk:equiv-v1" content="AHKL_ChangeLog.htm" />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga4.js" type="text/javascript"></script>
</head>
<body>
<h1>Änderungen von v1.1 bis v2.0</h1>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#language">Sprache</a>
    <ul>
      <li><a href="#legacy-syntax-removed">Legacy-Syntax entfernt</a></li>
      <li><a href="#hotkey-and-hotstring-labels">Hotkey- und Hotstring-Labels</a></li>
      <li><a href="#names">Namen</a></li>
      <li><a href="#scope">Gültigkeitsbereich</a></li>
      <li><a href="#variables">Variablen</a></li>
      <li><a href="#expressions">Ausdrücke (Expressions)</a></li>
      <li><a href="#objects-misc">Objekte (Sonstiges)</a></li>
      <li><a href="#functions">Funktionen</a></li>
      <li><a href="#nested-functions">Verschachtelte Funktionen</a></li>
      <li><a href="#uncategorized">Sonstiges</a></li>
      <li><a href="#continuation-sections">Fortsetzungsbereiche</a></li>
      <li><a href="#continuation-lines">Fortsetzungszeilen</a></li>
      <li><a href="#types">Typen</a></li>
    </ul>
  </li>
  <li><a href="#objects">Objekte</a>
    <ul>
      <li><a href="#primitive-values">Primitive Werte</a></li>
      <li><a href="#properties-and-methods">Eigenschaften und Methoden</a></li>
      <li><a href="#staticclass-variables">Statische bzw. Klassenvariablen</a></li>
      <li><a href="#meta-functions">Metafunktionen</a></li>
      <li><a href="#array">Array</a></li>
      <li><a href="#map">Map</a></li>
      <li><a href="#enumeration">Enumeration</a></li>
      <li><a href="#bound-functions">Bound-Funktionen</a></li>
      <li><a href="#com-objects-comobject">COM-Objekte (ComObject)</a></li>
      <li><a href="#default-property">Standardeigenschaft</a></li>
      <li><a href="#com-calls">COM-Aufrufe</a></li>
    </ul>
  </li>
  <li><a href="#library">Library</a>
    <ul>
      <li><a href="#removed-details">Entfernte Befehle (Details)</a></li>
      <li><a href="#modified-commandsfunctions">Geänderte Befehle/Funktionen</a></li>
      <li><a href="#new-functions">Neue Funktionen</a></li>
      <li><a href="#new-directives">Neue Direktiven</a></li>
      <li><a href="#built-in-variables">Interne Variablen</a></li>
      <li><a href="#built-in-objects">Interne Objekte</a></li>
    </ul>
  </li>
  <li><a href="#gui">Gui</a>
    <ul>
      <li><a href="#gui-sub-commands">Gui-Unterbefehle</a></li>
      <li><a href="#events">Ereignisse</a></li>
      <li><a href="#removed">Entfernt</a></li>
      <li><a href="#control-options">Steuerelementoptionen</a></li>
      <li><a href="#guicontrolget">GuiControlGet</a></li>
      <li><a href="#guicontrol">GuiControl</a></li>
      <li><a href="#other-changes">Sonstige Änderungen</a></li>
    </ul>
  </li>
  <li><a href="#error-handling">Fehlerbehandlung</a>
    <ul>
      <li><a href="#continuable-errors">Fortsetzbare Fehler</a></li>
      <li><a href="#errorlevel">ErrorLevel</a></li>
      <li><a href="#expressions-1">Ausdrücke (Expressions)</a></li>
      <li><a href="#functions-1">Funktionen</a></li>
      <li><a href="#catch">Catch</a></li>
    </ul>
  </li>
  <li><a href="#keyboard-mouse-hotkeys-and-hotstrings">Tastatur, Maus, Hotkeys und Hotstrings</a></li>
  <li><a href="#other">Sonstiges</a>
    <ul>
      <li><a href="#persistence">Persistenz</a></li>
      <li><a href="#threads">Threads</a></li>
      <li><a href="#default-settings">Standardeinstellungen</a></li>
      <li><a href="#default-script">Standardskript</a></li>
      <li><a href="#command-line">Befehlszeile</a></li>
    </ul>
  </li>
</ul>

<h2 id="language">Sprache</h2>
<h3 id="legacy-syntax-removed">Legacy-Syntax entfernt</h3>
<p>Direkt geschriebene Zuweisungen wurden entfernt:  <code>Var = Wert</code></p>
<p>Alle Legacy-If-Anweisungen wurden entfernt, so dass nur noch <code>if Ausdruck</code> übrig bleibt, das nie Klammern erfordert (aber erlaubt, wie bei jedem Ausdruck).</p>
<p>Die "Befehlssyntax" wurde entfernt. Es gibt keine "Befehle" mehr, sondern nur noch <a href="Language.htm#function-call-statements"><em>Funktionsaufrufanweisungen</em></a> - das sind nichts anderes als Funktions- oder Methodenaufrufe ohne runde Klammern. Das bedeutet:</p>
<ul>
<li>Alle ehemaligen Befehle sind jetzt Funktionen (außer Kontrollanweisungen).</li>
<li>Alle Funktionen können ohne runde Klammern aufgerufen werden, wenn der Rückgabewert nicht benötigt wird (aber nach wie vor können die runden Klammern bei Aufrufen innerhalb eines Ausdrucks nicht weggelassen werden).</li>
<li>Alle Parameter sind Ausdrücke, d.h. Text wird in Anführungszeichen gesetzt, und Kommas müssen nicht mit Escapezeichen versehen werden. Derzeit sind einige wenige Direktiven (die weder Befehle noch Funktionen sind) davon ausgenommen.</li>
<li>Parameter bleiben gleich, unabhängig von runden Klammern, d.h. es gibt keine Ausgabevariable für den Rückgabewert, folglich wird er verworfen, wenn die Klammern weggelassen werden.</li>
<li>Normale Variablenreferenzen werden nie mit Prozentzeichen umschlossen (außer bei <a href="lib/_Include.htm">#Include</a> und <a href="lib/_DllLoad.htm">#DllLoad</a>). Verwenden Sie <a href="Variables.htm#concat">Verkettung</a> oder <a href="lib/Format.htm">Format</a>, um Variablen in einen Text einzufügen.</li>
<li>Zwischen dem Funktionsnamen und dem ersten Parameter wird kein Komma gesetzt, folglich ist <code>WinMove(, y)</code> gleich <code>WinMove , y</code> (x wurde weggelassen). Ein Leer- oder Tabulatorzeichen ist erforderlich. Aus Konsistenzgründen folgen auch Direktiven der neuen Konvention (zwischen dem Direktivennamen und dem ersten Parameter darf kein Komma stehen).</li>
<li>Das Prozent-Leerzeichen-Präfix zum Erzwingen eines Ausdrucks gibt es nicht mehr. Anführungszeichenlose Prozentzeichen in Ausdrücken werden nur noch für Doppeldereferenzen (double-derefs) bzw. dynamische Referenzen verwendet und lösen in ungerader Anzahl einen Syntaxfehler aus.</li>
<li>Methodenaufrufanweisungen (Methodenaufrufe ohne runde Klammern) sind beschränkt auf eine reine Variable, gefolgt von einem oder mehreren Identifikatoren, getrennt durch Punkte, z.B. <code>Var.Eigenschaft.Methode "Zeichenkette"</code>.</li>
</ul>
<p>Die Übersetzung von v1-Befehlen in Funktionen verlief in der Regel wie folgt (einige Funktionen wurden jedoch geändert, wie weiter unten dokumentiert):</p>
<ul>
<li>Wenn der erste Parameter des Befehls eine Ausgabevariable ist und der zweite Parameter nicht, wird der erste Parameter zum Rückgabewert gemacht und aus der Parameterliste entfernt.</li>
<li>Die übrigen Ausgabevariablen werden wie <a href="#byref">ByRef-Parameter</a> (deren Verwendung und Syntax sich geändert hat) behandelt, außer dass sie Referenzen erlauben, die auf beschreibbare interne Variablen verweisen.</li>
<li>Bei Misserfolg wird eine Ausnahme ausgelöst, anstatt ErrorLevel zu setzen.</li>
<li>Werte, die zuvor über ErrorLevel zurückgegeben wurden, werden nun auf andere Weise zurückgegeben, durch Ausnahmen ersetzt, überflüssig gemacht oder einfach nicht zurückgegeben.</li>
</ul>
<p>Alle Kontrollanweisungen akzeptieren auch Ausdrücke, außer wo unten angegeben.</p>
<p>Alle Kontrollanweisungen, die Parameter akzeptieren (außer Zwei-Wort-Schleifenanweisungen), unterstützen runde Klammern um ihre Parameterliste, ohne Leerzeichen zwischen dem Namen und der Klammer. Zum Beispiel <code>return(var)</code>. Dies sind jedoch keine Funktionen, z.B. ist <code>x := return(y)</code> ungültig. <a href="lib/If.htm">If</a> und <a href="lib/While.htm">While</a> unterstützen dies bereits.</p>
<p>Auf <a href="#loop-sub-commands">Loop</a> (außer <a href="lib/Loop.htm">Loop <em>Wiederholungen</em></a>) folgt nun ein sekundäres Schlüsselwort (Files, Parse, Read oder Reg), das weder in Anführungszeichen gesetzt noch in einer Variable enthalten sein darf. Derzeit kann hinter dem Schlüsselwort ein Komma stehen, was aber nicht erforderlich ist, da dies kein Parameter ist. <a href="lib/Block.htm#otb">OTB</a> wird bei allen Varianten unterstützt.</p>
<p><a href="lib/Goto.htm">Goto</a>, <a href="lib/Break.htm">Break</a> und <a href="lib/Continue.htm">Continue</a> benötigen einen anführungszeichenlosen Labelnamen, äquivalent zu v1 (<code>Goto Label</code> springt zu <code>Label:</code>). Um dynamisch zu einem Label zu springen, verwenden Sie runde Klammern direkt hinter dem Namen: <code>Goto(Ausdruck)</code>. Dies ist jedoch keine Funktion und kann nicht innerhalb eines Ausdrucks verwendet werden. Es können runde Klammern bei Break oder Continue verwendet werden, aber dann muss der Parameter eine direkt geschriebene Zahl oder eine in Anführungszeichen gesetzte Zeichenkette sein.</p>
<p>Gosub wurde entfernt, und Labels können nicht mehr mit Funktionen wie <a href="lib/SetTimer.htm">SetTimer</a> und <a href="lib/Hotkey.htm">Hotkey</a> verwendet werden.</p>
<ul>
<li>Labels sind redundant, da sie im Grunde nur eine eingeschränkte Variante einer Funktion sind, ohne lokale Variablen oder einen Rückgabewert und ohne einen eigenen, separaten Namensraum. Funktionen können überall dort verwendet werden, wo zuvor Label-Subroutinen verwendet wurden (auch <a href="Functions.htm#nested">innerhalb anderer Funktionen</a>).</li>
<li>Funktionen können sich nicht überlappen (können aber in einer anderen Funktion enthalten sein). Verwenden Sie stattdessen mehrere Funktionen und rufen Sie diese nacheinander auf. Statt A_ThisLabel können Funktionsparameter verwendet werden.</li>
<li>Im Gegensatz zu Subroutinen wird eine Fehlermeldung angezeigt, wenn man vergisst, das <em>Ende</em> einer Funktion zu definieren, da jedes <code>{</code> ein entsprechendes <code>}</code> haben muss. Die Grenzen einer Funktion sollten auch leichter zu erkennen sein als die einer Label-Subroutine.</li>
<li>Funktionen können im automatischen Ausführungsbereich platziert werden, ohne diesen zu unterbrechen. Der automatische Ausführungsbereich kann sich nun problemlos über das gesamte Skript erstrecken und ist somit eher <a href="Language.htm#global-code">globaler Code</a>, der innerhalb des <a href="Scripts.htm#auto">Auto-Execute-Threads</a> ausgeführt wird.</li>
<li>Funktionen sind etwas weniger anfällig dafür, als "Goto" missbraucht zu werden (wobei ein Benutzer die aktuelle Subroutine sich selbst ausführen lässt, um eine Schleife zu erzeugen, was unweigerlich zur Erschöpfung des Stapelplatzes und zur Terminierung des Programms führt).</li>
<li>Es gibt weniger Mehrdeutigkeit bei Funktionen (z.B. <a href="lib/Hotkey.htm">Hotkey</a>), die ein Label oder eine Funktion akzeptieren, wobei beide mit demselben Namen existieren können.</li>
<li>Bei allen anderen Verwendungen von Labels ist es nicht erlaubt, vom Inneren einer Funktion aus auf ein globales Label zu verweisen. Daher kann die Suche nach Labels auf die lokale Label-Liste beschränkt werden. Es besteht daher keine Notwendigkeit, auf ungültige Sprünge von innerhalb einer Funktion nach außerhalb zu prüfen (die ohnehin nie unterstützt wurden).</li>
</ul>
<h3 id="hotkey-and-hotstring-labels">Hotkey- und Hotstring-Labels</h3>
<p><a href="Hotkeys.htm">Hotkeys</a> und nicht-automatisch-ersetzende <a href="Hotstrings.htm">Hotstrings</a> sind keine Labels mehr, sondern definieren (automatisch) eine Funktion. Verwenden Sie geschweifte Klammern bei mehrzeiligen Hotkeys, um den Körper des Hotkeys zu umschließen, anstatt ihn mit <code>return</code> zu beenden (was durch die geschweifte Endklammer impliziert wird). Um einen Hotkey explizit aufrufen zu lassen, geben Sie <code>FunkName(ThisHotkey)</code> zwischen <code>::</code> und <code>{</code> an - dies ist auch in v1.1.20+ möglich, aber es gibt jetzt einen Parameter. Wenn die Funktionsdefinition nicht explizit ist, heißt der Parameter ThisHotkey.</p>
<p><strong>Hinweis:</strong> Hotkey-Funktionen sind standardmäßig <a href="Functions.htm#AssumeLocal">Assume-Local</a>-Funktionen und können daher <a href="Functions.htm#Global">globalen Variablen</a> nichts ohne Deklaration zuweisen.</p>
<h3 id="names">Namen</h3>
<p>Funktions- und Variablennamen befinden sich nun in einem gemeinsamen Namensraum.</p>
<ul>
<li>Jede Funktionsdefinition erstellt eine Konstante (schreibgeschützte Variable) innerhalb des aktuellen Gültigkeitsbereichs.</li>
<li>Verwenden Sie <code>MeineFunk</code> anstelle von <code>Func("MeineFunk")</code>.</li>
<li>Verwenden Sie <code>MeineFunk</code> anstelle von <code>"MeineFunk"</code>, um die Funktion an eine interne Funktion wie <a href="lib/SetTimer.htm">SetTimer</a> oder <a href="lib/Hotkey.htm">Hotkey</a> zu übergeben. Die Übergabe eines Namens (Zeichenkette) wird nicht mehr unterstützt.</li>
<li>Verwenden Sie <code>meineVar()</code> anstelle von <code>%meineVar%()</code>, um eine Funktion per Wert aufzurufen.</li>
<li>Um eine Funktion aufzurufen, von der Sie nur einen Funktionsnamen (Zeichenkette) haben, verwenden Sie zunächst eine <a href="Variables.htm#deref">Doppeldereferenz</a> (double-deref), um den Namen in eine Variable aufzulösen und deren Wert (das Funktionsobjekt) abzurufen. <code>%meineVar%()</code> führt nun eine Doppeldereferenzierung (double-deref) durch und ruft dann das Ergebnis auf, äquivalent zu <code>f := %meineVar%, f()</code>. Vermeiden Sie nach Möglichkeit die Adressierung von Funktionen über ihren Namen (Zeichenkette); verwenden Sie stattdessen Referenzen.</li>
</ul>
<p>Die Namen dürfen weder mit einer Ziffer beginnen noch die folgenden früher zulässigen Zeichen enthalten: <code>@ # $</code>. Nur Buchstaben, Zahlen, Unterstriche und ASCII-fremde Zeichen sind erlaubt.</p>
<p><strong>Reservierte Wörter:</strong> Deklarationsschlüsselwörter und Namen von Kontrollanweisungen dürfen nicht als Variablen-, Funktions- oder Klassennamen verwendet werden. Dazu gehören <code class="no-highlight">local</code>, <code class="no-highlight">global</code>, <code class="no-highlight">static</code>, <code class="no-highlight">if</code>, <code class="no-highlight">else</code>, <code class="no-highlight">loop</code>, <code class="no-highlight">for</code>, <code class="no-highlight">while</code>, <code class="no-highlight">until</code>, <code class="no-highlight">break</code>, <code class="no-highlight">continue</code>, <code class="no-highlight">goto</code>, <code class="no-highlight">return</code>, <code class="no-highlight">switch</code>, <code class="no-highlight">case</code>, <code class="no-highlight">try</code>, <code class="no-highlight">catch</code>, <code class="no-highlight">finally</code> und <code class="no-highlight">throw</code>. Dies dient in erster Linie der Fehlererkennung, z.B. <code>if (ex) break</code>.</p>
<p><strong>Reservierte Wörter:</strong> <code class="no-highlight">as</code>, <code class="no-highlight">and</code>, <code class="no-highlight">contains</code>, <code class="no-highlight">false</code>, <code class="no-highlight">in</code>, <code class="no-highlight">is</code>, <code class="no-highlight">IsSet</code>, <code class="no-highlight">not</code>, <code class="no-highlight">or</code>, <code class="no-highlight">super</code>, <code class="no-highlight">true</code>, <code class="no-highlight">unset</code>. Diese Wörter sind für zukünftige oder andere spezifische Zwecke reserviert und dürfen nicht als Variablen- oder Funktionsnamen verwendet werden. Dies dient in erster Linie der Konsistenz: In v1 war <code>and := 1</code> in einer eigenen Zeile erlaubt, aber <code>(and := 1)</code> hätte nicht funktioniert.</p>
<p>Die oben aufgelisteten Wörter können zur Benennung von Eigenschaften oder Fenstergruppen verwendet werden. Üblicherweise wird den Eigenschaftsnamen ein <code>.</code> vorangestellt, um zu verhindern, dass das Wort als Operator interpretiert wird. Schlüsselwörter hingegen werden innerhalb eines Ausdrucks nie als Variablen- oder Funktionsnamen interpretiert. Zum Beispiel ist <code>not(x)</code> äquivalent zu <code>not (x)</code> oder <code>(not x)</code>.</p>
<p>Einige Klassen sind vordefiniert, wodurch diese globalen Variablennamen auf die gleiche Weise reserviert sind wie bei einer benutzerdefinierten Klasse. (Die meisten Probleme, die sich daraus ergeben, werden jedoch durch die unten beschriebenen <a href="#scope">Änderungen am Gültigkeitsbereich</a> entschärft.) Eine Liste der Klassen finden Sie unter <a href="ObjList.htm">Interne Klassen</a>.</p>
<h3 id="scope">Gültigkeitsbereich</h3>
<p><em>Superglobale</em> Variablen wurden entfernt (außer interne Variablen, die nicht ganz dasselbe sind, da sie weder neu deklariert noch "überschrieben" werden können).</p>
<p>Wenn innerhalb einer <a href="Functions.htm#AssumeLocal">Assume-Local</a>-Funktion ein bestimmter Name nicht in einer Deklaration oder als Ziel einer nicht-dynamischen Zuweisung oder des <a href="Variables.htm#ref">Referenzoperators (&amp;)</a> verwendet wird, kann er in eine bestehende globale Variable aufgelöst werden.</p>
<p>Mit anderen Worten:</p>
<ul>
<li>Funktionen können nun globale Variablen lesen, ohne sie deklarieren zu müssen.</li>
<li>Funktionen, die keine globalen Deklarationen (<code>global</code>) haben, können globale Variablen nicht direkt ändern (dadurch wird eine Quelle für unbeabsichtigte Seiteneffekte eliminiert).</li>
<li>Das Hinzufügen einer neuen Klasse (<code>class</code>) wird das Verhalten einer bestehenden Funktion viel weniger beeinflussen, da Klassen nicht superglobal sind.</li>
<li>Das Schlüsselwort <code>global</code> ist derzeit redundant, wenn es im globalen Bereich verwendet wird, kann aber zwecks Übersicht weiterhin angegeben werden. Variablen, die auf diese Weise deklariert werden, sind nun viel weniger anfällig für Konflikte mit lokalen Variablen (z.B. beim Kombinieren von Skripten, egal ob manuell oder mit <a href="lib/_Include.htm">#Include</a>), da sie nicht superglobal sind. Andererseits geht etwas Komfort verloren.</li>
<li>Deklarationen werden in der Regel nicht so oft benötigt.</li>
</ul>
<p>Der <em>Force-Local</em>-Modus wurde entfernt.</p>
<h3 id="variables">Variablen</h3>
<p>Lokale <a href="Functions.htm#static">statische</a> Variablen werden initialisiert, wenn und sobald sie von der Ausführung erreicht werden, nicht mehr in linearer Reihenfolge vor Beginn des automatischen Ausführungsbereichs. Jeder Initialisierer, der zum zweiten Mal erreicht wird, hat keinen Effekt mehr. Mehrere Deklarationen sind erlaubt und können für dieselbe Variable zu unterschiedlichen Zeitpunkten ausgeführt werden. Dies hat mehrere Vorteile:</p>
<ul>
<li>Wenn ein statischer Initialisierer andere Funktionen mit statischen Variablen aufruft, besteht ein geringeres Risiko, dass Initialisierer aufgrund der Reihenfolge der Funktionsdefinitionen noch nicht ausgeführt wurden.</li>
<li>Da die Funktion aufgerufen wurde, stehen Parameter, <a href="Variables.htm#ThisFunc">A_ThisFunc</a> und <a href="Functions.htm#closures">Closures</a> zur Verfügung (vorher waren sie es nicht).</li>
<li>Eine statische Variable kann bedingt initialisiert werden, was die Flexibilität erhöht, aber dennoch nur einmal ausgeführt wird, ohne dass <code>if IsSet()</code> benötigt wird.</li>
<li>Da es mehrere Initialisierer für eine einzelne statische Variable geben kann, sind Verbundzuweisungen wie <code>static x += 1</code> zulässig. (Diese Änderung reduzierte die Codegröße nur geringfügig, da dies bereits bei <code>local</code> und <code>global</code> erlaubt war.)</li>
</ul>
<p class="note"><strong>Hinweis:</strong> <code>static init := MeineFunk()</code> kann nicht mehr verwendet werden, um <em>MeineFunk</em> automatisch auszuführen. Da jedoch Label-und-Return-basierte Subroutinen nun vollständig vermieden werden können, kann sich der automatische Ausführungsbereich über das gesamte Skript erstrecken.</p>
<p>Das Deklarieren einer Variable mit <code>local</code> macht die Funktion nicht mehr zu einer <a href="Functions.htm#AssumeGlobal">Assume-Global</a>-Funktion.</p>
<p><a href="Variables.htm#deref">Doppeldereferenzen</a> (double-derefs) sind nun konsistenter mit Variablen, die beim Laden des Skripts aufgelöst werden, und können keine neuen Variablen mehr erzeugen. Dadurch werden einige Inkonsistenzen und häufige Anlässe zu Verwirrung vermieden.</p>
<p>Doppeldereferenzen (double-derefs), die aus irgendeinem Grund fehlschlagen, lösen jetzt einen Fehler aus. Früher wurde bei ungültigen Namen stillschweigend eine leere Zeichenkette erzeugt, während in anderen Fällen eine leere Variable erstellt und zurückgegeben wurde.</p>
<h3 id="expressions">Ausdrücke (Expressions)</h3>
<p>Direkt geschriebene Zeichenketten können in <code>"doppelten"</code> oder <code>'einfachen'</code> Anführungszeichen gesetzt werden, müssen aber mit demselben Zeichen beginnen und enden. Direkt geschriebene Anführungszeichen müssen mit einem Escapezeichen versehen werden - <code>`"</code> oder <code>`'</code> - oder mit dem gegenteiligen Anführungszeichen ersetzt werden:  <code>'"42" ist die Antwort'</code>. Zwei aufeinanderfolgende Anführungszeichen haben keine besondere Bedeutung und lösen einen Fehler aus, da eine Auto-Verkettung ein Leerzeichen benötigt.</p>
<p>Die Operatoren <code>&amp;&amp;</code>, <code>||</code>, <code>and</code> und <code>or</code> geben, ähnlich wie JavaScript und Lua, den gewinnenden Wert zurück. Zum Beispiel bewirkt <code>"" or "Standard"</code> die Rückgabe von "Standard" statt 1. Skripte, die einen reinen booleschen Wert (0 oder 1) benötigen, können so etwas wie <code>!!(x or y)</code> oder <code>(x or y) ? 1 : 0</code> verwenden.</p>
<p>Auto-Verkettungen benötigen nun mindestens ein Leer- oder Tabulatorzeichen (in der v1-Dokumentation hieß es "sollte" ein Leerzeichen sein).</p>
<p>Das Ergebnis eines Mehrfachanweisungsausdrucks wie <code>x(), y()</code> ist der letzte (ganz rechts befindliche) Teilausdruck, anstatt der erste (ganz links). In v1 und v2 werden Teilausdrücke von links nach rechts ausgewertet.</p>
<p>Gleichheitszeichen nach einem Komma sind nicht länger Zuweisungen: <code>y=z</code> in <code>x:=y, y=z</code> wäre keine Zuweisung, sondern ein unwirksamer Vergleich.</p>
<p><code>:=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>++</code> und <code>--</code> verhalten sich konsistent, egal ob sie allein oder in Kombination mit anderen Operatoren verwendet werden, wie z.B. bei <code>x := y, y += 2</code>. Früher gab es Unterschiede im Verhalten, wenn ein Fehler im Ausdruck auftrat oder ein leerer Wert in einer mathematischen Operation verwendet wurde.</p>
<p><code>!=</code> ist nun wie <code>=</code> immer nicht-Groß-/Kleinschreibung-sensitiv, während <code>!==</code> als Gegenstück zu <code>==</code> hinzugefügt wurde.</p>
<p><code>&lt;&gt;</code> wurde entfernt.</p>
<p><code>//</code> löst nun eine Ausnahme aus, wenn einer der Eingabewerte eine Floating-Point-Zahl ist. Früher waren die Ergebnisse zwischen negativen Floating-Point-Zahlen und negativen Integern inkonsistent.</p>
<p><code>|</code>, <code>^</code>, <code>&amp;</code>, <code>&lt;&lt;</code> und <code>&gt;&gt;</code> lösen nun eine Ausnahme aus, wenn einer ihrer Eingabewerte eine Floating-Point-Zahl ist, anstatt das Ergebnis auf einen Integer zu kürzen.</p>
<p>Die wissenschaftliche Schreibweise kann ohne Dezimalpunkt verwendet werden (erzeugt aber immer eine Floating-Point-Zahl). Die wissenschaftliche Schreibweise wird auch unterstützt, wenn numerische Zeichenketten in Integer umgewandelt werden (z.B. wird <code>"1e3"</code> als 1000 statt 1 interpretiert).</p>
<p>Funktionsaufrufe können jetzt praktisch mit jedem Teilausdruck angegeben werden, welche Funktion aufgerufen werden soll, solange vor der runden Startklammer der Parameterliste kein Leer- oder Tabulatorzeichen steht. Zum Beispiel würde <code>MeineFunk()</code> den Wert von <em>MeineFunk</em> aufrufen, egal ob es der tatsächliche Name einer Funktion oder eine Variable mit einem Funktionsobjekt ist, und <code>(a?b:c)()</code> würde je nach <em>a</em> entweder <em>b</em> oder <em>c</em> aufrufen. Beachten Sie, dass <code>x.y()</code> immer noch ein Methodenaufruf ist, ähnlich zu <code>(x.y)(x)</code>, aber <code>a[i]()</code> ist jetzt äquivalent zu <code>(a[i])()</code>.</p>
<p>Doppeldereferenzen (double-derefs) erlauben nun fast jeden Ausdruck (nicht nur Variablen) als Quelle für den Variablennamen. Zum Beispiel sind <code>DoNotUseArray%n+1%</code> und <code>%(%triple%)%</code> gültig. Die Syntax für Doppeldereferenzierung (double-deref) wird nun auch für die Dereferenzierung von VarRefs verwendet, z.B. <code>ref := &amp;var, value := %ref%</code>.</p>
<p>Die Ausdrücke <code>funkName[""]()</code> und <code>funkName.()</code> rufen nicht länger eine Funktion via Name auf. Das Weglassen des Methodennamens wie in <code>.()</code> verursacht nun eine Ladezeitfehlermeldung. Funktionen sollten per Referenz aufgerufen oder adressiert werden, nicht per Name.</p>
<p><code>var :=</code> löst einen Ladezeitfehler aus. In v1 war dies äquivalent zu <code>var := ""</code>, scheiterte aber stillschweigend in Kombination mit einem anderen Ausdruck, z.B. <code>x :=, y :=</code>.</p>
<p>Direkt geschriebene Zeichenketten gefolgt von einem mehrdeutigen unären/binären Operator lösen einen Ladezeitfehler aus. Wenn man z.B. mit <code>"Neuer Zähler:" ++Zähler</code> versuchen will, <em>Zähler</em> um 1 zu erhöhen und anzuzeigen, wird eine Fehlermeldung angezeigt, da es technisch gesehen eine ungültige Addition und ein unäres Plus ist.</p>
<p><code>Wort ++</code> und <code>Wort --</code> sind keine Ausdrücke mehr, da <code>Wort</code> eine benutzerdefinierte Funktion sein kann (und nach ++/-- kann ein Ausdruck folgen, der eine Variablenreferenz erzeugt). Um einen alleinstehenden Post-Inkrement- oder Post-Dekrement-Ausdruck zu schreiben, muss entweder das Leerzeichen zwischen der Variable und dem Operator weggelassen oder die Variable oder der Ausdruck in runden Klammern gesetzt werden.</p>
<p><code>Wort ? x : y</code> ist immer noch ein ternärer Ausdruck, aber bei komplexeren Fällen, die mit einem Wort beginnen, z.B. <code>Wort1 Wort2 ? x : y</code>, wird <em>Wort1</em> immer als Funktionsaufruf interpretiert (auch wenn eine solche Funktion nicht existiert). Um einen alleinstehenden ternären Ausdruck mit einer komplexen Bedingung zu schreiben, umschließen Sie die Bedingung mit runden Klammern.</p>
<p>Mit dem neuen <a href="Variables.htm#is"><code>is</code>-Operator</a> wie in <code>x is y</code> kann geprüft werden, ob der Wert <em>x</em> eine Instanz der Klasse <em>y</em> ist, wobei <em>y</em> ein Objekt mit einer <em>Prototype</em>-Eigenschaft (also eine <a href="lib/Class.htm">Klasse</a>) sein muss. Dies schließt auch primitive Werte wie in <code>x is Integer</code> ein (was eine reine Typprüfung ist, während <code>IsInteger(x)</code> auf eine mögliche Umwandlung prüft).</p>
<p>Die Schlüsselwörter <code>contains</code> und <code>in</code> sind für zukünftige Zwecke reserviert.</p>
<p><code>&amp;var</code> (Adressoperator) wurde durch <code>StrPtr(var)</code> und <code>ObjPtr(obj)</code> ersetzt, um die Intention zu verdeutlichen und die Fehlerprüfung zu verbessern. In v1 gab der Adressoperator die Adresse des internen Zeichenkettenpuffers von <em>var</em> zurück, auch dann, wenn dieser eine Zahl (aber kein Objekt) enthielt. Der Operator wurde auch verwendet, um die Adresse eines Objekts abzurufen. Das Abrufen einer Adresse falschen Typs kann schlimme Folgen haben.</p>
<p><code>&amp;var</code> ist nun der <a href="Variables.htm#ref">Referenzoperator</a>, der für alle <a href="#byref">ByRef</a>- und AusgabeVar-Parameter verwendet wird, um die Übersichtlichkeit und Flexibilität zu verbessern (und weitere Sprachänderungen zu ermöglichen). Weitere Informationen finden Sie unter <a href="Concepts.htm#variable-references">Variablenreferenzen (VarRef)</a>.</p>
<p>Die Länge der Zeichenkette wird nun während der Ausdrucksauswertung im Cache zwischengespeichert. Dies verbessert die Performanz und erlaubt binäre Nullen in Zeichenketten. Genauer gesagt:</p>
<ul>
<li>Die Verkettung von zwei Zeichenketten, von denen eine oder beide eine binäre Null enthalten, führt nicht mehr zur Kürzung der Daten.</li>
<li>Mit den Groß-/Kleinschreibung-sensitiven Gleichheitsoperatoren (<code>==</code> und <code>!==</code>) können Binärdaten verglichen werden. Die anderen Vergleichsoperatoren können nur bis zur ersten binären Null "sehen".</li>
<li>Binärdaten können von Funktionen zurückgegeben und in Objekten gespeichert werden.</li>
</ul>
<p>Die meisten Funktionen erwarten immer noch nullterminierte Zeichenketten, d.h. sie können nur bis zur ersten binären Null "sehen". Zum Beispiel würde <a href="lib/MsgBox.htm">MsgBox</a> nur den Teil der Zeichenkette vor der ersten binären Null anzeigen.</p>
<p>Der <code>*</code>-Operator (Dereferenz) wurde entfernt. Verwenden Sie stattdessen <a href="lib/NumGet.htm">NumGet</a>.</p>
<p>Der <code>~</code>-Operator (<a href="Variables.htm#unary">bitweises NICHT</a>) behandelt seinen Eingabewert nun immer als vorzeichenfähigen 64-Bit-Integer, d.h. er behandelt Werte zwischen 0 und 4294967295 nicht mehr als vorzeichenlose 32-Bit-Integer.</p>
<p><code>&gt;&gt;&gt;</code> und <code>&gt;&gt;&gt;=</code> für logische bitweise Verschiebung nach rechts wurden hinzugefügt.</p>
<p><a href="Variables.htm#fat-arrow">Fat-Arrow-Funktionen</a> wurden hinzugefügt. Der Ausdruck <code>Fn(Parameter) =&gt; Ausdruck</code> definiert eine Funktion namens <em>Fn</em> (was weggelassen werden kann) und gibt ein <a href="lib/Func.htm">Func-Objekt</a> oder <a href="Functions.htm#closures">Closure-Objekt</a> zurück. Bei Aufruf wertet die Funktion <em>Ausdruck</em> aus und gibt das Ergebnis zurück. Wenn dies in einer anderen Funktion verwendet wird, kann <em>Ausdruck</em> auf die Variablen der äußeren Funktion verweisen (was auch mit einer normalen Funktionsdefinition erreicht werden kann).</p>
<p>Die Fat-Arrow-Syntax kann auch verwendet werden, um Methoden und Eigenschafts-Getter/Setter zu definieren (in diesem Fall ist die Methoden-/Eigenschaftsdefinition selbst kein Ausdruck, sondern ihr Körper gibt einfach einen Ausdruck zurück).</p>
<p>Direkt geschriebene Zahlen werden nun auf der linken Seite des Objektelementzugriffs (Punkt) vollständig unterstützt. Zum Beispiel ist <code>0.1</code> eine Zahl, aber <code class="no-highlight">0.min</code> und <code class="no-highlight">0.1.min</code> greifen auf die <em>min</em>-Eigenschaft zu, die von einem Basisobjekt behandelt werden kann (siehe <a href="Objects.htm#primitive">Primitive Werte</a>). <code class="no-highlight">1..2</code> oder <code class="no-highlight">1.0.2</code> ist die Zahl 1.0, gefolgt von der Eigenschaft 2. Dies kann z.B. für Maßeinheiten, direkt geschriebene Versionsnummern oder Zahlenbereiche verwendet werden.</p>
<p><code>x**y</code>: Wenn <em>x</em> und <em>y</em> Integer sind und <em>y</em> positiv ist, liefert der Potenzoperator nun korrekte Ergebnisse für alle Eingabewerte, sofern im gültigen Bereich, während früher durch die interne Floating-Point-Berechnung eine gewisse Genauigkeit verloren ging. Das Verhalten bei Überlauf ist undefiniert.</p>
<h3 id="objects-misc">Objekte (Sonstiges)</h3>
<p>Siehe auch: <a href="#objects">Objekte</a></p>
<p>Der Zugriff auf Eigenschaften via <code>.</code> und der Zugriff auf Daten (Array- oder Map-Elemente) via <code>[]</code> werden nun getrennt voneinander behandelt. Zum Beispiel kann <code>dictionary["Count"]</code> die Definition von "Count" zurückgeben, während <code>dictionary.Count</code> die Anzahl der darin enthaltenen Wörter zurückgibt. Benutzerdefinierte Objekte können dies durch Definieren einer <a href="Objects.htm#__Item">__Item-Eigenschaft</a> nutzen.</p>
<p>Wenn der Name einer Eigenschaft oder Methode nicht im Voraus bekannt ist, können (und müssen) Prozentzeichen verwendet werden, um auf sie zuzugreifen. Zum Beispiel ist <code>obj.%varname%()</code> das v2-Äquivalent von <code>obj[varname]()</code>. Die Verwendung von <code>[]</code> ist für Daten (z.B. Array-Elemente) reserviert.</p>
<p>Die direkte Schreibweise zum Konstruieren eines Ad-hoc-Objekts ist nach wie vor <code>{Name: Wert}</code>, aber da reine Objekte jetzt nur noch "Eigenschaften" und keine "Array-Elemente" mehr haben, wurden die Regeln leicht geändert, um konsistent mit der Art und Weise zu sein, wie alle anderen Zugriffe auf Eigenschaften erfolgen:</p>
<ul>
<li><code>o := {a: b}</code> verwendet wie zuvor den Namen "a".</li>
<li><code>o := {%a%: b}</code> verwendet den Eigenschaftsnamen in <em>a</em>, anstatt diesen als Variablennamen zu nehmen, eine Doppeldereferenzierung (double-deref) durchzuführen und den Inhalt der resultierenden Variable zu verwenden. Mit anderen Worten, es hat denselben Effekt wie <code>o := {}, o.%a% := b</code>.</li>
<li>Jede andere Art von Ausdruck links von <code>:</code> ist unzulässig. Zum Beispiel <code>{(a): b}</code> oder <code>{ein Fehler: 1}</code>.</li>
</ul>
<p>Die Verwendung des Wortes "base" in <code>base.Methode()</code> wurde mit <a href="Objects.htm#Custom_Classes_super">super</a> ersetzt (<code>super.Methode()</code>), um die beiden Konzepte besser zu unterscheiden:</p>
<ul>
<li><code>super.</code> oder <code>super[</code> ruft die Superklassenversion einer Methode/Eigenschaft auf, wobei "Superklasse" die Basis des Prototypobjekts ist, das ursprünglich zur Definition der aktuellen Funktion gehörte.</li>
<li><code>super</code> ist ein reserviertes Wort; der Versuch, es ohne das Suffix <code>.</code> oder <code>[</code> oder <code>(</code> oder außerhalb einer Klasse zu verwenden, führt zu einem Ladezeitfehler.</li>
<li><code>base</code> ist eine vordefinierte Eigenschaft, die das unmittelbare Basisobjekt des Objekts abruft oder setzt (wie <a href="lib/Any.htm#GetBase">ObjGetBase</a>/<a href="lib/Object.htm#SetBase">ObjSetBase</a>). Es ist nur ein normaler, nicht reservierter Eigenschaftsname.</li>
<li>Der indirekte Aufruf von <code>super.x</code> löst einen Fehler aus, wenn die Superklasse keine Definition von x hat, während <code>base.x</code> früher ignoriert wurde (auch wenn es eine Zuweisung war).</li>
</ul>
<p>Der Aufruf eines benutzerdefinierten Objekts ohne explizite Angabe eines Methodennamens bewirkt nun den Aufruf der "Call"-Methode anstelle der ""-Methode. Zum Beispiel bewirkte <code>%Fn%()</code> früher den Aufruf von <code>Fn.()</code>, während der v2-Ausdruck <code>Fn()</code> den Aufruf von <code>Fn.Call()</code> bewirkt. <a href="lib/Func.htm">Func</a>-Objekte implementieren nicht mehr die namenlose Methode. Es ist nicht mehr zulässig, den Methodennamen in einem Methodenaufruf wegzulassen, aber <code>Fn.%""%()</code> funktioniert anstelle von <code>Fn.()</code>.</p>
<p><code>this.Method()</code> ruft <code>Fn.Call(this)</code> (wobei <em>Fn</em> das Funktionsobjekt ist, das die Methode implementiert) statt <code>Fn[this]()</code> auf (was in v1 zu einem Aufruf von <code>Fn.__Call(this)</code> führen würde, es sei denn, <code>Fn[this]</code> enthält eine Funktion). Funktionsobjekte sollten eine <em>Call</em>-Methode implementieren, nicht <em>__Call</em>, das nur für explizite Methodenaufrufe vorgesehen ist.</p>
<p><code><i>Klassenname</i>()</code> (ehemals <code>new <i>Klassenname</i>()</code>) scheitert nun bei der Erstellung des Objekts, wenn die <em>__New</em>-Methode definiert ist, aber nicht aufgerufen werden konnte (z.B. weil die Parameteranzahl falsch ist), oder wenn Parameter übergeben wurden, aber <em>__New</em> nicht definiert ist.</p>
<p>Objekte, die innerhalb eines Ausdrucks erstellt oder von einer Funktion zurückgegeben werden, werden nun zurückgehalten, bis die Auswertung des Ausdrucks abgeschlossen ist, und dann freigegeben. Dies verbessert die Performanz geringfügig und ermöglicht die Verwendung temporärer Objekte für die Speicherverwaltung innerhalb eines Ausdrucks, ohne zu befürchten, dass die Objekte vorzeitig freigegeben werden.</p>
<p>Objekte können Zeichenkettenwerte (aber keine Schlüssel) mit binären Nullen enthalten. Beim Klonen eines Objekts werden Binärdaten in Zeichenketten beibehalten, bis zur gespeicherten Länge der Zeichenkette (nicht ihre Kapazität). Früher wurden Daten über die Länge des Wertes hinaus geschrieben, wenn es um Binärdaten oder Strukturen ging; jetzt sollte stattdessen ein <a href="lib/Buffer.htm">Buffer-Objekt</a> verwendet werden.</p>
<p>Zuweisungsausdrücke wie <code>x.y := z</code> liefern nun immer den Wert von <em>z</em>, egal wie <em>x.y</em> implementiert wurde. Der Rückgabewert eines Eigenschafts-Setters wird nun ignoriert. Früher:</p>
<ul>
<li>Einige interne Objekte gaben <em>z</em> zurück, andere gaben <em>x.y</em> zurück (z.B. <code>c := GuiObj.BackColor := "red"</code>, das <em>c</em> auf 0xFF0000 gesetzt hat), und wieder andere gaben einen falschen Wert zurück.</li>
<li>Benutzerdefinierte Eigenschafts-Setter konnten unerwartete Werte oder gar nichts zurückgeben.</li>
</ul>
<p><code>x.y(z) := v</code> ist nun ein Syntaxfehler. Früher war dies äquivalent zu <code>x.y[z] := v</code>. Grundsätzlich sind <code>x.y(z)</code> (Methodenaufruf) und <code>x.y[z]</code> (parametrisierte Eigenschaft) zwei verschiedene Operationen, werden aber als äquivalent betrachtet, wenn <em>x</em> ein COM-Objekt ist (aufgrund von Einschränkungen der COM-Schnittstelle).</p>
<p>Die Verkettung eines Objekts mit einem anderen Wert oder dessen Übergabe an <a href="lib/Loop.htm">Loop</a> wird derzeit als Fehler behandelt, während das Objekt früher als leere Zeichenkette behandelt wurde. Dies kann durch impliziten Aufruf von <code>.ToString()</code> geändert werden. Verwenden Sie <code>String(x)</code>, um einen Wert in eine Zeichenkette umzuwandeln; dies ruft <code>.ToString()</code> auf, wenn <em>x</em> ein Objekt ist.</p>
<p>Beim Aufruf eines Objekts via IDispatch (die COM-Schnittstelle) führen unbehandelte Ausnahmen, die nicht an den Aufrufer zurückgegeben werden können, zu einem Fehlerdialogfenster. (Der Aufrufer kann nach Belieben ein zusätzliches Fehlerdialogfenster ohne spezifische Details anzeigen.) Dies gilt auch für den Aufruf von Ereignishandlern durch Verwendung von <a href="lib/ComObjConnect.htm">ComObjConnect</a>.</p>
<h3 id="functions">Funktionen</h3>
<p>Funktionen können nicht mehr dynamisch mit mehr Parametern als formal möglich aufgerufen werden.</p>
<p><a href="Functions.htm#Variadic">Variadische Funktionen</a> sind von der obigen Einschränkung nicht betroffen, erstellen aber normalerweise bei jedem Aufruf ein Array, das die überschüssigen Parameter enthält. Wenn dieses Array nicht benötigt wird, kann der Parametername nun weggelassen werden, um seine Erstellung zu verhindern:</p>
<pre>AkzeptiertEinOderMehrArgs(erster, *) {
  ...
}
</pre>
<p>Dies kann für Rückruffunktionen verwendet werden, wo die zusätzlichen Parameter nicht benötigt werden.</p>
<p><a href="Functions.htm#VariadicCall">Variadische Funktionsaufrufe</a> erlauben nun die Verwendung eines enumerierbaren Objekts in Situationen, wo früher ein Standardobjekt mit sequentiellen numerischen Schlüsseln erforderlich war. Wenn der Enumerator mehr als einen Wert pro Wiederholung zurückgibt, wird nur der erste Wert verwendet. Zum Beispiel erstellt <code>Array(mymap*)</code> ein Array, das die Schlüssel von <em>mymap</em> enthält.</p>
<p>Variadische Funktionsaufrufe hatten früher nur eine halbherzige Unterstützung für benannte Parameter. Dies wurde deaktiviert, um ein mögliches Hindernis für die ordnungsgemäße Implementierung von benannten Parametern zu beseitigen.</p>
<p>Benutzerdefinierte Funktionen können das neue Schlüsselwort <code>unset</code> als Standardwert eines Parameters verwenden, um den Parameter "ungesetzt" zu machen, wenn kein Wert bereitgestellt wurde. Die Funktion kann dann IsSet() verwenden, um festzustellen, ob ein Wert bereitgestellt wurde. <code>unset</code> ist derzeit in keinem anderen Kontext erlaubt.</p>
<p>Skripte werden nicht mehr automatisch aus den Funktionsbibliotheksordnern (Lib) inkludiert, wenn ein Funktionsaufruf ohne Definition vorhanden ist, wegen der erhöhten Komplexität und der Gefahr von Unfällen (jetzt, da das <em>MeineFunk</em> in <code>MeineFunk()</code> eine beliebige Variable sein kann). <code>#Include &lt;BiblName&gt;</code> funktioniert wie früher. Möglicherweise wird dies in einer zukünftigen Version durch Modulunterstützung ersetzt.</p>
<p>Variadische interne Funktionen haben jetzt einen <em>MaxParams</em>-Wert äquivalent zu <em>MinParams</em>, anstatt einer willkürlichen Zahl (wie 255 oder 10000). Verwenden Sie die <em>IsVariadic</em>-Eigenschaft, um festzustellen, ob es keine Obergrenze gibt.</p>
<h4 id="byref">ByRef</h4>
<p><a href="Functions.htm#ByRef">ByRef-Parameter</a> werden jetzt nicht mehr mit <code>ByRef param</code>, sondern mit <code>&amp;param</code> deklariert, mit einigen Unterschieden in der Verwendung.</p>
<p>ByRef-Parameter nehmen nicht mehr implizit eine Referenz, die auf die Variable des Aufrufers verweist. Stattdessen muss der Aufrufer explizit eine Referenz mit dem <a href="Variables.htm#ref">Referenzoperator</a> (<code>&amp;var</code>) übergeben. Dies erlaubt mehr Flexibilität, z.B. Referenzen woanders zu speichern, sie mit einer variadischen Funktion zu akzeptieren und sie mit einem variadischen Aufruf weiterzugeben.</p>
<p>Wenn ein Parameter als ByRef markiert ist, löst jeder Versuch, explizit einen Nicht-VarRef-Wert zu übergeben, einen Fehler aus. Andernfalls kann die Funktion erstens mit <code>param is VarRef</code> prüfen, ob eine Referenz vorliegt, zweitens mit <code>IsSetRef(param)</code> prüfen, ob die Zielvariable einen Wert hat, und drittens diese mit <code>%param%</code> explizit dereferenzieren.</p>
<p>ByRef-Parameter können nun eine Referenz erhalten, die auf eine lokale Variable aus einer vorherigen Instanz der gleichen Funktion verweist, wenn diese rekursiv aufgerufen wird.</p>
<h3 id="nested-functions">Verschachtelte Funktionen</h3>
<p>Eine Funktion kann innerhalb einer anderen Funktion definiert werden. Eine verschachtelte Funktion kann automatisch nicht-statische lokale Variablen von der äußeren Funktion "abfangen" (unter den richtigen Bedingungen), wodurch diese nach Abschluss der äußeren Funktion verwendet werden können.</p>
<p>Der neue Fat-Arrow-Operator <code>=&gt;</code> kann auch verwendet werden, um verschachtelte Funktionen zu erstellen.</p>
<p>Alle Details finden Sie unter <a href="Functions.htm#nested">Verschachtelte Funktionen</a>.</p>
<h3 id="uncategorized">Sonstiges</h3>
<p>Bei der Initialisierung einer deklarierten Variable oder eines optionalen Parameters muss <code>:=</code> statt <code>=</code> verwendet werden.</p>
<p><code>return %var%</code> bewirkt nun eine Doppeldereferenzierung (double-deref); früher war es äquivalent zu <code>return var</code>.</p>
<p><a href="lib/_Include.htm">#Include</a> ist standardmäßig relativ zum Verzeichnis, das die aktuelle Datei enthält. Der Parameter dieser Direktive kann nun optional in Anführungszeichen gesetzt werden.</p>
<p>Der Parameter von <a href="lib/_ErrorStdOut.htm">#ErrorStdOut</a> kann nun optional in Anführungszeichen gesetzt werden.</p>
<p>Labelnamen dürfen nun nur noch aus Buchstaben, Ziffern, Unterstrichen und ASCII-fremden Zeichen bestehen (dasselbe gilt für Variablen, Funktionen und so weiter).</p>
<p>Labels innerhalb einer Funktion werden lokal behandelt, d.h. sie sind nur innerhalb dieser Funktion "sichtbar" und stehen nicht in Konflikt mit anderen Labels außerhalb der Funktion. Es ist nicht möglich, lokale Labels extern aufzurufen (auch nicht via interne Funktionen). Stattdessen können verschachtelte Funktionen verwendet werden, die die volle Nutzung lokaler Variablen erlauben.</p>
<p><code>for k, v in obj</code>:</p>
<ul>
<li>Es wurde geändert, wie das Objekt indirekt aufgerufen wird. Siehe <a href="#enumeration">Enumeration</a> weiter unten.</li>
<li><em>k</em> und <em>v</em> werden nun auf die Werte zurückgesetzt, die sie vor Beginn der Schleife hatten, nachdem die Schleife unterbrochen oder beendet wurde.</li>
<li>Es wird eine Ausnahme ausgelöst, wenn <em>obj</em> kein Objekt ist oder es ein Problem beim Abrufen oder Aufrufen des Enumerators gibt.</li>
<li>Es können bis zu 19 Variablen verwendet werden.</li>
<li>Variablen können weggelassen werden.</li>
</ul>
<p>Ein Komma mit einem Escapezeichen zu versehen, ist nicht mehr wichtig. Wenn <code>`,</code> früher in einem Ausdruck innerhalb eines Befehlsparameters ohne runde Klammern verwendet wurde, wurde das Komma als Mehrfachanweisungsoperator interpretiert, nicht als Parametertrennung. Dies funktionierte nur bei Befehlen, nicht bei Funktionen oder Variablendeklarationen.</p>
<p>Die Escapesequenz <code>`s</code> ist jetzt überall erlaubt, wo <code>`t</code> unterstützt wird. Früher war sie nur bei #IfWin und (Join erlaubt.</p>
<p><code>*/</code> kann nun am Ende einer Zeile stehen, um einen mehrzeiligen Kommentar zu schließen, wodurch eine häufige Verwechslung bezüglich der Funktionsweise von <code>/* */</code> in anderen Sprachen behoben wird. Wegen der Gefahr von Mehrdeutigkeit (z.B. bei einem Hotstring, der auf <code>*/</code> endet) wird ein <code>*/</code>, dem kein <code>/*</code> vorangestellt ist, nicht mehr ignoriert (eine Änderung in AHK_L Revision 54 wurde rückgängig gemacht).</p>
<p>Integerkonstanten und numerische Zeichenketten außerhalb des unterstützten Bereichs (von vorzeichenbehafteten 64-Bit-Integern) werden nun überlaufen/umgekehrt, anstatt auf den Minimal-/Maximalwert begrenzt zu werden. Dies ist konsistent mit mathematischen Operatoren, daher ist <code>9223372036854775807+1 == 9223372036854775808</code> (aber beide erzeugen -9223372036854775808). Dies ermöglicht bitweise Operationen mit 64-Bit-Werten.</p>
<p>Bei numerischen Zeichenketten gibt es weniger Fälle, wo andere Leerraumzeichen als Leer- und Tabulatorzeichen der Zahl vorangestellt werden dürfen. In der Regel (sowohl in v1 als auch in v2) sind nur Leer- und Tabulatorzeichen erlaubt, aber in einigen Fällen werden andere Leerraumzeichen zugunsten von C-Laufzeitbibliothek-Konventionen toleriert.</p>
<p><a href="lib/Else.htm">Else</a> kann nun zusammen mit <a href="Language.htm#loop-statement">Schleifen beliebigen Typs</a> und <a href="lib/Catch.htm">Catch</a> verwendet werden. Bei Schleifen wird es ausgeführt, wenn die Schleife null Wiederholungen hatte. Bei <em>Catch</em> wird es ausgeführt, wenn innerhalb von <em>Try</em> keine Ausnahme ausgelöst wird (und nicht ausgeführt, wenn ein Fehler oder ein Wert ausgelöst wird, auch wenn es kein <em>Catch</em> gibt, das der Klasse des Wertes entspricht). Folglich kann die Interpretation von <em>Else</em> abweichen, wenn es ohne geschweifte Klammern verwendet wird. Zum Beispiel:</p>
<pre>if Bedingung
{
    while Bedingung
        <em>; Pro Wiederholung auszuführende Anweisung</em>
} <em>; Diese Klammern sind jetzt erforderlich, sonst assoziiert Else mit While</em>
else
    <em>; Auszuführende Anweisung, wenn Bedingung False ist</em>
</pre>
<h3 id="continuation-sections">Fortsetzungsbereiche</h3>
<p>Smartes LTrim: Standardmäßig werden alle Leer- oder Tabulatorzeichen am Anfang der ersten Zeile unter den Fortsetzungsbereichsoptionen gezählt und dann diese Anzahl von Leer- oder Tabulatorzeichen aus jeder nachfolgenden Zeile entfernt. Wenn die erste Zeile eine Mischung aus Leer- und Tabulatorzeichen enthält, wird nur der erste Zeichentyp als Einrückung behandelt. Wenn eine Zeile weniger eingerückt ist als die erste Zeile oder mit den falschen Zeichen eingerückt ist, bleiben alle Leerraumzeichen am Anfang dieser Zeile erhalten.</p>
<p>Anführungszeichen werden automatisch mit einem Escapezeichen versehen (also als direkt geschriebene Zeichen interpretiert), wenn der Fortsetzungsbereich innerhalb einer in Anführungszeichen gesetzten Zeichenkette beginnt. Dadurch wird verhindert, dass Anführungszeichen in mehrzeiligen Zeichenketten mit einem Escapezeichen versehen werden müssen (wenn das beginnende und endende Anführungszeichen außerhalb des Fortsetzungsbereichs liegen), während mehrzeilige Ausdrücke immer noch in Anführungszeichen gesetzte Zeichenketten enthalten können.</p>
<p>Wenn die Zeile über dem Fortsetzungsbereich mit einem Namenszeichen endet und der Bereich nicht innerhalb eines Anführungszeichens beginnt, wird automatisch ein einzelnes Leerzeichen eingefügt, um den Namen vom Inhalt des Fortsetzungsbereichs zu trennen. Dadurch kann ein Fortsetzungsbereich für einen mehrzeiligen Ausdruck verwendet werden, dem ein <code>return</code>, Funktionsaufrufanweisungen usw. vorangestellt sind. Es stellt auch sicher, dass Variablennamen nicht mit anderen Tokens (oder Namen) verbunden werden, was zu ungültigen Ausdrücken führt.</p>
<p>LF-Zeichen (<code>`n</code>) werden in Ausdrücken als Leerzeichen behandelt. Dies ermöglicht es, Ausdrücke unter Verwendung eines Fortsetzungsbereichs mit Standardoptionen (d.h. <code>Join</code> weglassen) mehrzeilig zu machen.</p>
<p>Die Optionen <code>,</code> und <code>%</code> wurden entfernt, da diese Zeichen nicht mehr mit einem Escapezeichen versehen werden müssen.</p>
<p>Wenn <code>(</code> oder <code>)</code> in den Optionen eines potenziellen Fortsetzungsbereichs erscheint (außer als Teil der <code>Join</code>-Option), wird die gesamte Zeile nicht als Beginn eines Fortsetzungsbereichs interpretiert. Mit anderen Worten, Zeilen wie <code>(x.y)()</code> und <code>(x=y) &amp;&amp; z()</code> werden als Ausdrücke interpretiert. Ein mehrzeiliger Ausdruck kann auch mit einer runden Startklammer am Anfang einer Zeile beginnen, vorausgesetzt, dass mindestens ein weiteres <code>(</code> oder <code>)</code> in der ersten physischen Zeile vorhanden ist. Zum Beispiel könnte der gesamte Ausdruck mit <code>((</code> und <code>))</code> umschlossen werden.</p>
<p>Abgesehen vom obigen Fall wird beim Vorhandensein ungültiger Optionen ein Ladezeitfehler angezeigt, anstatt die ungültigen Optionen zu ignorieren.</p>
<p>Zeilen, die mit <code>(</code> beginnen und mit <code>:</code> enden, sind nicht ausgeschlossen, einen Fortsetzungsbereich zu beginnen, weil sie wie ein Label aussehen, da <code>(</code> in einem Labelnamen nicht mehr gültig ist. Dies ermöglicht es, dass so etwas wie <code>(Join:</code> einen Fortsetzungsbereich beginnen kann. <code>(:</code> ist jedoch ein Fehler und <code>(::</code> ist immer noch ein Hotkey.</p>
<p>In Ausdrücken und Funktions-/Eigenschaftsdefinitionen wird eine neue Methode der Zeilenfortsetzung unterstützt, die sich die Tatsache zunutze macht, dass jedes <code>(</code>/<code>[</code>/<code>{</code> ein passendes <code>)</code>/<code>]</code>/<code>}</code> haben muss. Mit anderen Worten, wenn eine Zeile ein ungeschlossenes <code>(</code>/<code>[</code>/<code>{</code> enthält, wird sie mit nachfolgenden Zeilen verbunden, bis die Anzahl der Start- und Endklammern ausgeglichen ist. Ein <code>{</code> am Ende einer Zeile wird als <a href="lib/Block.htm#otb">OTB</a> interpretiert (und nicht als Beginn eines direkt geschriebenen Objekts), wenn es keine anderen ungeschlossenen Symbole gibt und kein Operator unmittelbar vor der Klammer steht.</p>
<h3 id="continuation-lines">Fortsetzungszeilen</h3>
<p>Die Zeilenfortsetzung ist jetzt selektiver hinsichtlich dessen, in welchem Kontext ein Symbol als Ausdrucksoperator interpretiert wird. Grundsätzlich können Komma- und Ausdrucksoperatoren nicht mehr zur Fortsetzung in textueller Hinsicht verwendet werden, z.B. bei Hotstrings oder Direktiven (außer #HotIf) oder nach einer ungeschlossenen, in Anführungszeichen gesetzten Zeichenkette.</p>
<p>Die Zeilenfortsetzung funktioniert nun auch für Ausdrucksoperatoren am Ende einer Zeile.</p>
<p><code>is</code>, <code>in</code> und <code>contains</code> können für die Zeilenfortsetzung verwendet werden, allerdings sind <code>in</code> und <code>contains</code> noch nicht als Operatoren reserviert/implementiert.</p>
<p><code>and</code>, <code>or</code>, <code>is</code>, <code>in</code> und <code>contains</code> fungieren als Zeilenfortsetzungsoperatoren, auch dann, wenn eine Zuweisung oder ein anderer binärer Operator folgt, da sie keine gültigen Variablennamen mehr sind. AHK v1 hingegen hatte Ausnahmen für <code>and</code>/<code>or</code> gefolgt von einem der folgenden Zeichen: <code>&lt;&gt;=/|^:,</code></p>
<p>Wenn <code>.</code> für die Fortsetzung verwendet wird, werden die beiden Zeilen nicht mehr automatisch durch ein Leerzeichen separiert, wenn am Anfang einer Zeile kein Leer- oder Tabulatorzeichen rechts von <code>.</code> steht, wie in <code>.SehrLangerVerschachtelterKlassenname</code>. Beachten Sie, dass <code class="no-highlight">x .123</code> immer ein Eigenschaftszugriff ist (keine Auto-Verkettung) und dass <code class="no-highlight">x+.123</code> mit oder ohne Leerzeichen funktioniert.</p>
<h3 id="types">Typen</h3>
<p>In der Regel erzeugt v2 konsistentere Ergebnisse als v1 bei einem Code, der vom Typ eines Wertes abhängt.</p>
<p>In v1 kann eine Variable sowohl eine Zeichenkette als auch eine zwischengespeicherte Binärzahl enthalten, die jedes Mal aktualisiert wird, wenn die Variable als Zahl verwendet wird. Da diese zwischengespeicherte Binärzahl die einzige Möglichkeit ist, den Typ des Wertes zu erkennen, ändert die interne Zwischenspeicherung durch Ausdrücke wie <code>Var+1</code> oder <code>Abs(Var)</code> quasi als Nebeneffekt den "Typ" von <code>Var</code>. AutoHotkey v2 deaktiviert diese Zwischenspeicherung, so dass <code>str := "123"</code> immer eine Zeichenkette und <code>int := 123</code> immer ein Integer ist. Folglich muss <code>str</code> jedes Mal umgewandelt werden, wenn es als Zahl verwendet wird (nicht nur beim ersten Mal), es sei denn, es wurde ursprünglich eine reine Zahl zugewiesen.</p>
<p>Die internen "Variablen" <code>True</code>, <code>False</code>, <code>A_PtrSize</code>, <code>A_Index</code> und <code>A_EventInfo</code> geben immer einen reinen Integer zurück, keine Zeichenkette. In v1 geben sie manchmal eine Zeichenkette zurück, bedingt durch bestimmte Optimierungen, die in v2 überflüssig gemacht wurden.</p>
<p>Alle direkt geschriebenen Zahlen werden beim Laden des Skripts in reine Binärzahlen umgewandelt und ihre Zeichenkettendarstellung wird verworfen. Zum Beispiel ist <code>MsgBox 0x1</code> äquivalent zu <code>MsgBox 1</code>, während <code>MsgBox 1.0000</code> äquivalent zu <code>MsgBox 1.0</code> ist (weil sich die interne Float-Formatierung geändert hat). Eine Zahl, die in eine Variable gespeichert oder von einer benutzerdefinierten Funktion zurückgegeben wird, behält ihren rein numerischen Status.</p>
<p>Das Standardformat für Floating-Point-Zahlen ist nun <code>.17g</code> (ehemals <code class="no-highlight">0.6f</code>), was in vielen Fällen kompakter und genauer ist. Dieser Standard kann nicht geändert werden, allerdings kann <code>Format</code> verwendet werden, um Formatierungen gezielt zu ändern.</p>
<p>Direkt geschriebene, in Anführungszeichen gesetzte Zeichenketten und Zeichenketten, die durch Verkettung mit direkt geschriebenen, in Anführungszeichen gesetzten Zeichenketten erzeugt wurden, werden nicht mehr bedingungslos als nicht-numerisch betrachtet. Stattdessen werden sie wie Zeichenketten behandelt, die in Variablen gespeichert sind oder von Funktionen zurückgegeben werden. Dies hat folgende Auswirkungen:</p>
<ul>
<li>Direkt geschriebenes, in Anführungszeichen gesetztes <code>"0"</code> wird als False behandelt.</li>
<li><code>("0xA") + 1</code> und <code>("0x" Chr(65)) + 1</code> erzeugen 11 anstatt zu scheitern.</li>
<li><code>x[y:="0"]</code> und <code>x["0"]</code> verhalten sich nun gleich.</li>
</ul>
<p>Die Operatoren <code>=</code> und <code>!=</code> vergleichen ihre Operanden nun alphabetisch, wenn beide Operanden Zeichenketten sind, sogar wenn sie numerische Zeichenketten sind. Ein numerischer Vergleich wird weiterhin durchgeführt, wenn beide Operanden numerisch sind und mindestens einer von ihnen eine reine Zahl (keine Zeichenkette) ist. Zum Beispiel werden <code>54</code> und <code>"530"</code> numerisch verglichen, während <code>"54"</code> und <code>"530"</code> alphabetisch verglichen werden. Außerdem werden in Variablen gespeicherte Zeichenketten genauso behandelt wie direkt geschriebene Zeichenketten.</p>
<p>Die Vergleichsoperatoren <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> und <code>&gt;=</code> lösen nun eine Ausnahme aus, wenn sie mit einer nicht-numerischen Zeichenkette verwendet werden. Früher verglichen sie numerisch oder alphabetisch, je nachdem, ob beide Eingabewerte numerisch waren, während direkt geschriebene, in Anführungszeichen gesetzte Zeichenketten immer als nicht-numerisch betrachtet wurden. Verwenden Sie stattdessen <code>StrCompare(a, b, GroßKleinSensitiv)</code>.</p>
<p><code>Type(Wert)</code> gibt eine der folgenden Zeichenketten zurück: String, Integer, Float, oder die spezifische Klasse eines Objekts.</p>
<p><code>Float(Wert)</code>, <code>Integer(Wert)</code> und <code>String(Wert)</code> wandeln <em>Wert</em> in den entsprechenden Typ um, oder lösen eine Ausnahme aus, wenn die Umwandlung nicht möglich ist (z.B. <code>Integer("1z")</code>). <code>Number(Wert)</code> wandelt einen Wert in einen Integer oder eine Floating-Point-Zahl um. <code>String(Wert)</code> ruft <code>Wert.ToString()</code> auf, wenn <em>Wert</em> ein Objekt ist. (Idealerweise sollte dies für jede implizite Umwandlung von Objekt zu Zeichenkette erfolgen, aber die derzeitige Implementierung macht dies schwierig.)</p>
<h2 id="objects">Objekte</h2>
<p>Objekte verwenden nun einen strukturierteren Klassen-Prototypen-Ansatz, der Klassenelemente bzw. statische Elemente von Instanzelementen trennt. Viele der internen Methoden und Obj-Funktionen wurden verschoben, umbenannt, geändert oder entfernt.</p>
<ul>
<li>Jede benutzerdefinierte oder interne Klasse ist ein Klassenobjekt (eine Instanz von <a href="lib/Class.htm">Class</a>), das nur Methoden und Eigenschaften, die mit dem Schlüsselwort <code>static</code> definiert wurden (einschließlich der von der Basisklasse geerbten statischen Elemente), und verschachtelte Klassen zur Verfügung stellt.</li>
<li>Jedes Klassenobjekt hat eine <a href="lib/Class.htm#Prototype">Prototype</a>-Eigenschaft, die zur <code>base</code> (Basis) aller Instanzen dieser Klasse wird. Alle nicht-statischen Methoden- und Eigenschaftsdefinitionen innerhalb des Klassenkörpers sind mit dem Prototypobjekt verbunden.</li>
<li>Die Instanziierung erfolgt durch Aufruf der statischen <a href="lib/Class.htm#Call">Call</a>-Methode, wie in <code>meineKlasse.Call()</code> oder <code>meineKlasse()</code>. Dadurch kann die Klasse das Konstruktionsverhalten vollständig überschreiben (z.B. um eine Class Factory oder ein Singleton zu implementieren oder um ein natives Array oder Map anstelle von Object zu konstruieren), obwohl die Initialisierung typischerweise noch in <code>__New</code> durchgeführt werden sollte. Der Rückgabewert von <code>__New</code> wird nun ignoriert; um den Rückgabewert zu überschreiben, verwenden Sie die Call-Methode.</li>
</ul>
<p>Der gemischte Objekttyp wurde in <code>Object</code>, <code>Array</code> und <code>Map</code> (assoziatives Array) aufgeteilt.</p>
<p>Object ist nun die Basisklasse für alle benutzerdefinierten <strong>und internen</strong> Objekte (außer VarRef und COM-Objekte). Elemente, die zu <code>Object.Prototype</code> hinzugefügt werden, werden von allen AutoHotkey-Objekten geerbt.</p>
<p>Der <code>is</code>-Operator erwartet eine Klasse, daher prüft <code>x is y</code>, ob <code>y.Prototype</code> in der Basisobjektkette existiert. Um zu prüfen, ob <em>y</em> selbst existiert, rufen Sie <code>x.HaseBase(y)</code> oder <code>HasBase(x, y)</code> auf.</p>
<p>Benutzerdefinierte Klassen können auch explizit <code>Object</code>, <code>Array</code>, <code>Map</code> oder einige andere interne Klassen via "extends" erweitern (obwohl dies nicht immer sinnvoll ist), wobei <code>Object</code> die Standardbasisklasse ist, wenn keine angegeben ist.</p>
<p>Der <code>new</code>-Operator wurde entfernt. Lassen Sie stattdessen einfach den Operator weg, wie in <code>MeineKlasse()</code>. Um ein Objekt zu konstruieren, das auf einem anderen Objekt <em>basiert</em>, das keine Klasse ist, erstellen Sie es mit <code>{}</code> oder <code>Object()</code> (oder auf andere Weise) und setzen Sie dessen <code>base</code>. <code>__Init</code> und <code>__New</code> können bei Bedarf explizit aufgerufen werden, allerdings ist das in der Regel nur bei der Instanziierung einer Klasse sinnvoll.</p>
<p>Verschachtelte Klassendefinitionen erzeugen jetzt eine dynamische Eigenschaft mit <em>Get</em>- und <em>Call</em>-Akzessorfunktionen anstelle einer einfachen Werteigenschaft. Damit soll folgendes Verhalten unterstützt werden:</p>
<ul>
<li><code>Verschachtelt.Klasse()</code> übergibt <em>Verschachtelt</em> nicht an <code>Verschachtelt.Klasse.Call</code> und letztlich an <code>__New</code>, was sonst passieren würde, da dies das normale Verhalten für Funktionsobjekte ist, die als Methoden aufgerufen werden (so wie die verschachtelte Klasse hier verwendet wird).</li>
<li><code>Verschachtelt.Klasse := 1</code> ist standardmäßig ein Fehler (die Eigenschaft ist schreibgeschützt).</li>
<li>Die Klasse wird initialisiert, sobald sie das erste Mal referenziert oder aufgerufen wird.</li>
</ul>
<p>GetCapacity und SetCapacity wurden entfernt.</p>
<ul>
<li><a href="lib/Object.htm#GetCapacity">ObjGetCapacity</a> und <a href="lib/Object.htm#SetCapacity">ObjSetCapacity</a> beeinflussen nur noch die Kapazität für die Eigenschaften des Objekts und kommen voraussichtlich nur selten zum Einsatz. Das Setzen der Kapazität des Zeichenkettenpuffers einer Eigenschaft, eines Array-Elements oder eines Map-Elements wird nicht unterstützt; für Binärdaten kann ein <a href="lib/Buffer.htm">Buffer-Objekt</a> verwendet werden.</li>
<li>Array- und Map-Objekte haben eine Capacity-Eigenschaft, die der aktuellen Array- oder Map-Speicherzuweisung des Objekts entspricht.</li>
</ul>
<p>Andere redundante Obj-Funktionen (die interne Methoden von Object widerspiegeln) wurden entfernt. <a href="lib/Object.htm#HasOwnProp">ObjHasOwnProp</a> (ehemals ObjHasKey) und <a href="lib/Object.htm#OwnProps">ObjOwnProps</a> (ehemals ObjNewEnum) bleiben, um eine sichere Überprüfung von Objekten zu ermöglichen, die solche Methoden neu definiert haben (und die primitiven Prototypen, die diese Methoden nicht definiert haben). ObjCount wurde mit <a href="lib/Object.htm#OwnPropCount">ObjOwnPropCount</a> ersetzt (nur eine Funktion, für alle Objects). Map hat seine eigene <a href="lib/Map.htm#Count">Count</a>-Eigenschaft.</p>
<p>ObjRawGet und ObjRawSet wurden mit <a href="lib/Object.htm#GetOwnPropDesc">GetOwnPropDesc</a> und <a href="lib/Object.htm#DefineProp">DefineProp</a> zusammengeführt. Die ursprünglichen Gründe für ihr Dasein wurden durch andere Änderungen überflüssig gemacht, z.B. das <code>Map</code>-Objekt, Änderungen in der Funktionsweise von Metafunktionen, und DefineProp selbst, das Metafunktionen für einige Zwecke überflüssig gemacht hat.</p>
<p>Top-Level-Klassendefinitionen erstellen nun eine Konstante (schreibgeschützte Variable), d.h. Wertzuweisungen an einen Klassennamen zeigen nun einen Fehler statt einer optionalen Warnung an, es sei denn, eine lokale Variable "überschreibt" die globale Klasse (was nun standardmäßig bei Zuweisungen innerhalb einer Funktion geschieht).</p>
<h3 id="primitive-values">Primitive Werte</h3>
<p>Primitive Werte emulieren Objekte durch Delegation von Methoden- und Eigenschaftsaufrufen an ein Prototypobjekt basierend auf ihrem Typ, anstelle des "Standardbasisobjekts" von v1. Integer und Float erweitern (extend) Number. String und Number erweitern Primitive. Primitive und Object erweitern Any. All diese existieren als vordefinierte Klassen.</p>
<h3 id="properties-and-methods">Eigenschaften und Methoden</h3>
<p>Methoden werden über Eigenschaften definiert, im Gegensatz zu v2.0-a104 bis v2.0-a127, wo Methoden und Eigenschaften getrennt behandelt werden. Im Gegensatz zu v1 sind jedoch Eigenschaften, die mit einer Klassenmethodendefinition (oder einer internen Methode) erstellt wurden, standardmäßig schreibgeschützt. Methoden können weiterhin durch Zuweisung neuer Werteigenschaften erstellt werden, was grundsätzlich dem Verhalten von v1 entspricht.</p>
<p>Die Object-Klasse definiert neue Methoden für den Umgang mit Eigenschaften und Methoden: <a href="lib/Object.htm#DefineProp">DefineProp</a>, <a href="lib/Object.htm#DeleteProp">DeleteProp</a>, <a href="lib/Object.htm#GetOwnPropDesc">GetOwnPropDesc</a>, <a href="lib/Object.htm#HasOwnProp">HasOwnProp</a>, <a href="lib/Object.htm#OwnProps">OwnProps</a>. Zusätzliche Methoden sind für alle Werte (außer ComObjects) definiert: <a href="lib/Any.htm#GetMethod">GetMethod</a>, <a href="lib/Any.htm#HasProp">HasProp</a>, <a href="lib/Any.htm#HasMethod">HasMethod</a>.</p>
<p>Object, Array und Map sind nun separate Typen, und Array-Elemente und Eigenschaften werden getrennt behandelt.</p>
<p>Die Definition von benutzerdefinierten und internen Methoden/Eigenschaften (einschließlich <code>base</code>) ist identisch. Dies gewährleistet ein konsistentes Verhalten und erlaubt das Erkennen, Abrufen und Umdefinieren von internen und benutzerdefinierten Elementen.</p>
<p>Wenn eine Eigenschaft keine Parameter akzeptiert, werden diese automatisch an das von der Eigenschaft zurückgegebene Objekt übergeben (oder sie löst eine Ausnahme aus).</p>
<p>Der Versuch, eine nicht-existierende Eigenschaft abzurufen, wird für alle Typen von Werten oder Objekten als Fehler behandelt, es sei denn, <code>__get</code> wurde definiert. Das Setzen einer nicht-existierenden Eigenschaft wird diese jedoch in den meisten Fällen erstellen.</p>
<p>Hacks für mehrdimensionale Arrays wurden entfernt. <code>x.y[z]:=1</code> erstellt kein Objekt mehr in <code>x.y</code>, und <code>x[y,z]</code> ist ein Fehler, es sei denn, x.__item (oder x.__item.__item usw.) behandelt zwei Parameter.</p>
<p>Wenn eine Eigenschaft <code>get</code>, aber nicht <code>set</code> definiert, löst die Zuweisung eines Wertes eine Ausnahme aus, anstatt die Eigenschaft zu überschreiben.</p>
<p><a href="lib/Object.htm#DefineProp">DefineProp</a> kann verwendet werden, um zu definieren, was passieren soll, wenn eine bestimmte Eigenschaft abgerufen, gesetzt <em>oder aufgerufen</em> wird, ohne Metafunktionen definieren zu müssen. Eigenschafts- und Methodendefinitionen in Klassen nutzen denselben Mechanismus, daher kann ein Eigenschafts-Getter/Setter und eine Methode mit demselben Namen definiert werden.</p>
<p>Direkt geschriebene Objekte via <code>{}</code> setzen nun direkt <em>eigene Eigenschaften</em> oder das <code>base</code> des Objekts. Das heißt, dass <code>__Set</code> und Eigenschafts-Setter nicht mehr indirekt aufgerufen werden (was typischerweise nur möglich wäre, wenn <code>base</code> in der Parameterliste gesetzt ist).</p>
<h3 id="staticclass-variables">Statische bzw. Klassenvariablen</h3>
<p>Initialisierungen von statischen bzw. Klassenvariablen werden jetzt im Kontext einer <code>static __Init</code>-Methode ausgeführt, d.h. <code>this</code> verweist auf die Klasse und die Initialisierungen können lokale Variablen erstellen. Sie werden evaluiert, wenn die Klasse zum ersten Mal referenziert wird (anstatt vor Beginn des automatischen Ausführungsbereichs, streng in der Reihenfolge der Definition). Wenn die Klasse noch nicht referenziert wurde, werden sie spätestens dann evaluiert, wenn die Klassendefinition während der Ausführung erreicht wird, d.h. die Initialisierung globaler Variablen kann zuerst erfolgen, ohne sie in eine Klasse zu stecken.</p>
<h3 id="meta-functions">Metafunktionen</h3>
<p>Die Metafunktionen wurden stark vereinfacht; sie verhalten sich wie normale Methoden:</p>
<ul>
<li>Es spielt keine Rolle, wo sie in der Hierarchie definiert sind.</li>
<li>Wenn überschrieben, wird die Basisversion nicht automatisch aufgerufen. Skripte können <code>super.__xxx()</code> bei Bedarf aufrufen.</li>
<li>Wenn definiert, muss sie die Standardaktion ausführen; wenn z.B. __set keinen Wert speichert, wird er nicht gespeichert.</li>
<li>Das Verhalten hängt nicht davon ab, ob die Methode <code>return</code> verwendet (aber natürlich müssen __get und __call immer noch einen Wert zurückgeben).</li>
</ul>
<p>Methoden- und Eigenschaftsparameter werden als Array übergeben. Dies optimiert verkettete Basisaufrufe oder Superklassenaufrufe und ermutigt Autoren (in Kombination mit der MaxParams-Validierung), die Parameter zu behandeln. Bei __set wird der Zuweisungswert separat übergeben.</p>
<pre>this.__call(name, args)
this.__get(name, args)
this.__set(name, args, value)</pre>
<p>Definierte Eigenschaften und Methoden haben Vorrang vor Metafunktionen, egal ob sie in einem Basisobjekt definiert wurden.</p>
<p>__Call wird nicht für interne Aufrufe von __Enum (ehemals _NewEnum) oder Call aufgerufen, z.B. wenn ein Objekt an eine <a href="lib/For.htm">For-Schleife</a> übergeben wird oder wenn ein Funktionsobjekt durch <a href="lib/SetTimer.htm">SetTimer</a> aufgerufen wird.</p>
<p>Die statische __New-Methode wird für jede Klasse bei ihrer Initialisierung aufgerufen, wenn sie von dieser Klasse definiert oder von einer Superklasse geerbt wurde. Weitere Informationen finden Sie unter <a href="#staticclass-variables">Statische bzw. Klassenvariablen</a> (oben) und <a href="Objects.htm#static__New">Klasseninitialisierung</a>.</p>
<h3 id="array">Array</h3>
<p><code>class Array extends Object</code></p>
<p>Ein Array-Objekt enthält eine Liste oder Sequenz von Werten, wobei Index 1 das erste Element ist.</p>
<p>Beim Zuweisen oder Abrufen eines Array-Elements muss der Absolutwert des Index zwischen 1 und <a href="lib/Array.htm#Length">Length</a> des Arrays liegen, andernfalls wird eine Ausnahme ausgelöst. Die Größe eines Arrays kann durch Einfügen oder Entfernen von Elementen mit der entsprechenden Methode oder durch Zuweisung eines Wertes an <a href="lib/Array.htm#Length">Length</a> geändert werden.</p>
<p>Aktuell sind eckige Klammern für den Zugriff auf Elemente erforderlich, d.h. <code>a.1</code> bezieht sich auf eine Eigenschaft und <code>a[1]</code> auf ein Element.</p>
<p>Negative Werte können verwendet werden, um rückwärts zu indexieren.</p>
<p>Die Verwendung von <a href="lib/Array.htm#Clone">Clone</a>, <a href="lib/Array.htm#Delete">Delete</a>, <a href="lib/Array.htm#InsertAt">InsertAt</a>, <a href="lib/Array.htm#Pop">Pop</a>, <a href="lib/Array.htm#Push">Push</a> und <a href="lib/Array.htm#RemoveAt">RemoveAt</a> ist grundsätzlich gleich geblieben. HasKey wurde umbenannt in <a href="lib/Array.htm#Has">Has</a>. <a href="lib/Array.htm#Length">Length</a> ist nun eine Eigenschaft. Die <a href="lib/Array.htm#Capacity">Capacity</a>-Eigenschaft wurde hinzugefügt.</p>
<p>Arrays können mit <code>Array(Werte*)</code> oder <code>[Werte*]</code> konstruiert werden. Variadische Funktionen erhalten ein Array von Parametern. Einige interne Funktionen erstellen ein Array.</p>
<p>Die For-Schleife-Verwendung ist <code>for val in arr</code> oder <code>for idx, val in arr</code>, wobei standardmäßig <code>idx = A_Index</code> ist. Das bedeutet, dass Elemente ohne Wert weiterhin enumeriert werden und dass der Index nicht zurückgegeben wird, wenn nur eine Variable übergeben wurde.</p>
<h3 id="map">Map</h3>
<p>Ein Map-Objekt ist ein assoziatives Array mit ähnlichen Fähigkeiten wie das v1-Objekt, aber weniger Mehrdeutigkeit.</p>
<ul>
<li><a href="lib/Map.htm#Clone">Clone</a> wird wie bisher verwendet.</li>
<li><a href="lib/Map.htm#Delete">Delete</a> kann immer nur einen Schlüssel löschen.</li>
<li>HasKey wurde umbenannt in <a href="lib/Map.htm#Has">Has</a>.</li>
<li><a href="lib/Map.htm#Count">Count</a> ist jetzt eine Eigenschaft.</li>
<li>Neue Eigenschaften: <a href="lib/Map.htm#Capacity">Capacity</a>, <a href="lib/Map.htm#CaseSense">CaseSense</a></li>
<li>Neue Methoden: <a href="lib/Map.htm#Get">Get</a>, <a href="lib/Map.htm#Set">Set</a>, <a href="lib/Map.htm#Clear">Clear</a></li>
<li>Zeichenkettenschlüssel sind standardmäßig Groß-/Kleinschreibung-sensitiv und werden nie in Integer umgewandelt.</li>
</ul>
<p>Derzeit werden Float-Schlüssel noch in Zeichenketten umgewandelt.</p>
<p>Eckige Klammern sind für den Zugriff auf Elemente erforderlich, d.h. <code>a.b</code> bezieht sich auf eine Eigenschaft und <code>a["b"]</code> auf ein Element. Im Gegensatz zu v1 kann eine Eigenschaft oder Methode nicht versehentlich durch die Zuweisung eines Array-Elements deaktiviert werden.</p>
<p>Es wird eine Ausnahme ausgelöst, wenn versucht wird, den Wert eines nicht-existierenden Elements abzurufen, es sei denn, das Map-Objekt hat eine <a href="lib/Map.htm#Default">Default</a>-Eigenschaft definiert. <code>MapObj.Get(Schlüssel, Standardwert)</code> kann verwendet werden, um explizit einen Standardwert für jeden Abruf bereitzustellen.</p>
<p>Verwenden Sie <code>Map(Schlüssel, Wert, ...)</code>, um ein Map-Objekt anhand einer Liste von Schlüssel-Wert-Paaren zu erstellen.</p>
<h3 id="enumeration">Enumeration</h3>
<p>Geändertes Enumerator-Modell:</p>
<ul>
<li>_NewEnum() wurde mit __Enum(n) ersetzt.</li>
<li>Der Pflichtparameter n enthält die Anzahl der Variablen in der For-Schleife, mit dem die Enumeration beeinflusst werden kann, ohne die Initialisierung bis zum ersten Aufruf der Wiederholung verzögern zu müssen.</li>
<li>Next() wurde mit Call() ersetzt und wird genauso verwendet, außer dass ByRef jetzt anders funktioniert. Zum Beispiel sollte eine Methode, die als <code>Call(&amp;a)</code> definiert ist, <code>a := next_value</code> zuweisen, während <code>Call(a)</code> ein <a href="Concepts.htm#variable-references">VarRef</a> erhalten würde und somit <code>%a% := next_value</code> zuweisen sollte.</li>
<li>Wenn __Enum nicht vorhanden ist, wird angenommen, dass das Objekt ein Enumerator ist. Dadurch können Funktionsobjekte (z.B. <a href="Functions.htm#closures">Closures</a>) direkt verwendet werden.</li>
</ul>
<p>Da Array-Elemente und Eigenschaften nun getrennt behandelt werden, muss zum Enumerieren von Eigenschaften explizit ein Enumerator via <a href="lib/Object.htm#OwnProps">OwnProps</a> erstellt werden.</p>
<h3 id="bound-functions">Bound-Funktionen</h3>
<p>Wenn eine <a href="misc/Functor.htm#BoundFunc">Bound-Funktion</a> aufgerufen wird, belegen die vom Aufrufer übergebenen Parameter alle Positionen, die bei der Erstellung der Bound-Funktion weggelassen wurden. Zum Beispiel bewirkt <code>F.Bind(,b).Call(a,c)</code>, dass <code>F(a,b,c)</code> statt <code>F(,b,a,c)</code> aufgerufen wird.</p>
<h3 id="com-objects-comobject">COM-Objekte (ComObject)</h3>
<p>COM-Wrapper-Objekte werden jetzt in Abhängigkeit von ihrem Variantentyp als Instanzen einiger verschiedener Klassen identifiziert (was wie früher Auswirkungen darauf hat, welche Methoden und Eigenschaften sie unterstützen):</p>
<ul>
<li><code>ComValue</code> ist die Basisklasse für alle COM-Wrapper-Objekte.</li>
<li><code>ComObject</code> ist für VT_DISPATCH mit einem Nicht-Null-Pointer, was typischerweise ein gültiges COM-Objekt ist, das vom Skript mit normaler Objektsyntax indirekt aufgerufen werden kann.</li>
<li><code>ComObjArray</code> ist für VT_ARRAY (SafeArrays).</li>
<li><code>ComValueRef</code> ist für VT_BYREF.</li>
</ul>
<p>Diese Klassen können für Typprüfungen mit <code>obj is ComObject</code> und ähnlichem verwendet werden. Für Objekte vom Typ ComValue, ComObjArray und ComValueRef (aber nicht ComObject) können Eigenschaften und Methoden durch Ändern des entsprechenden Prototypobjekts definiert werden.</p>
<p><code>ComObject(CLSID)</code> erstellt ein ComObject; dies ist quasi das neue ComObjCreate.</p>
<p>Hinweis: Wenn Sie alten Code aktualisieren und einen TypeError erhalten, weil ein Integer an ComObject übergeben wurde, sollten Sie wahrscheinlich stattdessen ComValue aufrufen.</p>
<p><code>ComValue(vt, Wert)</code> erstellt ein Wrapper-Objekt. Es kann eine Instanz einer der oben aufgeführten Klassen zurückgeben. Dies ersetzt <code>ComObjParameter(vt, value)</code>, <code>ComObject(vt, value)</code> und alle anderen Namen, die mit einem <em>Variantentyp</em> und <em>Wert</em> als Parameter verwendet wurden. <em>Wert</em> wird in den entsprechenden Typ umgewandelt (gemäß COM-Konventionen), anstatt einen Integer mit dem richtigen Binärwert zu verlangen. Genauer gesagt verhalten sich die folgenden anders als früher, wenn ihnen ein Integer übergeben wird: R4, R8, Cy, Date. Pointertypen erlauben entweder eine reine Integeradresse wie früher oder ein Objekt/ComValue.</p>
<p><code>ComObjFromPtr(pdsp)</code> ist eine ähnliche Funktion wie <code>ComObjEnwrap(dsp)</code>, aber wie ObjFromPtr ruft sie nicht AddRef auf den Pointer auf. Das v1-Äquivalent ist <code>ComObject(9, dsp, 1)</code>; das Weglassen des dritten Parameters in v1 führte zu AddRef.</p>
<p>Sowohl bei ComValue als auch bei ComObjFromPtr ist zu beachten, dass AddRef nie automatisch aufgerufen wird; in dieser Hinsicht verhalten sie sich wie <code>ComObject(9, Wert, 1)</code> oder <code>ComObject(13, Wert, 1)</code> in v1. Dies bedeutet nicht unbedingt, dass Sie <code>ObjAddRef(Wert)</code> beim Aktualisieren alter Skripte hinzufügen sollten, da viele Skripte die alte Funktion falsch verwendet haben.</p>
<p>COM-Wrapper-Objekte mit dem Variantentyp VT_BYREF, VT_ARRAY oder VT_UNKNOWN haben jetzt eine <em>Ptr</em>-Eigenschaft äquivalent zu <code>ComObjValue(ComObj)</code>. Dadurch können sie an <a href="lib/DllCall.htm">DllCall</a> oder <a href="lib/ComCall.htm">ComCall</a> mit dem Argumenttyp <em>Ptr</em> übergeben werden. Außerdem kann dadurch das Objekt direkt an <a href="lib/NumPut.htm">NumPut</a> oder <a href="lib/NumGet.htm">NumGet</a> übergeben werden, was zusammen mit VT_BYREF (Zugriff auf die typisierte Variable des Aufrufers), VT_ARRAY (Zugriff auf SAFEARRAY-Felder) oder VT_UNKNOWN (vtable-Pointer abrufen) verwendet werden kann.</p>
<p>COM-Wrapper-Objekte mit dem Variantentyp VT_DISPATCH oder VT_UNKNOWN und einem Null-Interface-Pointer haben jetzt eine <em>Ptr</em>-Eigenschaft, die gelesen oder geändert werden kann. Sobald ihr ein Nicht-Null-Pointer zugewiesen wurde, ist die Eigenschaft schreibgeschützt. Dies ist für die Verwendung mit <a href="lib/DllCall.htm">DllCall</a> und <a href="lib/ComCall.htm">ComCall</a> vorgesehen, damit der Pointer nach dem Return der Funktion nicht manuell gewrappt werden muss.</p>
<p>Die Enumeration von ComObjArray ist jetzt konsistent mit Array, d.h. <code>for value in arr</code> oder <code>for index, value in arr</code> statt <code>for value, vartype in arr</code>. Der Startwert für <em>index</em> ist die Untergrenze von ComObjArray (<code>arr.MinIndex()</code>), typischerweise 0.</p>
<p>Die Integertypen I1, I8, UI1, UI2, UI4 und UI8 werden nun in einen Integer statt in eine Zeichenkette umgewandelt. Diese kommen in COM-Aufrufen selten vor, was auch für VT_BYREF-Wrapper gilt. VT_ERROR wird nicht mehr in einen Integer umgewandelt, sondern erzeugt einen ComValue.</p>
<p>COM-Objekte setzen nicht mehr <a href="Variables.htm#LastError">A_LastError</a>, wenn ein indirekter Eigenschafts- oder Methodenaufruf fehlschlägt.</p>
<h3 id="default-property">Standardeigenschaft</h3>
<p>Ein COM-Objekt kann eine "Standardeigenschaft" haben, die zwei Verwendungen hat:</p>
<ul>
<li>Der <em>Wert</em> des Objekts. Zum Beispiel evaluiert <code>MsgBox obj</code> in VBScript das Objekt durch indirekten Aufruf seines Standardelements.</li>
<li>Die indexierte Eigenschaft einer Collection, die normalerweise <em>Item</em> oder <em>item</em> heißt.</li>
</ul>
<p>AutoHotkey v1 hatte kein Konzept für eine Standardeigenschaft, so dass der COM-Objekt-Wrapper die Standardeigenschaft indirekt aufrief, wenn der Eigenschaftsname weggelassen wurde, also <code>obj[]</code> oder <code>obj[,x]</code>.</p>
<p>AutoHotkey v2 trennt jedoch Eigenschaften von Array-/Map-/Collection-Elementen, indem <code>obj[x]</code> auf die Standardeigenschaft des Objekts gemappt wird (egal ob <em>x</em> vorhanden ist oder nicht). Für AutoHotkey-Objekte ist dies <code>__Item</code>.</p>
<p>Einige COM-Objekte, die Arrays oder Collections repräsentieren, stellen keine Standardeigenschaft zur Verfügung, so dass es in v2 nicht möglich ist, mit <code>[]</code> auf Elemente zuzugreifen. Zum Beispiel stellen JavaScript-Array-Objekte und einige andere Objekte, die normalerweise mit JavaScript verwendet werden, Array-Elemente als Eigenschaften zur Verfügung. In solchen Fällen kann <code>arr.%i%</code> verwendet werden, um auf eine Array-Element-Eigenschaft zuzugreifen.</p>
<p>Wenn ein <a href="lib/Array.htm">Array-Objekt</a> von AutoHotkey v2 an JavaScript übergeben wird, können seine Elemente nicht mit JavaScripts <code>arr[i]</code> abgerufen werden, da dies einen Zugriffsversuch auf eine Eigenschaft bedeuten würde.</p>
<h3 id="com-calls">COM-Aufrufe</h3>
<p>Aufrufe von AutoHotkey-Objekten über das IDispatch-Interface unterstützen jetzt nachvollziehbar VT_BYREF-Parameter. Dies wird häufig mit COM-Ereignissen verwendet (<a href="lib/ComObjConnect.htm">ComObjConnect</a>).</p>
<p>Für jeden VT_BYREF-Parameter wird eine namenlose temporäre Variable erstellt, der Wert aus der Variable des Aufrufers kopiert und eine <a href="Concepts.htm#variable-references">VarRef</a> an die AutoHotkey-Funktion/Methode übergeben. Bei Return wird der Wert aus der temporären Variable zurück in die Variable des Aufrufers kopiert.</p>
<p>Eine Funktion/Methode kann einen Wert durch Deklaration des Parameters als ByRef (mit <code>&amp;</code>) oder durch explizite Dereferenzierung zuweisen.</p>
<p>Zum Beispiel würde ein Parameter vom Typ <code>VT_BYREF|VT_BOOL</code> vorher ein ComObjRef-Objekt erhalten und einen Wert wie <code>pbCancel[] := true</code> oder <code>NumPut(-1, ComObjValue(pbCancel), "short")</code> zugewiesen bekommen. Nun kann der Parameter als <code>&amp;bCancel</code> definiert und zugewiesen werden, z.B. <code>bCancel := true</code>; oder als <code>pbCancel</code> definiert und zugewiesen werden, z.B. <code>%pbCancel% := true</code>.</p>
<h2 id="library">Library</h2>
<p>Entfernt:</p>
<ul>
<li>Asc() (verwenden Sie stattdessen <a href="lib/Ord.htm">Ord</a>)</li>
<li>AutoTrim (verwenden Sie stattdessen <a href="lib/Trim.htm">Trim</a>)</li>
<li>ComObjMissing() (schreiben Sie stattdessen zwei aufeinanderfolgende Kommas)</li>
<li>ComObjUnwrap() (verwenden Sie stattdessen <a href="lib/ComObjValue.htm">ComObjValue</a> und ggf. <a href="lib/ObjAddRef.htm">ObjAddRef</a>)</li>
<li>ComObjEnwrap() (verwenden Sie stattdessen <a href="lib/ComObjFromPtr.htm">ComObjFromPtr</a> und ggf. <a href="lib/ObjAddRef.htm">ObjAddRef</a>)</li>
<li>ComObjError()</li>
<li>ComObjXXX(), wobei XXX nichts anderes als eine der explizit definierten ComObj-Funktionen ist (verwenden Sie stattdessen <a href="lib/ComObjActive.htm">ComObjActive</a>, <a href="lib/ComValue.htm">ComValue</a> oder <a href="lib/ComObjFromPtr.htm">ComObjFromPtr</a>).</li>
<li>ControlSendRaw (verwenden Sie stattdessen <code>ControlSend "{Raw}"</code> oder <a href="lib/ControlSend.htm">ControlSendText</a>)</li>
<li>EnvDiv</li>
<li>EnvMult</li>
<li>EnvUpdate (es ist von sehr begrenztem Nutzen und kann mit einem einfachen <a href="lib/SendMessage.htm">SendMessage</a> ersetzt werden)</li>
<li>Exception (verwenden Sie stattdessen <a href="lib/Error.htm">Error</a> oder eine geeignete Unterklasse)</li>
<li>FileReadLine (verwenden Sie stattdessen eine <a href="lib/LoopFiles.htm">dateilesende Schleife</a> oder <a href="lib/FileOpen.htm">FileOpen</a>)</li>
<li>Func (verwenden Sie stattdessen eine direkte Referenz wie <code>MeineFunk</code>)</li>
<li>Gosub</li>
<li>Gui, GuiControl, GuiControlGet (siehe <a href="#gui">Gui</a>)</li>
<li>IfEqual</li>
<li>IfExist</li>
<li>IfGreater</li>
<li>IfGreaterOrEqual</li>
<li>IfInString</li>
<li>IfLess</li>
<li>IfLessOrEqual</li>
<li>IfMsgBox (<a href="lib/MsgBox.htm">MsgBox</a> gibt nun den Namen der Schaltfläche zurück)</li>
<li>IfNotEqual</li>
<li>IfNotExist</li>
<li>IfNotInString</li>
<li>IfWinActive</li>
<li>IfWinExist</li>
<li>IfWinNotActive</li>
<li>IfWinNotExist</li>
<li>If between/is/in/contains (aber siehe <a href="#isXXX">isXXX</a>)</li>
<li>Input (verwenden Sie stattdessen <a href="lib/InputHook.htm">InputHook</a>)</li>
<li>IsByRef (siehe <a href="Functions.htm#NoIsByRef">ByRef-Einschränkungen</a>)</li>
<li>IsFunc</li>
<li>Menu (verwenden Sie stattdessen die <a href="lib/Menu.htm">Menu/MenuBar-Klasse</a>, <a href="lib/TraySetIcon.htm">TraySetIcon</a>, <a href="Variables.htm#IconTip">A_IconTip</a>, <a href="Variables.htm#IconHidden">A_IconHidden</a> und <a href="Variables.htm#AllowMainWindow">A_AllowMainWindow</a>)</li>
<li>MenuGetHandle (verwenden Sie stattdessen <a href="lib/Menu.htm#Handle">Menu.Handle</a>)</li>
<li>MenuGetName (es gibt keine Menünamen; <a href="lib/MenuFromHandle.htm">MenuFromHandle</a> ist der nächstbeste Ersatz)</li>
<li>Progress (verwenden Sie stattdessen <a href="lib/Gui.htm">Gui</a>)</li>
<li>SendRaw (verwenden Sie stattdessen <code>Send "{Raw}"</code> oder <a href="lib/Send.htm#SendText">SendText</a>)</li>
<li>SetBatchLines (-1 ist nun das Standardverhalten)</li>
<li>SetEnv</li>
<li>SetFormat (<a href="lib/Format.htm">Format</a> kann zum Formatieren einer Zeichenkette verwendet werden)</li>
<li>SoundGet/SoundSet (siehe <a href="#Sound">Sound-Funktionen</a>)</li>
<li>SoundGetWaveVolume/SoundSetWaveVolume (etwas anderes Verhalten als SoundGet/SoundSet in Bezug auf die Balance, aber keines von beiden behält die Balance bei)</li>
<li>SplashImage (verwenden Sie stattdessen <a href="lib/Gui.htm">Gui</a>)</li>
<li>SplashTextOn/Off (verwenden Sie stattdessen <a href="lib/Gui.htm">Gui</a>)</li>
<li>StringCaseSense (verwenden Sie stattdessen entsprechende Parameter)</li>
<li>StringGetPos (verwenden Sie stattdessen <a href="lib/InStr.htm">InStr</a>)</li>
<li>StringLeft<br>
StringLen<br>
StringMid<br>
StringRight<br>
StringTrimLeft<br>
StringTrimRight -- verwenden Sie stattdessen <a href="lib/SubStr.htm">SubStr</a>.</li>
<li>StringReplace (verwenden Sie stattdessen <a href="lib/StrReplace.htm">StrReplace</a>)</li>
<li>StringSplit (verwenden Sie stattdessen <a href="lib/StrSplit.htm">StrSplit</a>)</li>
<li>Transform</li>
<li>VarSetCapacity (verwenden Sie stattdessen ein <a href="lib/Buffer.htm">Buffer-Objekt</a> für Binärdaten/Strukturen und <a href="lib/VarSetStrCapacity.htm">VarSetStrCapacity</a> für UTF-16-Zeichenketten)</li>
<li>WinGetActiveStats</li>
<li>WinGetActiveTitle</li>
<li>#CommentFlag</li>
<li>#Delimiter</li>
<li>#DerefChar</li>
<li>#EscapeChar</li>
<li>#HotkeyInterval (verwenden Sie stattdessen <a href="Variables.htm#HotkeyInterval">A_HotkeyInterval</a>)</li>
<li>#HotkeyModifierTimeout (verwenden Sie stattdessen <a href="lib/A_HotkeyModifierTimeout.htm">A_HotkeyModifierTimeout</a>)</li>
<li>#IfWinActive, #IfWinExist, #IfWinNotActive, #IfWinNotExist (siehe <a href="lib/_HotIf.htm#optimization">#HotIf-Optimierung</a>)</li>
<li>#InstallKeybdHook (verwenden Sie stattdessen die <a href="lib/InstallKeybdHook.htm">InstallKeybdHook</a>-Funktion)</li>
<li>#InstallMouseHook (verwenden Sie stattdessen die <a href="lib/InstallMouseHook.htm">InstallMouseHook</a>-Funktion)</li>
<li>#KeyHistory (verwenden Sie stattdessen <code>KeyHistory N</code>)</li>
<li>#LTrim</li>
<li>#MaxHotkeysPerInterval (verwenden Sie stattdessen <a href="lib/A_MaxHotkeysPerInterval.htm">A_MaxHotkeysPerInterval</a>)</li>
<li>#MaxMem (die maximale Kapazität jeder Variable ist nun unbegrenzt)</li>
<li>#MenuMaskKey (verwenden Sie stattdessen <a href="lib/A_MenuMaskKey.htm">A_MenuMaskKey</a>)</li>
<li>#NoEnv (gilt jetzt immer)</li>
</ul>
<p>Umbenannt:</p>
<ul>
<li>ComObjCreate() → <a href="lib/ComObject.htm">ComObject</a>, das nun eine Klasse ist</li>
<li>ComObjParameter() → <a href="lib/ComValue.htm">ComValue</a>, das nun eine Klasse ist</li>
<li>DriveSpaceFree → <a href="lib/DriveGetSpaceFree.htm">DriveGetSpaceFree</a></li>
<li>EnvAdd → <a href="lib/DateAdd.htm">DateAdd</a></li>
<li>EnvSub → <a href="lib/DateDiff.htm">DateDiff</a></li>
<li>FileCopyDir → <a href="lib/DirCopy.htm">DirCopy</a></li>
<li>FileCreateDir → <a href="lib/DirCreate.htm">DirCreate</a></li>
<li>FileMoveDir → <a href="lib/DirMove.htm">DirMove</a></li>
<li>FileRemoveDir → <a href="lib/DirDelete.htm">DirDelete</a></li>
<li>FileSelectFile → <a href="lib/FileSelect.htm">FileSelect</a></li>
<li>FileSelectFolder → <a href="lib/DirSelect.htm">DirSelect</a></li>
<li>#If → <a href="lib/_HotIf.htm">#HotIf</a></li>
<li>#IfTimeout → <a href="lib/_HotIfTimeout.htm">HotIfTimeout</a></li>
<li>StringLower → <a href="lib/StrLower.htm">StrLower</a> und <a href="lib/StrLower.htm">StrTitle</a></li>
<li>StringUpper → <a href="lib/StrLower.htm">StrUpper</a> und <a href="lib/StrLower.htm">StrTitle</a></li>
<li>UrlDownloadToFile → <a href="lib/Download.htm">Download</a></li>
<li>WinMenuSelectItem → <a href="lib/MenuSelect.htm">MenuSelect</a></li>
<li>LV-, TV- und SB-Funktionen → Methoden von <a href="lib/GuiControl.htm">GuiControl</a></li>
<li>File.__Handle → <a href="lib/File.htm#Handle">File.Handle</a></li>
</ul>
<h3 id="removed-details">Entfernte Befehle (Details)</h3>
<p>Eine vollständige Liste finden Sie oben.</p>
<p id="EnvUpdate">EnvUpdate wurde entfernt, kann aber wie folgt mit einem einfachen SendMessage-Aufruf ersetzt werden:</p>
<pre>SendMessage(0x1A, 0, StrPtr("Environment"), 0xFFFF)</pre>
<p id="StringCaseSense">StringCaseSense wurde entfernt, also ist <code>!=</code> immer nicht-Groß-/Kleinschreibung-sensitiv (allerdings wurde <code>!==</code> für "Groß-/Kleinschreibung-sensitiv ungleich" hinzugefügt). Sowohl <code>=</code> als auch <code>!=</code> ignorieren nur die Groß-/Kleinschreibung bei ASCII-Zeichen. <a href="lib/StrCompare.htm">StrCompare</a> wurde hinzugefügt, um Zeichenketten in jedem Modus zu vergleichen. Verschiedene String-Funktionen haben jetzt einen <em>GroßKleinSensitiv</em>-Parameter, mit dem die Groß-/Kleinschreibung-Sensitivität oder der Locale-Modus angegeben werden kann.</p>
<h3 id="modified-commandsfunctions">Geänderte Befehle/Funktionen</h3>
<p class="note">Die Überschrift soll nicht suggerieren, dass es Befehle in v2 gibt. Es gibt nur Funktionen. Die Überschrift bezieht sich auf beide Versionen.</p>
<p><a href="lib/BlockInput.htm">BlockInput</a> wird nicht mehr kurzzeitig deaktiviert, wenn ein Alt-Ereignis mit der SendEvent-Methode gesendet wird. Dies war ursprünglich notwendig, um einen Bug in einigen Versionen von Windows XP zu umgehen, der BlockInput dazu veranlasste, das künstliche Alt-Ereignis zu blockieren.</p>
<p><code>Chr(0)</code> gibt eine Zeichenkette mit der Länge 1 zurück, da eine binäre Null enthalten ist. Dies beruht auf der verbesserten Unterstützung für binäre Nullen in Zeichenketten.</p>
<p><a href="lib/ClipWait.htm">ClipWait</a> gibt nun 0 (false) zurück, wenn die Wartezeit abgelaufen ist, andernfalls 1 (true). ErrorLevel wurde entfernt. Die Angabe von 0 entspricht nicht länger der Angabe von 0.5; stattdessen wird die kleinstmögliche Wartezeit erzeugt.</p>
<p><code>ComObj()</code>: Diese Funktion hatte quasi einen Platzhalternamen, der viele verschiedene Suffixe zuließ. Einige Namen wurden häufiger mit bestimmten Parametertypen verwendet, z.B. <code>ComObjActive(CLSID)</code>, <code>ComObjParameter(vt, value)</code>, <code>ComObjEnwrap(dsp)</code>. Stattdessen gibt es jetzt separate Funktionen/Klassen und keine Platzhalternamen mehr. Weitere Informationen finden Sie unter <a href="#com-objects-comobject">COM-Objekte (ComObject)</a>.</p>
<p>Steuerelement-Parameter: Es wurden mehrere Änderungen am <a href="lib/Control.htm#Parameter"><em>Steuerelement</em>-Parameter</a> vorgenommen, der von den <a href="lib/Control.htm">Control-Funktionen</a>, <a href="lib/SendMessage.htm">SendMessage</a> und <a href="lib/PostMessage.htm">PostMessage</a> verwendet wird:</p>
<ul>
<li>Dieser akzeptiert nun eine HWND-Nummer (muss ein reiner Integer sein) oder ein Objekt mit einer <em>Hwnd</em>-Eigenschaft wie z.B. ein <a href="lib/GuiControl.htm">GuiControl-Objekt</a>. Die HWND-Nummer kann ein Steuerelement oder ein Top-Level-Fenster identifizieren, obwohl letzteres in der Regel nur für einige wenige Funktionen sinnvoll ist (siehe unten).</li>
<li>Dieser Parameter ist nicht mehr optional, außer bei Funktionen, die mit einem Top-Level-Fenster arbeiten (<a href="lib/ControlSend.htm">ControlSend[Text]</a>, <a href="lib/ControlClick.htm">ControlClick</a>, <a href="lib/SendMessage.htm">SendMessage</a>, <a href="lib/PostMessage.htm">PostMessage</a>) oder wenn andere optionale Parameter vorangestellt sind (<a href="lib/ListViewGetContent.htm">ListViewGetContent</a>, <a href="lib/ControlGetPos.htm">ControlGetPos</a>, <a href="lib/ControlMove.htm">ControlMove</a>).</li>
<li>Wenn weggelassen, wird stattdessen das Zielfenster verwendet. Diese Änderung entspricht dem vorherigen Verhalten von <a href="lib/SendMessage.htm">SendMessage</a>/<a href="lib/PostMessage.htm">PostMessage</a> und ersetzt den von <a href="lib/ControlSend.htm">ControlSend</a> verwendeten Sonderwert <code>ahk_parent</code>.</li>
<li>Leere Werte sind ungültig. Diese Funktionen verwenden standardmäßig nicht das oberste Steuerelement des Zielfensters.</li>
</ul>
<p><a href="lib/ControlGetFocus.htm">ControlGetFocus</a> gibt nun die HWND-Nummer anstelle der ClassNN-Bezeichnung des Steuerelements zurück, und wertet es nicht mehr als Fehler, wenn es erfolgreich festgestellt hat, dass das Fenster kein fokussiertes Steuerelement aufweist.</p>
<p><a href="lib/ControlMove.htm">ControlMove</a>, <a href="lib/ControlGetPos.htm">ControlGetPos</a> und <a href="lib/ControlClick.htm">ControlClick</a> verwenden nun Clientkoordinaten (wie <a href="lib/GuiControl.htm">GuiControl</a>) statt Fensterkoordinaten. Clientkoordinaten sind relativ zur oberen linken Ecke des Clientbereichs (das ist der Bereich ohne Titelleiste und Rahmen). (Steuerelemente werden nur im Clientbereich gerendert.)</p>
<p><a href="lib/ControlMove.htm">ControlMove</a>, <a href="lib/ControlSend.htm">ControlSend</a> und <a href="lib/ControlSetText.htm">ControlSetText</a> haben nun eine Parameterreihenfolge, die mit anderen Control-Funktionen konsistent ist, d.h. <em><strong>Steuerelement</strong>, FensterTitel, FensterText, AusnahmeTitel, AusnahmeText</em> werden immer zusammen in dieser Reihenfolge verwendet (am Ende der Parameterliste), um das Einprägen der Parameter zu fördern.</p>
<p><a href="lib/CoordMode.htm">CoordMode</a> akzeptiert nicht länger "Relative" als Modus, da alle Modi relativ zu etwas sind. Es war synonym mit "Window", verwenden Sie stattdessen dieses Wort.</p>
<p><a href="lib/DllCall.htm">DllCall</a>: Siehe <a href="#dllcall">DllCall</a>-Abschnitt weiter unten.</p>
<p><a href="lib/Edit.htm">Edit</a> hatte früher ein Fallback-Verhalten für den Dateityp <code>.ini</code>, wenn das Shellverb "edit" nicht registriert war. Dies wurde entfernt, da Skriptdateien nicht mehr die Dateiendung <code>.ini</code> haben können. <code>AutoHotkey.ini</code> war der Standardskriptname in alten AutoHotkey-Versionen.</p>
<p><a href="lib/Edit.htm">Edit</a> macht nun nichts mehr, wenn das Skript aus der Standardeingabe (stdin) gelesen wurde, anstatt zu versuchen, einen Editor für <code>*</code> zu öffnen.</p>
<p><a href="lib/EnvSet.htm">EnvSet</a> löscht nun die Umgebungsvariable, wenn der <em>Wert</em>-Parameter vollständig weggelassen wird.</p>
<p><a href="lib/Exit.htm">Exit</a> verhielt sich früher wie <a href="lib/ExitApp.htm">ExitApp</a>, wenn das Skript nicht persistent ist, selbst wenn es andere suspendierte Threads gab, die vom Thread, der Exit aufrief, unterbrochen wurden. Dies ist nun nicht mehr der Fall. Stattdessen wird der aktuelle Thread immer ordnungsgemäß beendet, und das Skript erst terminiert (sofern nicht persistent), wenn der letzte Thread beendet wurde. Dadurch wird sichergestellt, dass <a href="lib/Finally.htm">Finally</a>-Anweisungen ausgeführt und lokale Variablen freigegeben werden, was wiederum den Aufruf von <code>__Delete</code> für alle in lokalen Variablen enthaltenen Objekte ermöglicht.</p>
<p><a href="lib/FileAppend.htm">FileAppend</a> übersetzt standardmäßig keine Zeilenumbrüche, um mit <a href="lib/FileRead.htm">FileRead</a> und <a href="lib/FileOpen.htm">FileOpen</a> konsistent zu sein. FileAppend und FileRead haben jeweils einen separaten <em>Optionen</em>-Parameter, der die Optionspräfixe ersetzt und optional einen Kodierungsnamen enthalten kann (was die <code>*Pnnn</code>-Option von FileRead überflüssig macht). FileAppend, FileRead und FileOpen verwenden <code>"`n"</code>, um Zeilenumbruchübersetzungen zu aktivieren. FileAppend und FileRead unterstützen die Option <code>"RAW"</code>, um die Codepageumwandlung zu deaktivieren (Binärdaten lesen/schreiben); FileRead gibt in diesem Fall ein <a href="lib/Buffer.htm">Buffer-Objekt</a> zurück. Dies ersetzt <code>*c</code> (siehe <a href="lib/ClipboardAll.htm">ClipboardAll</a>). FileAppend akzeptiert ein Buffer-ähnliches Objekt, in diesem Fall wird keine Umwandlung durchgeführt.</p>
<p><a href="lib/FileCopy.htm">FileCopy</a> und <a href="lib/FileMove.htm">FileMove</a> lösen jetzt eine Ausnahme aus, wenn der Quellpfad kein <code>*</code> oder <code>?</code> enthält und keine Datei gefunden wurde. Nach wie vor wird das Kopieren oder Verschieben von 0 Dateien nicht als Fehler gewertet, wenn der Quellpfad Platzhalterzeichen enthält.</p>
<p><a href="lib/FileOpen.htm">FileOpen</a> löst jetzt eine Ausnahme aus, wenn die Datei nicht geöffnet werden kann. Andernfalls würde eine Ausnahme bereits beim ersten Zugriffsversuch auf das Objekt ausgelöst (wenn das Skript nicht auf Fehler geprüft hat) und nicht erst am eigentlichen Fehlerpunkt.</p>
<p><a href="lib/File.htm#RawRead">File.RawRead</a>: Bei der direkten Übergabe einer Variable wird die Adresse des internen Zeichenkettenpuffers der Variable nicht länger verwendet. Daher kann eine Variable, die eine Adresse enthält, direkt übergeben werden (während in v1 so etwas wie <code>var+0</code> notwendig war).</p>
<p>Zum Reservieren von Pufferspeicher ist das neue <a href="lib/Buffer.htm">Buffer-Objekt</a> einer Variable vorzuziehen; jedes Objekt kann verwendet werden, solange es die <em>Ptr</em>- und <em>Size</em>-Eigenschaft hat.</p>
<p><a href="lib/File.htm#RawWrite">File.RawWrite</a>: Wie oben, außer dass es eine Zeichenkette (oder eine Variable mit einer Zeichenkette) akzeptieren kann - in diesem Fall ist <em>Bytes</em> standardmäßig die Größe der Zeichenkette in Bytes. Die Zeichenkette kann binäre Nullen enthalten.</p>
<p><a href="lib/File.htm#ReadLine">File.ReadLine</a> unterstützt nun immer <code>`r</code>, <code>`n</code> und <code>`r`n</code> als Zeilenenden und fügt das Zeilenende nicht länger in den Rückgabewert ein. Zeilenenden werden weiterhin unverändert via <a href="lib/File.htm#Read">File.Read</a> an das Skript zurückgegeben, wenn die Zeilenumbruchübersetzung deaktiviert ist.</p>
<p><a href="lib/FileEncoding.htm">FileEncoding</a> erlaubt nun die Angabe von Codepages als Zahl ohne das Präfix <code>CP</code>. Der Parameter ist nicht mehr optional, kann aber weiterhin explizit leer sein.</p>
<p><a href="lib/FileExist.htm">FileExist</a> ignoriert nun <code>.</code> und <code>..</code> implizit in jeder Verzeichnisauflistung, folglich ist <code>FileExist("dir\*")</code> nun False statt True, wenn das Verzeichnis existiert, aber leer ist.</p>
<p><a href="lib/FileGetAttrib.htm">FileGetAttrib</a> und A_LoopFileAttrib haben jetzt den Buchstaben "L" für Analysepunkte oder symbolische Verknüpfungen.</p>
<p><a href="lib/FileInstall.htm">FileInstall</a> in einem unkompilierten Skript versucht nicht länger, die Datei zu kopieren, wenn Quelle und Ziel derselbe Pfad sind (nach der Auflösung relativer Pfade, da die Quelle relativ zu <a href="Variables.htm#ScriptDir">A_ScriptDir</a> ist, nicht zu <a href="Variables.htm#WorkingDir">A_WorkingDir</a>). In v1 führte dies dazu, dass ErrorLevel auf 1 gesetzt wurde, was meist unbemerkt blieb. Der Versuch, eine Datei mittels zwei verschiedener Pfade auf sich selbst zu kopieren, löst weiterhin einen Fehler aus.</p>
<p>FileSelectFile (jetzt <a href="lib/FileSelect.htm">FileSelect</a>) hatte zwei Mehrfachauswahlmodi, die über die Optionen 4 und M zugänglich waren. Option 4 und der entsprechende Modus wurden entfernt; sie waren für einige Zeit undokumentiert. FileSelect gibt nun im Mehrfachauswahlmodus ein Array von Pfaden zurück, anstatt einer Zeichenkette wie <code>C:\Verz`nDatei1`nDatei2</code>. Jedes Array-Element enthält den vollständigen Pfad einer Datei. Wenn der Benutzer das Dialogfenster abbricht, ist das Array leer.</p>
<p>FileSelect verwendet jetzt die seit Windows Vista verfügbare IFileDialog-API anstelle der alten GetOpenFileName/GetSaveFileName-API. Dadurch entfällt die Notwendigkeit von (internen) Workarounds, die sich darauf beziehen, dass das Dialogfenster das aktuelle Arbeitsverzeichnis ändert.</p>
<p>FileSelect hat nicht mehr standardmäßig den redundanten Filter "Text Documents (*.txt)", wenn <em>Filter</em> weggelassen wird.</p>
<p>FileSelect entfernt keine Leerzeichen mehr aus dem Filtermuster, wie z.B. bei <code>Muster mit Leerzeichen*.ext</code>. Tests haben gezeigt, dass Leerzeichen auf beiden Seiten des Musters (z.B. nach dem Semikolon in <code>*.cpp; *.h</code>) bereits vom Betriebssystem ignoriert werden, so dass es keine negativen Auswirkungen geben sollte.</p>
<p>FileSelect kann jetzt im "Ordner auswählen"-Modus mit dem Optionsbuchstaben <code>D</code> verwendet werden.</p>
<p><a href="lib/FileSetAttrib.htm">FileSetAttrib</a> überschreibt nun Attribute, wenn kein +, - oder ^ als Präfix vorhanden ist, anstatt nichts zu tun. Zum Beispiel kopiert <code>FileSetAttrib(FileGetAttrib(Datei2), Datei1)</code> die Attribute von Datei2 nach Datei1 (alles was Datei2 hat wird hinzugefügt und alles was Datei2 nicht hat wird entfernt).</p>
<p><a href="lib/FileSetAttrib.htm">FileSetAttrib</a> und <a href="lib/FileSetTime.htm">FileSetTime</a>: Die Parameter <em>OrdnerEinbeziehen</em> und <em>Rekursiv</em> wurden mit einem einzelnen <em>Modus</em>-Parameter ersetzt, der mit dem von <a href="lib/LoopFiles.htm">Loop Files</a> identisch ist. Zum Beispiel <code>FileSetAttrib("+a", "*.zip", "RF")</code> (nur Dateien rekursiv durchwandern).</p>
<p><a href="lib/GetKeyName.htm">GetKeyName</a> gibt jetzt die Nicht-Ziffernblock-Namen für VK-Codes zurück, die sowohl einer Ziffernblock- als auch einer Nicht-Ziffernblock-Taste entsprechen. Zum Beispiel gibt <code>GetKeyName("vk25")</code> Left statt NumpadLeft zurück.</p>
<p><a href="lib/GetKeyState.htm">GetKeyState</a> gibt nun immer 1 oder 0 statt On bzw. Off zurück.</p>
<p><a href="lib/GroupActivate.htm">GroupActivate</a> gibt nun die HWND-Nummer des Fensters zurück, das für die Aktivierung ausgewählt wurde, oder 0, wenn kein passendes Fenster gefunden wurde (abgesehen vom bereits aktiven Fenster), anstatt ErrorLevel zu setzen.</p>
<p><a href="lib/GroupAdd.htm">GroupAdd</a>: Der <em>Label</em>-Parameter und die dazugehörige Funktionalität wurden entfernt. Dies war eine unintuitive Möglichkeit zu erkennen, wenn GroupActivate keine passenden Fenster finden konnte; verwenden Sie stattdessen den Rückgabewert von GroupActivate.</p>
<p><a href="lib/GroupDeactivate.htm">GroupDeactivate</a> selektiert nun Fenster ähnlich der Taskleiste und den System-Hotkeys <kbd>Alt</kbd>+<kbd>Esc</kbd> und <kbd>Alt</kbd>+<kbd>Umschalt</kbd>+<kbd>Esc</kbd>. Konkret heißt das:</p>
<ul>
<li>Untergeordnete Fenster werden nicht evaluiert. Wenn das nicht-untergeordnete Fenster geeignet ist (keine Übereinstimmung für die Gruppe ist), wird entweder das nicht-untergeordnete Fenster oder eines seiner untergeordneten Fenster aktiviert, je nachdem, welches zuletzt aktiv war. Ein Fenster, das einem Gruppenmitglied untergeordnet ist, wird nicht länger aktiviert, aber das Hinzufügen des untergeordneten Fensters selbst zur Gruppe hat jetzt keinen Effekt mehr. (Früher wurden alle untergeordneten Fenster einzeln durchgegangen und nie ihr übergeordnetes Fenster aktiviert.)</li>
<li>Jedes deaktivierte Fenster wird übersprungen, es sei denn, eines seiner untergeordneten Fenster war in jüngerer Zeit aktiv als es selbst.</li>
<li>Fenster mit dem WS_EX_NOACTIVATE-Style werden übersprungen, da sie wahrscheinlich nicht aktiviert werden sollten. Sie werden auch von den System-Hotkeys <kbd>Alt</kbd>+<kbd>Esc</kbd> und <kbd>Alt</kbd>+<kbd>Umschalt</kbd>+<kbd>Esc</kbd> übersprungen.</li>
<li>Fenster mit dem WS_EX_NOACTIVATE-Style, aber nicht mit dem WS_EX_APPWINDOW-Style, werden nicht in der Taskleiste und im Alt-Tab-Fenster angezeigt und entsprechend übersprungen.</li>
</ul>
<p><a href="lib/Hotkey.htm">Hotkey</a> verwendet nicht mehr standardmäßig das <a href="lib/_HotIf.htm">#HotIf</a> (ehemals #If) ganz unten im Skript. Hotkey/Hotstring- und HotIf-Threads verwenden standardmäßig dasselbe Kriterium wie der Hotkey, folglich schaltet <code>Hotkey A_ThisHotkey, "Off"</code> den aktuellen Hotkey aus, selbst wenn er kontextabhängig ist. Alle anderen Threads verwenden standardmäßig die zuletzt im automatischen Ausführungsbereich definierte Einstellung, die wiederum standardmäßig keine Kriterien verwendet (globale Hotkeys).</p>
<p>Der <em>Aktion</em>-Parameter von <a href="lib/Hotkey.htm">Hotkey</a> benötigt nun ein Funktionsobjekt oder den Namen eines Hotkeys. Labels und Funktionsnamen werden nicht mehr unterstützt. Wenn der Name eines Hotkeys angegeben ist, wird die ursprüngliche Funktion dieses Hotkeys verwendet; und im Gegensatz zu früher funktioniert dies mit <a href="lib/_HotIf.htm">#HotIf</a> (ehemals #If).</p>
<ul>
<li>Neben anderen Vorteilen beseitigt dies die Mehrdeutigkeit mit folgenden speziellen Zeichenketten: <code>On</code>, <code>Off</code>, <code>Toggle</code>, <code>AltTab</code>, <code>ShiftAltTab</code>, <code>AltTabAndMenu</code>, <code>AltTabMenuDismiss</code>. Früher wurde das Label oder die Funktion mit diesem Namen verwendet, sofern vorhanden, aber nur, wenn der <em>Label</em>-Parameter weder eine Variablenreferenz noch einen Ausdruck enthielt.</li>
</ul>
<p><a href="lib/Hotkey.htm">Hotkey</a> und <a href="lib/Hotstring.htm">Hotstring</a> unterstützen jetzt die S-Option, um den Hotkey/Hotstring vor <a href="lib/Suspend.htm">Suspend</a> zu schützen (entspricht der neuen Direktive <a href="lib/_SuspendExempt.htm">#SuspendExempt</a>), und die S0-Option, um den Schutz zu deaktivieren.</p>
<p>"Hotkey If" und die anderen If-Unterbefehle wurden in einzelne Funktionen aufgeteilt: <a href="lib/HotIf.htm">HotIf, HotIfWinActive, HotIfWinExist, HotIfWinNotActive, HotIfWinNotExist</a>.</p>
<p><a href="lib/HotIf.htm">HotIf</a> (ehemals "Hotkey If") erkennt nun Ausdrücke, die die Operatoren <code>and</code> oder <code>or</code> verwenden. In v1 funktionierte dies nicht, da diese Operatoren beim Laden des Skripts mit <code>&amp;&amp;</code> oder <code>||</code> ersetzt wurden.</p>
<p><a href="lib/Hotkey.htm">Hotkey</a> hat nicht länger die UseErrorLevel-Option und wird niemals ErrorLevel setzen. Bei Misserfolg wird eine Ausnahme ausgelöst. Die Fehlermeldungen wurden geändert, um konstant (und kürzer) zu sein, mit der Taste oder dem Namen des Hotkeys in <code>Exception.Extra</code>, und mit der Klasse der Ausnahme, die den Grund für den Fehler angibt.</p>
<p><a href="lib/_HotIf.htm">#HotIf</a> (ehemals #If) erstellt jetzt implizit eine Funktion mit einem Parameter (ThisHotkey). Wie alle Funktionen ist auch diese Funktion standardmäßig eine <a href="Functions.htm#AssumeLocal">Assume-Local</a>-Funktion. Der Ausdruck kann lokale Variablen erstellen und globale Variablen lesen, aber nicht direkt globalen Variablen etwas zuweisen, da der Ausdruck keine Deklarationen enthalten kann.</p>
<p>#HotIf wurde so optimiert, dass einfache Aufrufe von <a href="lib/WinActive.htm">WinActive</a> oder <a href="lib/WinExist.htm">WinExist</a> direkt vom Hook-Thread ausgewertet werden können (wie es bei #IfWin in v1 der Fall war und bei <a href="lib/HotIf.htm">HotIfWin</a> immer noch der Fall ist). Dies verbessert die Performanz und verringert das Risiko von Problemen, wenn das Skript beschäftigt ist oder nicht reagiert. Diese Optimierung gilt für Ausdrücke, die einen einzelnen Aufruf von <a href="lib/WinActive.htm">WinActive</a> oder <a href="lib/WinExist.htm">WinExist</a> mit bis zu zwei Parametern enthalten, wobei jeder Parameter eine einfache in Anführungszeichen gesetzte Zeichenkette ist und das Ergebnis optional mit <code>!</code> oder <code>not</code> invertiert wird. Zum Beispiel <code>#HotIf WinActive("Chrome")</code> oder <code>#HotIf !WinExist("Popup")</code>. In solchen Fällen kann der erste Ausdruck mit einer beliebigen Kombination von Kriterien entweder via Ausdruck oder via Fensterkriterien identifiziert werden. Zum Beispiel verweisen <code>HotIf '!WinExist("Popup")'</code> und <code>HotIfWinNotExist "Popup"</code> auf dieselben Hotkey-Varianten.</p>
<p><code>KeyHistory N</code> ändert die Größe des Tastenverlaufspuffers, anstatt den Tastenverlauf anzuzeigen. Dies ersetzt "#KeyHistory N".</p>
<p><a href="lib/ImageSearch.htm">ImageSearch</a> gibt 1 (true) zurück, wenn das Bild gefunden wurde, oder 0 (false), wenn es nicht gefunden wurde, und löst eine Ausnahme aus, wenn die Suche nicht durchgeführt werden konnte. ErrorLevel wird nicht gesetzt.</p>
<p><a href="lib/IniDelete.htm">IniDelete</a>, <a href="lib/IniRead.htm">IniRead</a> und <a href="lib/IniWrite.htm">IniWrite</a> setzen <a href="Variables.htm#LastError">A_LastError</a> auf das Ergebnis der Systemfunktion GetLastError().</p>
<p><a href="lib/IniRead.htm">IniRead</a> löst eine Ausnahme aus, wenn der Schlüssel, die Sektion oder die Datei nicht gefunden werden kann und der <em>Standardwert</em>-Parameter weggelassen wurde. Wenn ein <em>Standardwert</em> angegeben wurde, sogar <code>""</code>, wird keine Ausnahme ausgelöst.</p>
<p><a href="lib/InputHook.htm">InputHook</a> behandelt nun <kbd>Umschalt</kbd>+<kbd>Backspace</kbd> wie <kbd>Backspace</kbd>, anstatt es in <code>`b</code> zu übersetzen.</p>
<p><a href="lib/InputBox.htm">InputBox</a> wurde syntaktisch überarbeitet, um die Benutzerfreundlichkeit zu verbessern (weniger Parameter). Informationen zur Verwendung finden Sie unter <a href="#inputbox">InputBox</a>.</p>
<p><a href="lib/InStr.htm">InStr</a>: Der <em><em>GroßKleinSensitiv</em></em>-Parameter akzeptiert jetzt 0, 1 oder "Locale".</p>
<p>InStr sucht jetzt von rechts nach links, wenn <em>Vorkommen</em> negativ ist (was früher zu einem Ergebnis von 0 führte), und sucht nicht mehr von rechts nach links, wenn eine negative <em>StartPos</em> mit einem positiven <em>Vorkommen</em> verwendet wird. (InStr sucht jedoch weiterhin von rechts nach links, wenn <em>StartPos</em> negativ ist und <em>Vorkommen</em> weggelassen wird.) Dies unterstützt die Rechts-nach-Links-Suche in einer Schleife und ermöglicht es, eine negative <em>StartPos</em> zu verwenden und trotzdem von links nach rechts zu suchen.</p>
<ul>
<li>Zum Beispiel sucht <code>InStr(a, b,, -1, 2)</code> jetzt von links nach rechts. Um stattdessen von rechts nach links zu suchen, verwenden Sie <code>InStr(a, b,, -1, -2)</code>.</li>
<li>Beachten Sie, dass eine <em>StartPos</em> von -1 in AutoHotkey v2 das letzte Zeichen und in AutoHotkey v1 das vorletzte Zeichen repräsentiert. Wenn das obige Beispiel aus v1 stammen würde (statt aus v2.0-a033 bis v2.0-a136), sollte der neue Code <code>InStr(a, b, -2, -2)</code> sein.</li>
</ul>
<p><a href="lib/KeyWait.htm">KeyWait</a> gibt nun 0 (false) zurück, wenn die Wartezeit abgelaufen ist, andernfalls 1 (true). ErrorLevel wurde entfernt.</p>
<p><a href="lib/MouseClick.htm">MouseClick</a> und <a href="lib/MouseClickDrag.htm">MouseClickDrag</a> sind nicht mehr von der Systemeinstellung zum Vertauschen der Maustasten betroffen; "Left" ist immer die primäre Taste und "Right" immer die sekundäre Taste.</p>
<p><a href="lib/MsgBox.htm">MsgBox</a> wurde syntaktisch geändert, um seine häufig verwendeten Parameter zu priorisieren und die Benutzerfreundlichkeit zu verbessern. Informationen zur Verwendung finden Sie unter <a href="#msgbox">MsgBox</a> weiter unten.</p>
<p><a href="lib/NumPut.htm">NumPut</a>/<a href="lib/NumGet.htm">NumGet</a>: Bei der direkten Übergabe einer Variable wird die Adresse des internen Zeichenkettenpuffers der Variable nicht länger verwendet. Daher kann eine Variable, die eine Adresse enthält, direkt übergeben werden (während in v1 so etwas wie <code>var+0</code> notwendig war). Zum Reservieren von Pufferspeicher ist das neue <a href="lib/Buffer.htm">Buffer-Objekt</a> einer Variable vorzuziehen; jedes Objekt kann verwendet werden, solange es die <em>Ptr</em>- und <em>Size</em>-Eigenschaft hat.</p>
<p>Die Parameter von NumPut wurden neu angeordnet, um die Angabe einer Sequenz von Werten zu ermöglichen, wobei jeder Zahl eine Zeichenkette vorangestellt werden muss, die den Typ der Zahl angibt. Zum Beispiel: <code>NumPut("ptr", a, "int", b, "int", c, addrOrBuffer, offset)</code>. Auch der Typ-Parameter von NumGet kann nicht mehr weggelassen werden. (Im Vergleich zu <a href="lib/DllCall.htm">DllCall</a> entsprechen die Eingabeparameter von NumPut den Parametern der DLL-Funktion, während der Rückgabetypparameter von NumGet der Rückgabetypzeichenkette der DLL-Funktion entspricht.)</p>
<p>Die Verwendung von <code>Object(obj)</code> und <code>Object(ptr)</code> zum Umwandeln zwischen einer Referenz und einem Pointer sind nun separate Funktionen: <code>ObjPtrAddRef(obj)</code> und <code>ObjFromPtrAddRef(ptr)</code>. Es gibt auch Versionen dieser Funktionen, die die Referenzanzahl nicht inkrementieren:  <code>ObjPtr(obj)</code> und <code>ObjFromPtr(ptr)</code>.</p>
<p>Das OnClipboardChange-Label wird nicht mehr automatisch aufgerufen, wenn es vorhanden ist. Verwenden Sie stattdessen die <a href="lib/OnClipboardChange.htm">OnClipboardChange</a>-Funktion, die es seit v1.1.20 gibt. Sie benötigt nun ein Funktionsobjekt, keinen Namen.</p>
<p><a href="lib/OnError.htm">OnError</a> benötigt nun ein Funktionsobjekt, keinen Namen. Siehe auch <a href="#error-handling">Fehlerbehandlung</a> weiter unten.</p>
<p>Der OnExit-Befehl wurde entfernt; verwenden Sie stattdessen die <a href="lib/OnExit.htm">OnExit</a>-Funktion, die es seit v1.1.20 gibt. Sie benötigt nun ein Funktionsobjekt, keinen Namen. A_ExitReason wurde ebenfalls entfernt; der entsprechende Wert kann nun über einen Parameter der OnExit-Rückruffunktion abgerufen werden.</p>
<p><a href="lib/OnMessage.htm">OnMessage</a> hat nicht mehr den Eine-Funktion-pro-Meldung-Modus, der verwendet wurde, wenn ein Funktionsname (Zeichenkette) übergeben wurde; es akzeptiert jetzt nur eine Funktion via Referenz. Verwenden Sie <code>OnMessage(x, MeineFunk)</code>, wobei <em>MeineFunk</em> der Name einer Funktion ist (ohne Anführungszeichen), aber beachten Sie, dass das v1-Äquivalent <code>OnMessage(x, Func("MeineFunk"))</code> wäre, das im Gegensatz zu <code>OnMessage(x, "MeineFunk")</code> anderen Funktionen erlaubt, die Meldung x weiter zu überwachen. Um die Überwachung der Meldung zu beenden, verwenden Sie <code>OnMessage(x, MeineFunk, 0)</code>, da <code>OnMessage(x, "")</code> und <code>OnMessage(x)</code> nun Fehler sind. Bei Misserfolg wird OnMessage eine Ausnahme auslösen.</p>
<p><a href="lib/Pause.htm">Pause</a> wird nicht länger von <a href="lib/_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> ausgeschlossen, wenn es in der ersten Zeile eines Hotkeys verwendet wird, folglich ist <code>#p::Pause</code> nicht mehr zum Umschalten von Pause geeignet. <code>Pause()</code> pausiert nun nur den aktuellen Thread (für Kombinationen wie ListVars/Pause), während <code>Pause(Wert)</code> nun immer den darunter liegenden Thread als pausiert markiert. <em>Wert</em> muss 0, 1 oder -1 sein. Der zweite Parameter wurde entfernt.</p>
<p><a href="lib/PixelSearch.htm">PixelSearch</a> und <a href="lib/PixelGetColor.htm">PixelGetColor</a> verwenden RGB- statt BGR-Werte, um mit anderen Funktionen konsistent zu sein. Beide Funktionen lösen eine Ausnahme aus, wenn ein Problem auftritt, und setzen keinen ErrorLevel mehr. PixelSearch gibt 1 (true) zurück, wenn die Farbe gefunden wurde. Der langsame Modus von PixelSearch wurde entfernt, da er auf den meisten modernen Systemen wegen Inkompatibilität mit der Desktopgestaltung unbrauchbar ist.</p>
<p><a href="lib/PostMessage.htm">PostMessage</a>: Siehe <a href="#SendMessage">SendMessage</a> weiter unten.</p>
<p><a href="lib/Random.htm">Random</a> wurde überarbeitet, um den Zufallszahlengenerator des Betriebssystems zu nutzen, einige Einschränkungen zu beseitigen und die Verwendung zu vereinfachen.</p>
<ul>
<li>Es unterstützt nun den vollen 64-Bit-Bereich von vorzeichenfähigen Integerwerten (früher war es 32-Bit).</li>
<li>Floating-Point-Zahlen werden auf Basis eines zufälligen 53-Bit-Integers anstelle eines zufälligen 32-Bit-Integers generiert und sollten größer gleich <em>Min</em> und kleiner als <em>Max</em> sein (allerdings können Floating-Point-Rundungsfehler theoretisch dazu führen, dass sie gleich <em>Max</em> sind).</li>
<li>Die Parameter konnten bereits in beliebiger Reihenfolge angegeben werden, aber jetzt wird bei Angabe nur des ersten Parameters der andere Grenzwert auf 0 gesetzt, anstatt auf 2147483647. Zum Beispiel gibt <code>Random(9)</code> eine Zahl im Bereich von 0 bis 9 zurück.</li>
<li>Wenn beide Parameter weggelassen werden, ist der Rückgabewert eine Floating-Point-Zahl im Bereich von 0.0 bis 1.0 (wobei 1.0 nahezu nie erreicht wird) anstelle eines Integers im Bereich von 0 bis 2147483647.</li>
<li>Das System setzt den Zufallszahlengenerator automatisch zurück (fachsprachlich Reseeding genannt) und bietet keine Möglichkeit für ein manuelles Reseeding, folglich gibt es keinen Ersatz für den <em>NeuerSeed</em>-Parameter.</li>
</ul>
<p>Die <a href="lib/RegExMatch.htm">RegExMatch</a>-Optionen O und P wurden entfernt; der O-Modus (Objekt) ist nun immer aktiv. Das RegExMatch-Objekt unterstützt nun Enumeration (For-Schleife). Die Syntax des Match-Objekts hat sich geändert:</p>
<ul>
<li>__Get wird verwendet, um die Kurzform <code>Match.TeilMust</code> zu implementieren, wobei <em>TeilMust</em> der Name eines Teilsuchmusters (erfassten Gruppe) ist. Da __Get nicht mehr aufgerufen wird, wenn eine Eigenschaft <em>geerbt</em> wird, können die folgenden Teilsuchmusternamen nicht mehr mit der Kurzform verwendet werden: Pos, Len, Name, Count, Mark. (Zum Beispiel gibt <code>Match.Len</code> immer die Länge der gesamten Übereinstimmung zurück, nicht eine erfasste Zeichenkette.)</li>
<li>Ursprünglich hatte das Match-Objekt Methoden statt Eigenschaften, so dass Eigenschaften für Teilsuchmusternamen reserviert werden konnten. Da das neue Sprachverhalten impliziert, dass <code>Match.Name</code> standardmäßig eine Funktion zurückgibt, wurden die Methoden mit Eigenschaften ersetzt oder ergänzt:
<ul>
<li>Pos, Len und Name sind jetzt Eigenschaften und Methoden.</li>
<li>Name benötigt jetzt einen Parameter, um Verwirrung zu vermeiden (<code>Match.Name</code> löst einen Fehler aus).</li>
<li>Count und Mark sind jetzt nur noch Eigenschaften.</li>
<li>Value wurde entfernt; verwenden Sie <code>Match.0</code> oder <code>Match[]</code> statt <code>Match.Value()</code>, und <code>Match[N]</code> statt <code>Match.Value(N)</code>.</li>
</ul>
</li>
</ul>
<p>RegisterCallback wurde in <a href="lib/CallbackCreate.htm">CallbackCreate</a> umbenannt und zugunsten von <a href="Functions.htm#closures">Closures</a> verbessert:</p>
<ul>
<li>Es unterstützt nun <a href="misc/Functor.htm">Funktionsobjekte</a> (aber keine Funktionsnamen mehr).</li>
<li>Der <em>EventInfo</em>-Parameter wurde entfernt (verwenden Sie stattdessen ein <a href="Functions.htm#closures">Closure</a> oder eine <a href="misc/Functor.htm#BoundFunc">Bound-Funktion</a>).</li>
<li>Das spezielle Verhalten von variadischen Rückruffunktionen wurde entfernt und die <code>&amp;</code>-Option hinzugefügt (Adresse der Parameterliste übergeben).</li>
<li><code>CallbackFree(Adresse)</code> wurde hinzugefügt, um den Rückrufspeicher und das zugehörige Funktionsobjekt freizugeben.</li>
</ul>
<p>Registry-Funktionen (<a href="lib/RegRead.htm">RegRead</a>, <a href="lib/RegWrite.htm">RegWrite</a>, <a href="lib/RegDelete.htm">RegDelete</a>): Die in v1.1.21 eingeführte Syntax ist nun die einzige Syntax. RootSchlüssel und UnterSchlüssel wurden zusammengefasst. Schreiben Sie <code>RootSchlüssel\UnterSchlüssel</code> statt <code>RootSchlüssel, UnterSchlüssel</code>. Für den Zugriff auf eine Remote-Registry muss <code>\\ComputerName\RootSchlüssel\UnterSchlüssel</code> statt <code>\\ComputerName:RootSchlüssel, UnterSchlüssel</code> verwendet werden.</p>
<p>Die Parameter von RegWrite wurden neu angeordnet, so dass <em>Wert</em> der erste Parameter ist, wie bei IniWrite (dies hat aber keinen Einfluss auf den Einzelparametermodus, wo <em>Wert</em> der einzige Parameter war).</p>
<p>Wenn <em>SchlüsselName</em> weggelassen wird und das aktuelle Loop-Reg-Element ein Unterschlüssel ist, arbeiten RegDelete, RegRead und RegWrite nun mit den Werten innerhalb dieses Unterschlüssels, d.h. <em>SchlüsselName</em> ist in diesem Fall standardmäßig <code>A_LoopRegKey "\" A_LoopRegName</code> (beachten Sie, dass A_LoopRegKey mit A_LoopRegSubKey zusammengeführt wurde). Früher verhielten sie sich wie folgt:</p>
<ul>
<li>RegRead las einen Wert mit dem gleichen Namen wie der Unterschlüssel, wenn ein solcher im übergeordneten Schlüssel vorhanden war.</li>
<li>RegWrite gab einen Fehler zurück.</li>
<li>RegDelete löschte den Unterschlüssel.</li>
</ul>
<p>RegDelete, RegRead und RegWrite erlauben nun die Angabe von <em>WertName</em>, wenn <em>SchlüsselName</em> weggelassen wird:</p>
<ul>
<li>Wenn das aktuelle Loop-Reg-Element ein Unterschlüssel ist, ist <em>WertName</em> standardmäßig leer (d.h. der Standardwert des Unterschlüssels wird verwendet) und <em>WertTyp</em> muss angegeben werden.</li>
<li>Wenn das aktuelle Loop-Reg-Element ein Wert ist, sind <em>WertName</em> und <em>WertTyp</em> standardmäßig der Name und Typ des Wertes, die einzeln oder beide überschrieben werden können.</li>
</ul>
<p>Andernfalls löscht RegDelete mit leerem oder weggelassenem <em>WertName</em> nun den Standardwert des Schlüssels (nicht den Schlüssel selbst), um mit RegWrite, RegRead und A_LoopRegName konsistent zu sein. Das Schlüsselwort "AHK_DEFAULT" hat keine besondere Bedeutung mehr. Mit <a href="lib/RegDeleteKey.htm">RegDeleteKey</a> (neu) kann ein Schlüssel gelöscht werden.</p>
<p><a href="lib/RegRead.htm">RegRead</a> hat jetzt wie IniRead einen <em>Standardwert</em>-Parameter.</p>
<p>RegRead hatte einen undokumentierten 5-Parameter-Modus, bei dem der Werttyp nach der Ausgabevariable angegeben werden konnte. Dieser wurde entfernt.</p>
<p><a href="lib/Reload.htm">Reload</a> macht nun nichts mehr, wenn das Skript aus der Standardeingabe (stdin) gelesen wurde.</p>
<p><a href="lib/Run.htm">Run</a> und <a href="lib/Run.htm">RunWait</a> ignorieren nun die UseErrorLevel-Option, da ErrorLevel entfernt wurde. Verwenden Sie stattdessen <a href="lib/Try.htm">Try</a>/<a href="lib/Catch.htm">Catch</a>. <a href="Variables.htm#LastError">A_LastError</a> wird bedingungslos gesetzt und kann nach dem Abfangen/Unterdrücken einer Ausnahme inspiziert werden. RunWait gibt den Exitcode zurück.</p>
<p><a href="lib/Send.htm">Send</a> (und seine Varianten) interpretieren jetzt <code>{LButton}</code> und <code>{RButton}</code> konsistent zu Hotkeys und <a href="lib/Click.htm">Click</a>. Das heißt, dass LButton die primäre Taste und RButton die sekundäre Taste ist, auch dann, wenn der Benutzer die Maustasten über die Systemsteuerung vertauscht hat.</p>
<p id="SendMessage"><a href="lib/SendMessage.htm">SendMessage</a> und <a href="lib/PostMessage.htm">PostMessage</a>: Die wParam- und lParam-Parameter müssen nun Integer oder Objekte mit einer Ptr-Eigenschaft sein; es wird eine Ausnahme ausgelöst, wenn ihnen eine nicht-numerische Zeichenkette oder Floating-Point-Zahl zugewiesen wird. Früher wurde eine Zeichenkette via Adresse übergeben, wenn der Ausdruck mit <code>"</code> begann, aber andere Zeichenketten wurden zwangsweise in Integer umgewandelt. Die Übergabe der Adresse einer Variable (früher <code>&amp;var</code>, jetzt <code>StrPtr(var)</code>) aktualisiert nicht mehr die Länge der Variable (verwenden Sie stattdessen <code>VarSetStrCapacity(&amp;var, -1)</code>).</p>
<p>SendMessage und PostMessage lösen jetzt bei Misserfolg (oder Zeitüberschreitung) eine Ausnahme aus und setzen keinen ErrorLevel mehr. SendMessage gibt die Antwort der Meldung zurück.</p>
<p><a href="lib/SetTimer.htm">SetTimer</a> unterstützt keine Label- oder Funktionsnamen mehr, aber da es jetzt einen Ausdruck akzeptiert und Funktionen direkt über ihren Namen referenziert werden können, ist die Verwendung sehr ähnlich: <code>SetTimer MeineFunk</code>. Wie bei allen Funktionen, die ein Objekt akzeptieren, erlaubt SetTimer nun die Angabe von Ausdrücken, die ein Objekt zurückgeben (früher war eine Variablenreferenz erforderlich).</p>
<p><a href="lib/Sort.htm">Sort</a> wurde wie folgt geändert:</p>
<ul>
<li>Der <em>VarName</em>-Parameter wurde aus Flexibilitätsgründen in separate Ein-/Ausgabeparameter aufgeteilt. Die Verwendung ist nun <code>Ausgabe := Sort(Eingabe [, Optionen, Rückruf])</code>.</li>
<li>Wenn zwei Elemente gleich sind, wird jetzt automatisch die ursprüngliche Reihenfolge der Elemente als Entscheidungshilfe verwendet, um stabilere Ergebnisse zu gewährleisten.</li>
<li>Die <code>C</code>-Option akzeptiert jetzt auch ein Suffix äquivalent zum <em>GroßKleinSensitiv</em>-Parameter anderer Funktionen (zusätzlich zu <code>CL</code>): <code>CLocale CLogical COn C1 COff C0</code>. Die wichtigste Neuerung ist die Unterstützung des "logischen" Vergleichsmodus.</li>
</ul>
<p id="Sound"><a href="lib/Sound.htm">Sound-Funktionen</a>: SoundGet und SoundSet wurden überarbeitet, um sie besser an die Sound-APIs von Windows Vista und höher anzupassen, auf Kosten der XP-Unterstützung.</p>
<ul>
<li>Nicht unterstützte Regler wurden entfernt.</li>
<li>Alte Mixerkomponententypen wurden entfernt.</li>
<li>Komponenten können jetzt via Name und/oder Index referenziert werden.</li>
<li>Geräte können jetzt via Name+Präfix und/oder Index referenziert werden.</li>
<li>Beide Funktionen wurden in Volume- und Mute-Funktionen aufgeteilt.</li>
<li><a href="lib/SoundGetName.htm">SoundGetName</a> wurde hinzugefügt, um Geräte- oder Komponentennamen abzurufen.</li>
<li><a href="lib/SoundGetInterface.htm">SoundGetInterface</a> wurde hinzugefügt, um COM-Interfaces abzurufen.</li>
</ul>
<p><a href="lib/StrGet.htm">StrGet</a>: Wenn <em>Länge</em> negativ ist, bestimmt dessen Absolutwert die genaue Anzahl der Zeichen, die umgewandelt werden, einschließlich aller binären Nullen, die die Zeichenkette eventuell enthält, d.h. das Ergebnis wird immer eine Zeichenkette mit exakt dieser Länge sein. Wenn <em>Länge</em> positiv ist, endet die umgewandelte Zeichenkette bei der ersten binären Null (wie in v1).</p>
<p><a href="lib/StrGet.htm">StrGet</a>/<a href="lib/StrPut.htm">StrPut</a>: Der <em>Adresse</em>-Parameter kann ein Objekt mit den Eigenschaften <em>Ptr</em> und <em>Size</em> sein, wie z.B. das neue <a href="lib/Buffer.htm">Buffer-Objekt</a>. Das Lesen/Schreiben wird automatisch via <em>Size</em> begrenzt (in Bytes). Wenn auch <em>Length</em> angegeben ist, darf es nicht größer als <em>Size</em> (multipliziert mit 2 bei UTF-16) sein.</p>
<p>Der Rückgabewert von StrPut ist nun in Bytes, so dass er direkt an <code>Buffer()</code> übergeben werden kann.</p>
<p><a href="lib/StrReplace.htm">StrReplace</a> hat jetzt einen <em>GroßKleinSensitiv</em>-Parameter anstelle von <em>AusgabeVarAnzahl</em>, der um einen Parameter nach rechts verschoben wurde, mit <em>Limit</em> dahinter.</p>
<p><a href="lib/Suspend.htm">Suspend</a>: Ein Hotkey oder Hotstring, der in seiner ersten Zeile Suspend aufruft, ist nicht länger vor einer Suspension geschützt. Verwenden Sie stattdessen <code>#SuspendExempt</code> oder die <code>S</code>-Option. Der Parameterwert "Permit" ist nicht mehr gültig.</p>
<p><a href="lib/Switch.htm">Switch</a> vergleicht Zeichenketten nun standardmäßig Groß-/Kleinschreibung-sensitiv und hat einen <em>GroßKleinSensitiv</em>-Parameter, der den Modus der Groß-/Kleinschreibung-Sensitivität überschreibt und einen Zeichenkettenvergleich (anstelle eines numerischen Vergleichs) erzwingt. Früher war der Vergleich nur Groß-/Kleinschreibung-sensitiv, wenn StringCaseSense eingeschaltet war.</p>
<p><a href="lib/SysGet.htm">SysGet</a> hat jetzt nur noch numerische Unterbefehle; alle anderen Unterbefehle sind nun separate Funktionen. Einzelheiten finden Sie unter <a href="#sub-commands">Unterbefehle</a> weiter unten.</p>
<p><a href="lib/TrayTip.htm">TrayTip</a>: Die Verwendung ist nun <code>TrayTip [Text, Titel, Optionen]</code>. <em>Optionen</em> ist eine Zeichenkette von beliebig vielen Optionen (nicht Groß-/Kleinschreibung-sensitiv), jeweils getrennt durch ein Leer- oder Tabulatorzeichen. Die Optionen sind <code>Iconx</code>, <code>Icon!</code>, <code>Iconi</code>, <code>Mute</code> und/oder ein numerischer Wert wie früher. TrayTip wird jetzt auch angezeigt, wenn <em>Text</em> weggelassen wird (was nun im Gegensatz zu v1 seltener versehentlich passieren kann). Der <em>Zeitlimit</em>-Parameter existiert nicht mehr (er funktionierte ohnehin nicht in Windows Vista oder höher). Skripte können nun die Flags NIIF_USER (0x4) und NIIF_LARGE_ICON (0x20) kombiniert verwenden (0x24), um die große Version des Tray-Symbols in der Benachrichtigung anzuzeigen. NIIF_USER (0x4) kann auch allein für das kleine Symbol verwendet werden, was aber je nach System variieren kann.</p>
<p>#Warn UseUnsetLocal und UseUnsetGlobal wurden entfernt, da das Lesen einer ungesetzten Variable nun einen Fehler auslöst. <a href="lib/IsSet.htm">IsSet</a> kann verwendet werden, um den Fehler zu vermeiden, und <a href="lib/Try.htm">Try</a>/<a href="lib/Catch.htm">Catch</a> oder <a href="lib/OnError.htm">OnError</a> können verwendet werden, um den Fehler zu behandeln.</p>
<p><a href="lib/_Warn.htm#VarUnset">#Warn VarUnset</a> wurde hinzugefügt und verwendet standardmäßig den MsgBox-Modus. Sofern nicht deaktiviert, wird vor Beginn der Skriptausführung eine Warnung angezeigt, wenn die jeweils erste Referenz zu einer Variable nie als Ziel einer direkten nicht-dynamischen Zuweisung verwendet wird, nie mit dem Referenzoperator (&amp;) verwendet wird oder nie direkt an IsSet übergeben wird.</p>
<p><a href="lib/_Warn.htm#Unreachable">#Warn Unreachable</a> behandelt Zeilen nach einem <a href="lib/Exit.htm">Exit</a>-Aufruf nicht mehr als unerreichbar, da Exit jetzt eine normale Funktion ist.</p>
<p>#Warn ClassOverwrite wurde entfernt, da Top-Level-Klassen nicht mehr durch Zuweisung überschrieben werden können. (Allerdings können sie nun implizit von einer lokalen Variable "überschrieben" werden; dies kann mit #Warn LocalSameAsGlobal erkannt werden.)</p>
<p><a href="lib/WinActivate.htm">WinActivate</a> sendet nun <code>{Alt up}</code> nach dem ersten gescheiterten Versuch, ein Fenster zu aktivieren. Tests haben gezeigt, dass dadurch die Chance verringert wird, dass die Taskleistenschaltflächen aufblinken. Weitere Einzelheiten finden Sie in der Dokumentation.</p>
<p><a href="lib/WinClose.htm">WinClose</a> und <a href="lib/WinKill.htm">WinKill</a>: Die Angabe von 0 für <em>Wartezeit</em> entspricht nicht länger der Angabe von 0.5; stattdessen wird die kleinstmögliche Wartezeit erzeugt.</p>
<p><a href="lib/WinSetTitle.htm">WinSetTitle</a> und <a href="lib/WinMove.htm">WinMove</a> haben nun eine Parameterreihenfolge, die mit anderen Win-Funktionen konsistent ist, d.h. <em>FensterTitel, FensterText, AusnahmeTitel, AusnahmeText</em> werden immer zusammen in dieser Reihenfolge verwendet (am Ende der Parameterliste), um das Einprägen der Parameter zu fördern.</p>
<p>Der <em>FensterTitel</em>-Parameter der meisten Funktionen akzeptiert nun eine HWND-Nummer (muss ein reiner Integer sein) oder ein Objekt mit einer <em>Hwnd</em>-Eigenschaft wie z.B. ein <a href="lib/Gui.htm">Gui-Objekt</a>. <a href="lib/DetectHiddenWindows.htm">DetectHiddenWindows</a> wird in solchen Fällen ignoriert, außer bei Verwendung mit <a href="lib/WinWait.htm">WinWait</a> oder <a href="lib/WinWaitClose.htm">WinWaitClose</a>.</p>
<p><a href="lib/WinMove.htm">WinMove</a> hat keine spezielle Behandlung mehr für das Wort <code class="no-highlight">DEFAULT</code>. Lassen Sie den Parameter stattdessen weg oder geben Sie eine leere Zeichenkette an (funktioniert sowohl in v1 als auch in v2).</p>
<p><a href="lib/WinWait.htm">WinWait</a>, <a href="lib/WinWaitClose.htm">WinWaitClose</a>, <a href="lib/WinWaitActive.htm">WinWaitActive</a> und <a href="lib/WinWaitActive.htm">WinWaitNotActive</a> geben einen Wert ungleich Null zurück, wenn sie aufgehört haben zu warten (das Zeitlimit nicht überschritten wurde). ErrorLevel wurde entfernt. WinWait und WinWaitActive geben die HWND-Nummer des gefundenen Fensters zurück. WinWaitClose setzt nun das <a href="misc/WinTitle.htm#LastFoundWindow">Zuletzt Gefundene Fenster</a>, d.h. bei Zeitüberschreitung gibt WinWaitClose 0 (false) und <code>WinExist()</code> das von WinWaitClose gefundene Fenster zurück. Die Angabe von 0 für <em>Zeitlimit</em> entspricht nicht länger der Angabe von 0.5; stattdessen wird die kleinstmögliche Wartezeit erzeugt.</p>
<p><strong>Unsortiert:</strong></p>
<p>Eine negative <em>StartPos</em> bei <a href="lib/InStr.htm">InStr</a>, <a href="lib/SubStr.htm">SubStr</a>, <a href="lib/RegExMatch.htm">RegExMatch</a> und <a href="lib/RegExReplace.htm">RegExReplace</a> wird als Position ausgehend vom Ende interpretiert. Position -1 ist das letzte Zeichen und Position 0 ist ungültig (während in v1 Position 0 das letzte Zeichen war).</p>
<p>Funktionen, die früher On/Off oder On/Off/Toggle (aber keine anderen Zeichenketten) akzeptierten, benötigen nun stattdessen 1/0/-1. On und Off werden typischerweise mit <code>True</code> bzw. <code>False</code> ersetzt. Variablen, die On/Off zurückgegeben haben, geben jetzt 1/0 zurück, was in Ausdrücken nützlicher ist.</p>
<ul>
<li><a href="lib/_UseHook.htm">#UseHook</a> und <a href="lib/_MaxThreadsBuffer.htm">#MaxThreadsBuffer</a> erlauben <code>1</code>, <code>0</code>, <code>True</code> und <code>False</code>. (Im Gegensatz zu den anderen unterstützen sie keine Ausdrücke.)</li>
<li><a href="lib/ListLines.htm">ListLines</a> erlaubt weggelassen oder boolesch.</li>
<li><a href="lib/ControlSetChecked.htm">ControlSetChecked</a>, <a href="lib/ControlSetEnabled.htm">ControlSetEnabled</a>, <a href="lib/Pause.htm">Pause</a>, <a href="lib/Suspend.htm">Suspend</a>, <a href="lib/WinSetAlwaysOnTop.htm">WinSetAlwaysOnTop</a> und <a href="lib/WinSetEnabled.htm">WinSetEnabled</a> erlauben <code>1</code>, <code>0</code> und <code>-1</code>.</li>
<li><a href="Variables.htm#DetectHiddenWindows">A_DetectHiddenWindows</a>, <a href="Variables.htm#DetectHiddenText">A_DetectHiddenText</a>, und <a href="Variables.htm#StoreCapsLockMode">A_StoreCapsLockMode</a> verwenden boolesche Werte (äquivalent zu den entsprechenden Funktionen).</li>
</ul>
<p>Die folgenden Funktionen geben einen reinen Integer anstelle einer hexadezimalen Zeichenkette zurück:</p>
<ul>
<li><a href="lib/ControlGetStyle.htm">ControlGetExStyle</a></li>
<li><a href="lib/ControlGetHwnd.htm">ControlGetHwnd</a></li>
<li><a href="lib/ControlGetStyle.htm">ControlGetStyle</a></li>
<li><a href="lib/MouseGetPos.htm">MouseGetPos</a></li>
<li><a href="lib/WinActive.htm">WinActive</a></li>
<li><a href="lib/WinExist.htm">WinExist</a></li>
<li><a href="lib/WinGetID.htm">WinGetID</a></li>
<li><a href="lib/WinGetIDLast.htm">WinGetIDLast</a></li>
<li><a href="lib/WinGetList.htm">WinGetList</a> (innerhalb des Arrays)</li>
<li><a href="lib/WinGetStyle.htm">WinGetStyle</a></li>
<li><a href="lib/WinGetStyle.htm">WinGetStyleEx</a></li>
<li><a href="lib/WinGetControlsHwnd.htm">WinGetControlsHwnd</a> (innerhalb des Arrays)</li>
</ul>
<p><a href="Variables.htm#ScriptHwnd">A_ScriptHwnd</a> gibt ebenfalls einen reinen Integer zurück.</p>
<h4 id="dllcall">DllCall</h4>
<p>Wenn ein Typ-Parameter eine Variable ist, wird immer der Inhalt dieser Variable verwendet, niemals ihr Name. Mit anderen Worten, anführungszeichenlose Typnamen werden nicht mehr unterstützt - die Typnamen müssen in Anführungszeichen gesetzt werden.</p>
<p>Wenn DllCall die Länge einer Zeichenkette aktualisiert, die als Str oder WStr übergeben wurde, erkennt DllCall nun, wenn die Zeichenkette nicht korrekt nullterminiert wurde (was wahrscheinlich auf einen Pufferüberlauf schließen lässt), und terminiert in diesem Fall das Programm mit einer Fehlermeldung, da eine sichere Ausführung nicht mehr garantiert werden kann.</p>
<p><code>AStr</code> (ohne irgendein Suffix) darf nur noch für Eingabeparameter verwendet werden. Da der Puffer immer nur so groß sein kann wie die Eingabezeichenkette, war AStr für Ausgabeparameter meist nicht sinnvoll. Dies würde für WStr statt AStr gelten, wenn AutoHotkey für ANSI kompiliert ist, aber offizielle v2-Versionen werden immer nur für Unicode kompiliert.</p>
<p>Wenn eine Funktion eine neue Adresse in einen <code>Str*</code>-, <code>AStr*</code>- oder <code>WStr*</code>-Parameter schreibt, wird DllCall nun die neue Zeichenkette der entsprechenden Variable zuweisen, falls eine bereitgestellt wurde, anstatt nur die Länge der ursprünglichen Zeichenkette zu aktualisieren (die sich wahrscheinlich nicht geändert hat). Parameter dieses Typs werden normalerweise nicht verwendet, um die Eingabezeichenkette zu ändern, sondern um eine Zeichenkette an eine neue Adresse zurückzugeben.</p>
<p>DllCall akzeptiert nun ein Objekt für jeden <code>Ptr</code>-Parameter und den <em>Funktion</em>-Parameter; das Objekt muss eine <em>Ptr</em>-Eigenschaft haben. Zum Reservieren von Pufferspeicher ist das neue <a href="lib/Buffer.htm">Buffer-Objekt</a> einer Variable vorzuziehen. Im Falle von <code>Ptr*</code> wird der neue Wert des Parameters wieder der <em>Ptr</em>-Eigenschaft des Objekts zugewiesen. Dies ermöglicht Konstrukte wie <code>DllCall(..., "Ptr*", unk := IUnknown())</code> statt <code>DllCall(..., "Ptr*", punk), unk := IUnknown(punk)</code>, und kann verwendet werden, um sicherzustellen, dass jede Ausgabe der Funktion ordnungsgemäß freigegeben wird (selbst wenn eine Ausnahme aufgrund des Rückgabetyps <code>HRESULT</code> ausgelöst wird, obwohl die Funktion in diesem Fall normalerweise keinen Nicht-Null-Pointer ausgeben würde).</p>
<p>DllCall verlangt nun, dass die Werte von Parametern numerischen Typs numerisch sein müssen, und löst eine Ausnahme aus, wenn eine nicht-numerische oder leere Zeichenkette übergeben wurde. Insbesondere wenn das Suffix * oder P für Ausgabeparameter verwendet wird, dann muss die Ausgabevariable initialisiert werden.</p>
<p>Der Ausgabewert (falls vorhanden) von numerischen Parametern mit dem Suffix * oder P wird ignoriert, wenn das Skript eine einfache Variable übergibt, die eine Zahl enthält. Um den Ausgabewert zu erhalten, übergeben Sie eine <a href="Concepts.htm#variable-references">VarRef</a> wie <code>&amp;meineVar</code> oder ein Objekt mit einer <em>Ptr</em>-Eigenschaft.</p>
<p>Der neue Rückgabetyp <code>HRESULT</code> löst eine Ausnahme aus, wenn die Funktion fehlschlägt (<code>int &lt; 0</code> oder <code>uint &amp; 0x80000000</code>). Dies sollte nur bei Funktionen verwendet werden, die tatsächlich ein <code>HRESULT</code> zurückgeben.</p>
<h4 id="loop-sub-commands">Loop-Unterbefehle</h4>
<p>Das Unterbefehlschlüsselwort muss direkt geschrieben werden; es darf weder in Anführungszeichen stehen noch eine Variable oder ein Ausdruck sein. Alle anderen Parameter sind Ausdrücke. Alle Loop-Unterbefehle unterstützen nun <a href="lib/Block.htm#otb">OTB</a>.</p>
<p>Entfernt:</p>
<pre class="no-highlight">Loop, DateiMuster [, OrdnerEinbeziehen, Rekursiv]
Loop, RootSchlüssel [, Schlüssel, UnterschlüsselEinbeziehen, Rekursiv]
</pre>
<p>Verwenden Sie stattdessen folgendes (verfügbar seit v1.1.21):</p>
<pre>Loop Files, DateiMuster [, Modus]
Loop Reg SchlüsselName [, Modus]
</pre>
<p>Das Komma nach dem zweiten Wort ist jetzt optional.</p>
<p><a href="lib/LoopReg.htm#vars">A_LoopRegKey</a> enthält nun den Root-Schlüssel und Unterschlüssel, außerdem wurde A_LoopRegSubKey entfernt.</p>
<h4 id="inputbox">InputBox</h4>
<pre>InputBoxObj := InputBox([Anzeigetext, Titel, Optionen, Standardwert])
</pre>
<p>Der <em>Optionen</em>-Parameter akzeptiert eine Zeichenkette von beliebig vielen Optionen (nicht Groß-/Kleinschreibung-sensitiv), jeweils getrennt durch ein Leer- oder Tabulatorzeichen, ähnlich den Gui-Steuerelement-Optionen. Das folgende Beispiel enthält alle unterstützten Optionen: <code>"x0 y0 w100 h100 T10.0 Password*"</code>. <code>T</code> ist Timeout (Zeitlimit); <code>Password</code> wird genauso verwendet wie die äquivalente Edit-Steuerelement-Option.</p>
<p>Die Optionen für Breite und Höhe bestimmen nun die Größe des Clientbereichs (das ist der Bereich ohne Titelleiste und Fensterrahmen), folglich sind sie weniger vom Design abhängig.</p>
<p>Der Titel ist leer, wenn der <em>Titel</em>-Parameter eine leere Zeichenkette ist. Der Titel ist standardmäßig nur <a href="Variables.htm#ScriptName">A_ScriptName</a>, wenn der Parameter komplett weggelassen wird, konsistent mit optionalen Parametern von benutzerdefinierten Funktionen.</p>
<p><em>InputBoxObj</em> ist ein Objekt mit den Eigenschaften <em>Result</em> (enthält "OK", "Cancel" oder "Timeout") und <em>Value</em>.</p>
<h4 id="msgbox">MsgBox</h4>
<pre>Ergebnis := MsgBox([Text, Titel, Optionen])
</pre>
<p>Der <em>Optionen</em>-Parameter akzeptiert eine Zeichenkette von beliebig vielen Optionen (nicht Groß-/Kleinschreibung-sensitiv), jeweils getrennt durch ein Leer- oder Tabulatorzeichen, ähnlich den Gui-Steuerelement-Optionen.</p>
<ul>
<li><code>Iconx</code>, <code>Icon?</code>, <code>Icon!</code> und <code>Iconi</code> setzen das Symbol.</li>
<li><code class="no-highlight">Default</code> gefolgt von einem Integer macht die <em>n</em>-te Schaltfläche zur Standardschaltfläche.</li>
<li><code>T</code> gefolgt von einem Integer oder einer Floating-Point-Zahl setzt den Timeout in Sekunden.</li>
<li><code>Owner</code> gefolgt von einer HWND-Nummer setzt das übergeordnete Fenster und überschreibt die <code>+OwnDialogs</code>-Gui-Option.</li>
<li>Die folgenden (sich gegenseitig ausschließenden) Zeichenketten bestimmen, welche Schaltflächen angezeigt werden: <code>OK</code>, <code>OKCancel</code>, <code>AbortRetryIgnore</code>, <code>YesNoCancel</code>, <code>YesNo</code>, <code>RetryCancel</code>, <code>CancelTryAgainContinue</code>, oder einfach die Initialen, mit oder ohne Schrägstriche (z.B. <code>o/c</code> oder <code>yn</code>).</li>
<li>Ein numerischer Wert, wie bei v1. Numerische Werte können mit Zeichenkettenoptionen kombiniert werden, oder <em>Optionen</em> kann ein reiner Integer sein.</li>
</ul>
<p>Der Rückgabewert ist der englische Name der Schaltfläche ohne Leerzeichen. Diese Zeichenketten sind dieselben, die bei IfMsgBox in v1 verwendet wurden.</p>
<p>Der Titel ist leer, wenn der <em>Titel</em>-Parameter eine leere Zeichenkette ist. Der Titel ist standardmäßig nur <a href="Variables.htm#ScriptName">A_ScriptName</a>, wenn der Parameter komplett weggelassen wird, konsistent mit optionalen Parametern von benutzerdefinierten Funktionen.</p>
<h4 id="sub-commands">Unterbefehle</h4>
<p>Die Unterbefehle von Control, ControlGet, Drive, DriveGet, WinGet, WinSet und Process wurden durch einzelne Funktionen ersetzt, und die Hauptbefehle wurden entfernt. Die Namen und die Verwendung einiger Funktionen wurden geändert. Diese Funktionen werden nun wie folgt verwendet:</p>
<pre><em>; Die "..." sind die optionalen Parameter Steuerelement, FensterTitel, etc.</em>

Bool   := ControlGetChecked(...)
Bool   := ControlGetEnabled(...)
Bool   := ControlGetVisible(...)
Int    := ControlGetIndex(...)  <em>; Für Tab, LB, CB, DDL</em>
Zkette := ControlGetChoice(...)
Arr    := ControlGetItems(...)
Int    := ControlGetStyle(...)
Int    := ControlGetExStyle(...)
Int    := ControlGetHwnd(...)

          ControlSetChecked(TrueFalseToggle, ...)
          ControlSetEnabled(TrueFalseToggle, ...)
          ControlShow(...)
          ControlHide(...)
          ControlSetStyle(Wert, ...)
          ControlSetExStyle(Wert, ...)
          ControlShowDropDown(...)
          ControlHideDropDown(...)
          ControlChooseIndex(Index, ...)  <em>; Deckt auch Tab ab</em>
Index  := ControlChooseString(Zkette, ...)

Index  := ControlFindItem(Zkette, ...)
Index  := ControlAddItem(Zkette, ...)
          ControlDeleteItem(Index, ...)

Int    := EditGetLineCount(...)
Int    := EditGetCurrentLine(...)
Int    := EditGetCurrentCol(...)
Zkette := EditGetLine(N [, ...])
Zkette := EditGetSelectedText(...)
          EditPaste(Zkette, ...)

Zkette := ListViewGetContent([Optionen, ...])

          DriveEject([Laufw])
          DriveRetract([Laufw])
          DriveLock(Laufw)
          DriveUnlock(Laufw)
          DriveSetLabel(Laufw [, Label])

Zkette := DriveGetList([Typ])
Zkette := DriveGetFilesystem(Laufw)
Zkette := DriveGetLabel(Laufw)
Zkette := DriveGetSerial(Laufw)
Zkette := DriveGetType(Pfad)
Zkette := DriveGetStatus(Pfad)
Zkette := DriveGetStatusCD(Laufw)
Int    := DriveGetCapacity(Pfad)
Int    := DriveGetSpaceFree(Pfad)

<em>; Die "..." sind die optionalen Parameter FensterTitel, etc.</em>

Int    := WinGetID(...)
Int    := WinGetIDLast(...)
Int    := WinGetPID(...)
Zkette := WinGetProcessName(...)
Zkette := WinGetProcessPath(...)
Int    := WinGetCount(...)
Arr    := WinGetList(...)
Int    := WinGetMinMax(...)
Arr    := WinGetControls(...)
Arr    := WinGetControlsHwnd(...)
Int    := WinGetTransparent(...)
Zkette := WinGetTransColor(...)
Int    := WinGetStyle(...)
Int    := WinGetExStyle(...)

          WinSetTransparent(N [, ...])
          WinSetTransColor("Farbe [N]" [, ...]),
          WinSetAlwaysOnTop([TrueFalseToggle := 1, ...])
          WinSetStyle(Wert [, ...])
          WinSetExStyle(Wert [, ...])
          WinSetEnabled(Wert [, ...])
          WinSetRegion(Wert [, ...])

          WinRedraw(...)
          WinMoveBottom(...)
          WinMoveTop(...)

PID    := ProcessExist([PID_oder_Name])
PID    := ProcessClose(PID_oder_Name)
PID    := ProcessWait(PID_oder_Name [, Timeout])
PID    := ProcessWaitClose(PID_oder_Name [, Timeout])

          ProcessSetPriority(Priority [, PID_oder_Name])
</pre>
<p><a href="lib/ProcessExist.htm">ProcessExist</a>, <a href="lib/ProcessClose.htm">ProcessClose</a>, <a href="lib/ProcessWait.htm">ProcessWait</a> und <a href="lib/ProcessWaitClose.htm">ProcessWaitClose</a> setzen keinen ErrorLevel mehr; sie geben stattdessen die PID zurück.</p>
<p>Keine der anderen Funktionen setzt ErrorLevel. Stattdessen lösen sie bei Misserfolg eine Ausnahme aus. In den meisten Fällen ist ein Misserfolg darauf zurückzuführen, dass das Zielfenster oder -steuerelement nicht gefunden wurde.</p>
<p>HWND-Nummern und Styles werden immer als reine Integer zurückgegeben, nicht als hexadezimale Zeichenketten.</p>
<p><a href="lib/ControlChooseIndex.htm">ControlChooseIndex</a> akzeptiert 0, um alle Elemente abzuwählen. Es ersetzt "Control Choose", unterstützt aber auch Tab-Steuerelemente.</p>
<p>"ControlGet Tab" wurde mit <a href="lib/ControlGetIndex.htm">ControlGetIndex</a> zusammengeführt, das auch mit ListBox, ComboBox und DDL funktioniert. Bei Tab-Steuerelementen gibt es 0 zurück, wenn kein Tab ausgewählt ist (selten, aber möglich). <a href="lib/ControlChooseIndex.htm">ControlChooseIndex</a> erlaubt keine 0 für Tab-Steuerelemente, da Anwendungen in der Regel nicht damit umgehen können.</p>
<p><a href="lib/ControlGetItems.htm">ControlGetItems</a> ersetzt "ControlGet List" für ListBox und ComboBox. Es gibt ein Array zurück.</p>
<p><a href="lib/DriveEject.htm">DriveEject</a> und <a href="lib/DriveEject.htm">DriveRetract</a> verwenden jetzt DeviceIoControl anstelle von mciSendString. DriveEject kann dadurch Nicht-CD/DVD-Laufwerke auswerfen, die eine "Auswerfen"-Option im Explorer haben (d.h. Wechseldatenträger, aber keine externen Festplatten).</p>
<p><a href="lib/ListViewGetContent.htm">ListViewGetContent</a> ersetzt "ControlGet List" für ListView und wird aktuell genauso verwendet wie früher.</p>
<p><a href="lib/WinGetList.htm">WinGetList</a>, <a href="lib/WinGetControls.htm">WinGetControls</a> und <a href="lib/WinGetControlsHwnd.htm">WinGetControlsHwnd</a> geben Arrays zurück, keine zeilenumbruchgetrennte Liste.</p>
<p><a href="lib/WinSetTransparent.htm">WinSetTransparent</a> behandelt <code>""</code> als <code>"Off"</code> und nicht als <code>0</code> (was das Fenster unsichtbar und unklickbar machen würde).</p>
<p>Abkürzungen wie Topmost, Trans, FS und Cap wurden entfernt.</p>
<p>Die folgenden Funktionen waren früher Unterbefehle von <a href="lib/SysGet.htm">SysGet</a>:</p>
<pre>AktuelleN := MonitorGet([N, &amp;Links, &amp;Oben, &amp;Rechts, &amp;Unten])
AktuelleN := MonitorGetWorkArea([N, &amp;Links, &amp;Oben, &amp;Rechts, &amp;Unten])
Anzahl    := MonitorGetCount()
Primär    := MonitorGetPrimary()
Name      := MonitorGetName([N])
</pre>
<h3 id="new-functions">Neue Funktionen</h3>
<p><code>Buffer([ByteAnzahl, FüllByte])</code> (Aufruf der Buffer-Klasse) erzeugt und gibt ein <code>Buffer</code>-Objekt zurück, das einen Bereich im Speicher mit einer Größe von <em>ByteAnzahl</em> Bytes beansprucht, der nur initialisiert ist, wenn <em>FüllByte</em> angegeben ist. <code>BufferObj.Ptr</code> gibt die Adresse zurück. <code>BufferObj.Size</code> gibt die Größe in Bytes zurück oder setzt sie (und reserviert den Bereich des Speichers neu). Es kann ein beliebiges Objekt mit einer <em>Ptr</em>- und <em>Size</em>-Eigenschaft an <a href="lib/NumPut.htm">NumPut</a>, <a href="lib/NumGet.htm">NumGet</a>, <a href="lib/StrPut.htm">StrPut</a>, <a href="lib/StrGet.htm">StrGet</a>, <a href="lib/File.htm#RawRead">File.RawRead</a>, <a href="lib/File.htm#RawWrite">File.RawWrite</a> und <a href="lib/FileAppend.htm">FileAppend</a> übergeben werden. Es kann ein beliebiges Objekt mit einer <em>Ptr</em>-Eigenschaft an <a href="lib/DllCall.htm">DllCall</a>-Parametern vom Typ <code>Ptr</code>, <a href="lib/SendMessage.htm">SendMessage</a> und <a href="lib/PostMessage.htm">PostMessage</a> übergeben werden.</p>
<p><code>CaretGetPos([&amp;OutputVarX, &amp;OutputVarY])</code> ruft die aktuellen Koordinaten des Textcursors (Texteinfügemarke) ab. Dies stellt sicher, dass die X- und Y-Koordinate immer übereinstimmen und dass es kein Caching gibt, das zu unerwartetem Verhalten führt (z.B. wenn A_CaretX/Y einen Wert zurückgibt, der nicht im aktuellen Koordinatenmodus ist).</p>
<p><code>ClipboardAll([Daten, Größe])</code> erstellt ein Objekt mit allem, was in der Zwischenablage enthalten ist (und akzeptiert optional Daten, die vorher aus der Zwischenablage abgerufen wurden, anstatt den aktuellen Inhalt der Zwischenablage zu verwenden). Die Methoden zum Lesen und Schreiben von Zwischenablagedateidaten sind unterschiedlich. Das Datenformat ist das gleiche, außer dass die Datengröße immer 32-Bit ist, so dass die Daten zwischen 32-Bit- und 64-Bit-Builds portierbar sind. Einzelheiten finden Sie in der v2-Dokumentation.</p>
<p><code>ComCall(offset, comobj, ...)</code> ist äquivalent zu <code>DllCall(NumGet(NumGet(comobj.ptr) + offset * A_Index), "ptr", comobj.ptr, ...)</code>, aber standardmäßig mit dem Rückgabetyp <code>HRESULT</code> anstelle von <code>Int</code>.</p>
<p><a href="lib/ComObject.htm">ComObject</a> (ehemals ComObjCreate) und <a href="lib/ComObjQuery.htm">ComObjQuery</a> geben jetzt ein Wrapper-Objekt zurück, auch dann, wenn eine IID angegeben ist. ComObjQuery erlaubt für den ersten Parameter ein beliebiges Objekt mit einer <em>Ptr</em>-Eigenschaft.</p>
<p><a href="lib/ControlGetClassNN.htm">ControlGetClassNN</a> gibt die ClassNN-Bezeichnung eines bestimmten Steuerelements zurück.</p>
<p><a href="lib/ControlSend.htm">ControlSendText</a>, das äquivalent zu ControlSendRaw ist, aber den Text- statt Raw-Modus verwendet.</p>
<p><code>DirExist(DateiMuster)</code>, das so ähnlich wie FileExist verwendet wird. Beachten Sie, dass eine Platzhalterprüfung wie <code>InStr(FileExist("MeinOrdner\*"), "D")</code>, wobei <em>MeinOrdner</em> Dateien und Unterordner enthält, nur mitteilt, ob die <u>erste</u> gefundene Datei ein Ordner ist, nicht ob ein Ordner existiert.</p>
<p><code>Float(Wert)</code>: Siehe <a href="#types">Typen</a> weiter oben.</p>
<p><code>InstallKeybdHook([Installieren, Erzwingen])</code> und <code>InstallMouseHook([Installieren, Erzwingen])</code> ersetzen die entsprechenden Direktiven, für erhöhte Flexibilität.</p>
<p><code>Integer(Wert)</code>: Siehe <a href="#types">Typen</a> weiter oben.</p>
<p id="isXXX"><a href="lib/Is.htm">IsXXX</a>: Der Legacy-Befehl "if Var is Typ" wurde durch mehrere Funktionen ersetzt: IsAlnum, IsAlpha, IsDigit, IsFloat, IsInteger, IsLower, IsNumber, IsSpace, IsUpper, IsXDigit. Außer IsFloat, IsInteger und IsNumber lösen alle eine Ausnahme aus, wenn der Parameter keine Zeichenkette ist, da eine implizite Umwandlung in eine Zeichenkette zu kontraproduktiven Ergebnissen führen kann.</p>
<p><code>IsSet(Var)</code>, <code>IsSetRef(&amp;Ref)</code>: Gibt 1 (true) zurück, wenn der Variable ein Wert zugewiesen wurde (auch wenn dieser Wert eine leere Zeichenkette ist), andernfalls 0 (false). Bei 0 (false) würde der Versuch, die Variable innerhalb eines Ausdrucks zu lesen, einen Fehler auslösen.</p>
<p><code>Menu()</code>/<code>MenuBar()</code> gibt ein neues Menu/MenuBar-Objekt zurück, das die folgenden Elemente analog zu den v1-Menu-Unterbefehlen enthält. Methoden: <a href="lib/Menu.htm#Add">Add</a>, <a href="lib/Menu.htm#AddStandard"><strong>Add</strong>Standard</a>, <a href="lib/Menu.htm#Check">Check</a>, <a href="lib/Menu.htm#Delete">Delete</a>, <a href="lib/Menu.htm#Disable">Disable</a>, <a href="lib/Menu.htm#Enable">Enable</a>, <a href="lib/Menu.htm#Insert">Insert</a>, <a href="lib/Menu.htm#Rename">Rename</a>, <a href="lib/Menu.htm#SetColor"><strong>Set</strong>Color</a>, <a href="lib/Menu.htm#SetIcon"><strong>Set</strong>Icon</a>, <a href="lib/Menu.htm#Show">Show</a>, <a href="lib/Menu.htm#ToggleCheck">ToggleCheck</a>, <a href="lib/Menu.htm#ToggleEnable">ToggleEnable</a>, <a href="lib/Menu.htm#Uncheck">Uncheck</a>. Eigenschaften: <a href="lib/Menu.htm#ClickCount">Click<strong>Count</strong></a>, <a href="lib/Menu.htm#Default">Default</a>, <a href="lib/Menu.htm#Handle">Handle</a> (ersetzt MenuGetHandle). <a href="Variables.htm#TrayMenu">A_TrayMenu</a> gibt ebenfalls ein Menu-Objekt zurück. Es gibt keinen UseErrorLevel-Modus, keine globalen Menünamen, und kein explizites Löschen des Menüs selbst (dies geschieht, wenn alle Referenzen freigegeben werden; die <a href="lib/Menu.htm#Delete">Delete</a>-Methode ist äquivalent zu DeleteAll von v1). Labels werden nicht unterstützt, nur Funktionsobjekte. Die <a href="lib/Menu.htm#AddStandard">AddStandard</a>-Methode fügt die vordefinierten Menüpunkte hinzu und ermöglicht es, diese wie benutzerdefinierte Menüpunkte individuell zu ändern. Im Gegensatz zu v1 wird das Win32-Menü nur zerstört, wenn das Objekt gelöscht wird.</p>
<p><code>MenuFromHandle(Handle)</code> ruft ein Menu- oder MenuBar-Objekt über dessen Win32-Menü-Handle ab, wenn es von AutoHotkey erstellt wurde.</p>
<p><code>Number(Wert)</code>: Siehe <a href="#types">Typen</a> weiter oben.</p>
<p><code>Persistent([Persistieren])</code> ersetzt die entsprechende Direktive, was die Flexibilität erhöht.</p>
<p><code>RegDeleteKey([SchlüsselName])</code> löscht einen Registry-Schlüssel. (RegDelete löscht jetzt nur noch Werte, außer wenn alle Parameter in einer Registry-Schleife weggelassen werden.)</p>
<p><a href="lib/Send.htm#SendText">SendText</a>, das äquivalent zu SendRaw ist, aber den Text- statt Raw-Modus verwendet.</p>
<p><code>StrCompare(Zkette1, Zkette2 [, GroßKleinSensitiv])</code> gibt -1 (Zkette1 kleiner als Zkette2), 0 (gleich) oder 1 (größer als) zurück. <em>GroßKleinSensitiv</em> kann "Locale" sein.</p>
<p><code>String(Wert)</code>: Siehe <a href="#types">Typen</a> weiter oben.</p>
<p><code>StrPtr(Wert)</code> gibt die Adresse einer Zeichenkette zurück. Im Gegensatz zum Adressoperator von v1 kann dies mit direkt geschriebenen Zeichenketten und temporären Zeichenketten verwendet werden.</p>
<p><code>SysGetIPAddresses()</code> gibt ein Array von IP-Adressen zurück, äquivalent zu den entfernten A_IPAddress-Variablen. Jede Referenz zu <code>A_IPAddress%N%</code> rief alle Adressen ab, gab aber nur eine zurück, so dass das Abrufen mehrerer Adressen exponentiell länger dauerte als nötig. Das zurückgegebene Array kann beliebig viele Elemente enthalten.</p>
<p><code>TraySetIcon([DateiName, SymbolNummer, Einfrieren])</code> ersetzt "Menu Tray, Icon".</p>
<p><code>VarSetStrCapacity(&amp;ZielVar [, GewünschteKapazität])</code> ersetzt die v1-Funktion VarSetCapacity, ist aber nur für die Verwendung mit UTF-16-Zeichenketten vorgesehen (z.B. um Mehrfachverkettungen zu optimieren); folglich sind <em>GewünschteKapazität</em> und der Rückgabewert in Zeichen, nicht in Bytes.</p>
<p><code>VerCompare(A, B)</code> vergleicht zwei Versionszeichenketten mit dem gleichen Algorithmus wie <a href="lib/_Requires.htm">#Requires</a>.</p>
<p><code>WinGetClientPos([&amp;AusX, &amp;AusY, &amp;AusBreite, &amp;AusHöhe, FensterTitel, ...])</code> ruft die Position und Größe des Clientbereichs eines Fensters ab, in Bildschirmkoordinaten.</p>
<h3 id="new-directives">Neue Direktiven</h3>
<p><code>#DllLoad [DateiOderVerzName]</code>: Lädt eine DLL- oder EXE-Datei vor Beginn der Skriptausführung.</p>
<h3 id="built-in-variables">Interne Variablen</h3>
<p><a href="Variables.htm#AhkPath">A_AhkPath</a> gibt immer den Pfad der aktuellen EXE-Datei oder des Interpreters zurück, auch dann, wenn das Skript kompiliert ist. Früher wurde der Pfad des kompilierten Skripts zurückgegeben, wenn eine BIN-Datei als Basisdatei verwendet wurde, aber v2.0-Releases enthalten keine BIN-Dateien mehr.</p>
<p><a href="Variables.htm#IsCompiled">A_IsCompiled</a> gibt 0 statt "" zurück, wenn das Skript nicht kompiliert ist.</p>
<p><a href="Variables.htm#OSVersion">A_OSVersion</a> gibt immer eine Zeichenkette im Format <code>Haupt.Neben.Build</code> zurück, z.B. <code>6.1.7601</code> für Windows 7 SP1. A_OSType wurde entfernt, da nur NT-basierte Systeme unterstützt wurden.</p>
<p><a href="Variables.htm#TimeSincePriorHotkey">A_TimeSincePriorHotkey</a> gibt "" statt -1 zurück, wenn <a href="Variables.htm#PriorHotkey">A_PriorHotkey</a> "" ist. <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a> gibt "" statt -1 zurück, wenn <a href="Variables.htm#ThisHotkey">A_ThisHotkey</a> "" ist.</p>
<p>Alle internen "virtuellen" Variablen haben jetzt das <code>A_</code>-Präfix (Einzelheiten finden Sie unten). Alle vordefinierten Variablen ohne dieses Präfix (z.B. <code>Object</code>) sind nur globale Variablen. Die Unterscheidung kann wichtig sein, da es derzeit nicht möglich ist, eine virtuelle Variable zu referenzieren (außer wenn sie direkt an eine interne Funktion übergeben wird); <a href="Variables.htm#Args">A_Args</a> ist jedoch keine virtuelle Variable.</p>
<p>Interne Variablen, die Zahlen zurückgeben, geben diese jetzt als <a href="Concepts.htm#numbers">Integer</a> statt als <a href="Concepts.htm#strings">Zeichenkette</a> zurück.</p>
<p>Umbenannt:</p>
<ul>
<li>A_LoopFileFullPath → <a href="lib/LoopFiles.htm#LoopFilePath">A_LoopFilePath</a> (gibt einen relativen Pfad zurück, wenn der Parameter von Loop relativ war, daher war "FullPath" irreführend)</li>
<li>A_LoopFileLongPath → <a href="lib/LoopFiles.htm#LoopFileFullPath">A_LoopFileFullPath</a></li>
<li>Clipboard → <a href="lib/A_Clipboard.htm">A_Clipboard</a></li>
</ul>
<p>Entfernt:</p>
<ul>
<li>ClipboardAll (ersetzt durch die <a href="lib/ClipboardAll.htm">ClipboardAll</a>-Funktion)</li>
<li>ComSpec (verwenden Sie stattdessen <a href="Variables.htm#ComSpec">A_ComSpec</a>)</li>
<li>ProgramFiles (verwenden Sie stattdessen <a href="Variables.htm#ProgramFiles">A_ProgramFiles</a>)</li>
<li>A_AutoTrim</li>
<li>A_BatchLines</li>
<li>A_CaretX, A_CaretY (verwenden Sie stattdessen <a href="lib/CaretGetPos.htm">CaretGetPos</a>)</li>
<li>A_DefaultGui, A_DefaultListView, A_DefaultTreeView</li>
<li>A_ExitReason</li>
<li>A_FormatFloat</li>
<li>A_FormatInteger</li>
<li>A_Gui, A_GuiControl, A_GuiControlEvent, A_GuiEvent, A_GuiX, A_GuiY, A_GuiWidth, A_GuiHeight (alle ersetzt durch Parameter von <a href="lib/GuiOnEvent.htm">Ereignishandlern</a>)</li>
<li>A_IPAddress1, A_IPAddress2, A_IPAddress3, A_IPAddress4 (verwenden Sie stattdessen <a href="lib/SysGetIPAddresses.htm">SysGetIPAddresses</a>)</li>
<li>A_IsUnicode (v2 ist immer Unicode; es kann mit <code>StrLen(Chr(0xFFFF))</code> ersetzt oder mit <code>global A_IsUnicode := 1</code> neu definiert werden)</li>
<li>A_StringCaseSense</li>
<li>A_ThisLabel</li>
<li>A_ThisMenu, A_ThisMenuItem, A_ThisMenuItemPos (verwenden Sie stattdessen die <a href="lib/Menu.htm#Add">Parameter der Menüpunkt-Rückruffunktion</a>)</li>
<li>A_LoopRegSubKey (<a href="lib/LoopReg.htm#vars">A_LoopRegKey</a> enthält nun den Root-Schlüssel und Unterschlüssel)</li>
<li>True und False (existieren noch, sind aber jetzt Schlüsselwörter, keine Variablen)</li>
</ul>
<p>Hinzugefügt:</p>
<ul>
<li><a href="Variables.htm#AllowMainWindow">A_AllowMainWindow</a> (Lesen/Schreiben; ersetzt "Menu Tray, MainWindow/NoMainWindow")</li>
<li><a href="Variables.htm#HotkeyInterval">A_HotkeyInterval</a> (ersetzt #HotkeyInterval)</li>
<li><a href="Variables.htm#HotkeyModifierTimeout">A_HotkeyModifierTimeout</a> (ersetzt #HotkeyModifierTimeout)</li>
<li><a href="Variables.htm#InitialWorkingDir">A_InitialWorkingDir</a> (siehe <a href="#default-settings">Standardeinstellungen</a> weiter unten)</li>
<li><a href="Variables.htm#MaxHotkeysPerInterval">A_MaxHotkeysPerInterval</a> (ersetzt #MaxHotkeysPerInterval)</li>
<li><a href="Variables.htm#MenuMaskKey">A_MenuMaskKey</a> (ersetzt #MenuMaskKey)</li>
</ul>
<p>Den folgenden internen Variablen können Werte zugewiesen werden:</p>
<ul>
<li><a href="Variables.htm#ControlDelay">A_ControlDelay</a></li>
<li><a href="Variables.htm#CoordMode">A_CoordMode..</a></li>
<li><a href="Variables.htm#DefaultMouseSpeed">A_DefaultMouseSpeed</a></li>
<li><a href="Variables.htm#DetectHiddenText">A_DetectHiddenText</a> (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li><a href="Variables.htm#DetectHiddenWindows">A_DetectHiddenWindows</a> (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li><a href="Variables.htm#EventInfo">A_EventInfo</a></li>
<li><a href="Variables.htm#FileEncoding">A_FileEncoding</a> (gibt nun auch "CP0" statt "" zurück, außerdem kann ein Integer ohne CP-Präfix zugewiesen werden)</li>
<li><a href="Variables.htm#IconHidden">A_IconHidden</a></li>
<li><a href="Variables.htm#IconTip">A_IconTip</a> (außerdem spiegelt es nun immer den Tooltip wider, auch wenn es Standard oder leer ist)</li>
<li><a href="Variables.htm#Index">A_Index</a>: Bei endlichen Schleifen wirkt sich die Änderung dieser Variable darauf aus, wie viele Wiederholungen durchgeführt werden. (Die Globalität von internen Variablen ermöglicht es einer Enumerator-Funktion, den Index für eine For-Schleife sichtbar zu machen.)</li>
<li><a href="Variables.htm#KeyDelay">A_KeyDelay</a></li>
<li><a href="Variables.htm#KeyDelayPlay">A_KeyDelayPlay</a></li>
<li><a href="Variables.htm#KeyDelay">A_KeyDuration</a></li>
<li><a href="Variables.htm#KeyDelayPlay">A_KeyDurationPlay</a></li>
<li><a href="Variables.htm#LastError">A_LastError</a>: Ruft die Win32-Funktion SetLastError() auf. Außerdem wird jetzt ein vorzeichenloser Wert zurückgegeben.</li>
<li><a href="Variables.htm#ListLines">A_ListLines</a></li>
<li><a href="Variables.htm#MouseDelay">A_MouseDelay</a></li>
<li><a href="Variables.htm#MouseDelay">A_MouseDelayPlay</a></li>
<li><a href="Variables.htm#RegView">A_RegView</a></li>
<li><a href="Variables.htm#ScriptName">A_ScriptName</a>: Ändert den Standardtitel von Dialogfenstern.</li>
<li><a href="Variables.htm#SendLevel">A_SendLevel</a></li>
<li><a href="Variables.htm#SendMode">A_SendMode</a></li>
<li><a href="Variables.htm#StoreCapsLockMode">A_StoreCapsLockMode</a> (gibt nun auch 1 oder 0 statt "On" oder "Off" zurück)</li>
<li><a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a></li>
<li><a href="Variables.htm#TitleMatchModeSpeed">A_TitleMatchModeSpeed</a></li>
<li><a href="Variables.htm#WinDelay">A_WinDelay</a></li>
<li><a href="Variables.htm#WorkingDir">A_WorkingDir</a>: Entspricht dem Aufruf von <a href="lib/SetWorkingDir.htm">SetWorkingDir</a>.</li>
</ul>
<h3 id="built-in-objects">Interne Objekte</h3>
<p><a href="lib/File.htm">File-Objekte</a> erfordern jetzt strikt die Eigenschaftssyntax für den Aufruf von Eigenschaften und die Methodensyntax für den Aufruf von Methoden. Zum Beispiel ist <code>FileObj.Pos(n)</code> ungültig. Es wird eine Ausnahme ausgelöst, wenn zu wenige oder zu viele Parameter vorhanden sind oder wenn einer schreibgeschützten Eigenschaft ein Wert zugewiesen wird.</p>
<p>File.Tell() wurde entfernt.</p>
<p><a href="lib/Func.htm#IsByRef">Func.IsByRef()</a> funktioniert nun mit internen Funktionen.</p>
<h2 id="gui">Gui</h2>
<p>Gui, GuiControl und GuiControlGet wurden durch <a href="lib/Gui.htm#Call">Gui()</a> und <a href="lib/Gui.htm">Gui</a>/<a href="lib/GuiControl.htm">GuiControl</a>-Objekte ersetzt, die in der Regel flexibler, konsistenter und leichter zu bedienen sind.</p>
<p>Eine GUI wird typischerweise nicht via Name/Nummer referenziert (obwohl sie immer noch mit <code>GuiObj.Name</code> benannt werden kann). Stattdessen wird ein GUI-Objekt (und Fenster) explizit durch Instanziierung der <code>Gui</code>-Klasse erstellt, wie in <code>GuiObj := Gui()</code>. Dieses Objekt hat Methoden und Eigenschaften, die die Gui-Unterbefehle ersetzen. <a href="lib/Gui.htm#Add">Gui.Add()</a> gibt ein GuiControl-Objekt zurück, das Methoden und Eigenschaften hat, die die GuiControl- und GuiControlGet-Befehle ersetzen. Dieses Objekt kann in eine Variable gespeichert oder mit <code>GuiObj["Name"]</code> oder <a href="lib/GuiCtrlFromHwnd.htm">GuiCtrlFromHwnd</a> abgerufen werden. Es wird auch als Parameter übergeben, wenn ein Ereignishandler (der g-Label-Ersatz) aufgerufen wird.</p>
<p>Die Verwendung dieser Methoden und Eigenschaften ist nicht 1:1. Vieles wurde überarbeitet, um konsistenter und flexibler zu sein und um Fehler oder Einschränkungen zu beheben.</p>
<p>Es gibt keine Standard-GUIs, da das zu verwendende Gui- oder GuiControl-Objekt immer angegeben ist. LV/TV/SB-Funktionen wurden durch Methoden (des GuiControl-Objekts) ersetzt, so dass es viel einfacher ist, mehrere ListViews/TreeViews zu verwenden.</p>
<p>Es gibt keine internen Variablen, die Informationen über Ereignisse enthalten. Stattdessen werden die Informationen als Parameter an die ereignisbehandelnde Funktion/Methode übergeben, einschließlich des Gui- oder GuiControl-Objekts.</p>
<p>Steuerelemente können weiterhin benannt und via Name referenziert werden. Dies ist jedoch nur ein Name (der mit <code>GuiObj["Name"]</code> und <a href="lib/Gui.htm#Submit">Gui.Submit()</a> verwendet wird), keine zugeordnete Variable, daher müssen keine globalen oder statischen Variablen deklariert oder erstellt werden. Der Wert wird nie automatisch in eine Variable gespeichert, kann aber über <a href="lib/GuiControl.htm#Value">GuiControl.Value</a> abgerufen oder gesetzt werden. <a href="lib/Gui.htm#Submit">Gui.Submit()</a> gibt ein neues assoziatives Array zurück, das die Namen der Steuerelemente als Schlüssel verwendet.</p>
<p>Die <code>v<i>Name</i></code>-Option setzt nun nur noch den Namen des Steuerelements auf <em>Name</em>.</p>
<p>Die <code>+Hwnd<i>VarName</i></code>-Option wurde zugunsten von <a href="lib/GuiControl.htm#Hwnd">GuiControl.Hwnd</a> entfernt.</p>
<p>Es gibt keine "g-Labels" oder Labels/Funktionen mehr, die GUI-Ereignisse automatisch behandeln. Das Skript muss für jedes gewünschte Ereignis eine Rückruffunktion registrieren, indem es die <a href="lib/GuiOnEvent.htm">OnEvent</a>-Methode des Gui oder GuiControl aufruft. Anstatt z.B. <code>if (A_GuiEvent = "I" &amp;&amp; InStr(ErrorLevel, "F", true))</code> in einem g-Label zu prüfen, registriert das Skript einen Handler für das <a href="lib/GuiOnEvent.htm#ItemFocus">ItemFocus</a>-Ereignis: <code>MeineLV.OnEvent("ItemFocus", MeineFunktion)</code>. <em>MeineFunktion</em> würde nur für das ItemFocus-Ereignis aufgerufen werden. Die <code>AltSubmit</code>-Option ist nicht mehr erforderlich, um zusätzliche Ereignisse zu erkennen.</p>
<p>Arrays werden überall dort verwendet, wo zuvor eine via Vertikalstrich getrennte Liste verwendet wurde, z.B. um die Listeneinträge für eine ListBox anzugeben, wenn die ListBox erstellt wird, wenn Einträge hinzugefügt werden oder wenn die ausgewählten Einträge abgerufen werden.</p>
<p>Skripte können eine Klasse definieren, die <code>Gui</code> erweitert und ihre eigenen Ereignisse behandelt, wobei die gesamte GUI-Logik in sich geschlossen bleibt.</p>
<h3 id="gui-sub-commands">Gui-Unterbefehle</h3>
<p><strong>Gui New</strong> → <a href="lib/Gui.htm#Call">Gui()</a>. Die Übergabe einer leeren Zeichenkette bewirkt, dass nicht der Standardtitel, sondern ein leerer Titel angezeigt wird.</p>
<p><strong>Gui Add</strong> → <a href="lib/Gui.htm#Add">Gui.Add() oder Gui.Add<em>Steuerelement</em>()</a>; z.B. <code>GuiObj.Add("Edit")</code> oder <code>GuiObj.AddEdit()</code>.</p>
<p><strong>Gui Show</strong> → <a href="lib/Gui.htm#Show">Gui.Show()</a>, aber ohne <em>Titel</em>-Parameter. Der Titel kann via Parameter von Gui() oder via Gui.Title-Eigenschaft angegeben werden. Der initiale Fokus wird immer noch auf das erste eingabefähige Steuerelement mit dem WS_TABSTOP-Style gesetzt (gemäß der Standardmeldungsverarbeitung des Systems), es sei denn, es handelt sich um ein Button-Steuerelement, dann wird der Fokus jetzt auf die Standardschaltfläche verschoben.</p>
<p><strong>Gui Submit</strong> → <a href="lib/Gui.htm#Submit">Gui.Submit()</a>. Funktioniert wie früher, außer dass Submit() ein neues Objekt erstellt und zurückgibt, das alle "zugeordneten Variablen" enthält.</p>
<p><strong>Gui Destroy</strong> → <a href="lib/Gui.htm#Destroy">Gui.Destroy()</a>. Das Objekt existiert weiterhin (bis es vom Skript freigegeben wird), kann aber nicht verwendet werden. Es muss eine neue GUI erstellt werden (falls erforderlich). Das Fenster wird auch zerstört, wenn das Objekt gelöscht wird, aber das Objekt wird "am Leben gehalten", solange das Fenster sichtbar ist.</p>
<p><strong>Gui Font</strong> → <a href="lib/Gui.htm#SetFont">Gui.SetFont()</a>. Mit GuiControl.SetFont() kann auch direkt die Schriftart eines Steuerelements gesetzt werden.</p>
<p><strong>Gui Color</strong> → <a href="lib/Gui.htm#BackColor">Gui.BackColor</a> setzt oder gibt die Hintergrundfarbe zurück. <em>SteuerelementFarbe</em> (der zweite Parameter) wird nicht unterstützt, aber bei allen Steuerelementen, die diesen Parameter früher unterstützt haben, kann stattdessen der Hintergrund via <code>+Background</code>-Option geändert werden. Im Gegensatz zu "Gui Color" hat Gui.BackColor keinen Einfluss auf Progress-Steuerelemente oder deaktivierte/schreibgeschützte TreeView- (mit <code>-Theme</code>), Edit-, DDL- oder ComboBox-Steuerelemente.</p>
<p><strong>Gui Margin</strong> → die Eigenschaften <a href="lib/Gui.htm#MarginX">Gui.MarginX</a> und <a href="lib/Gui.htm#MarginY">Gui.MarginY</a>.</p>
<p><strong>Gui Menu</strong> → <a href="lib/Gui.htm#MenuBar">Gui.MenuBar</a> setzt oder gibt ein via <code>MenuBar()</code> erstelltes MenuBar-Objekt zurück.</p>
<p><strong>Gui Cancel/Hide/Minimize/Maximize/Restore</strong> → gleichnamige Gui-Methoden.</p>
<p><strong>Gui Flash</strong> → <a href="lib/Gui.htm#Flash">Gui.Flash()</a>, aber <code>false</code> statt <code>Off</code> verwenden.</p>
<p><strong>Gui Tab</strong> → <a href="lib/GuiControls.htm#Tab_UseTab">GuiControl.UseTab()</a>. Es kann weiterhin ein Tabname angegeben werden, wobei wie früher standardmäßig der Tab verwendet wird, dessen führender Namensteil mit der angegebenen Zeichenkette übereinstimmt. Übergeben Sie True im zweiten Parameter, um zu bewirken, dass die angegebene Zeichenkette eine exakte Übereinstimmung sein muss, aber im Gegensatz zum Exakt-Modus von v1 ist die Suche nicht Groß-/Kleinschreibung-sensitiv.</p>
<h3 id="events">Ereignisse</h3>
<p>Informationen darüber, welche GUI-Ereignisse und GUI-Steuerelement-Ereignisse explizit unterstützt werden, finden Sie unter <a href="lib/GuiOnEvent.htm#Events">Ereignisse (OnEvent)</a>.</p>
<p>Das Size-Ereignis übergibt 0,-1 oder 1 (konsistent mit <a href="lib/WinGetMinMax.htm">WinGetMinMax</a>) statt 0, 1 oder 2.</p>
<p>Das ContextMenu-Ereignis kann für jedes Steuerelement oder für die gesamte GUI registriert werden.</p>
<p>Das DropFiles-Ereignis vertauscht die Parameter <em>DateiArray</em> und <em>Ctrl</em>, um mit ContextMenu konsistent zu sein.</p>
<p>Die Ereignisse ContextMenu und DropFiles verwenden Clientkoordinaten statt Fensterkoordinaten (Client ist auch der standardmäßig verwendete <a href="lib/CoordMode.htm">Koordinatenmodus</a> in v2).</p>
<p>Die folgenden Steuerelementereignisse wurden entfernt, können aber weiterhin durch Übergabe des entsprechenden numerischen Benachrichtigungscodes (definiert im Windows SDK) an <a href="lib/GuiOnNotify.htm">GuiControl.OnNotify()</a> erkannt werden: K, D, d, A, S, s, M, C, E und die MonthCal-Ereignisse 1 und 2.</p>
<p>Steuerelementereignisse übergeben den Ereignisnamen nicht als Parameter (GUI-Ereignisse taten dies nie).</p>
<p>Custom: Die Ereignisse N und Normal wurden mit <a href="lib/GuiOnNotify.htm">GuiControl.OnNotify()</a> und <a href="lib/GuiOnCommand.htm">GuiControl.OnCommand()</a> ersetzt, die für alle Steuerelemente verwendet werden können.</p>
<p>Link: Das Click-Ereignis übergibt "Ctrl, ID oder Index, HREF" statt "Ctrl, Index, HREF oder ID", und führt HREF nicht automatisch aus, wenn eine Click-Rückruffunktion registriert ist.</p>
<p>ListView: Die Ereignisse Click, DoubleClick und ContextMenu (wenn ausgelöst durch einen Rechtsklick) melden nun das angeklickte Element (andernfalls 0), nicht das fokussierte Element.</p>
<p>ListView: Das I-Ereignis wurde in mehrere benannte Ereignisse aufgeteilt, außer f (defokussiert), da es mit F (ItemFocus) erkannt werden kann.</p>
<p>ListView: Das e-Ereignis (ItemEdit) wird ignoriert, wenn der Benutzer das Editieren abbricht.</p>
<p>Slider: Das Change-Ereignis wird konsistenter ausgelöst als das g-Label von v1, d.h. es ignoriert nicht länger standardmäßig Änderungen durch das Mausrad. Einzelheiten finden Sie unter <a href="lib/GuiControls.htm#slider-change">Erkennen von Änderungen (Slider)</a>.</p>
<p>Der BS_NOTIFY-Style wird jetzt bei Bedarf automatisch für Button-, CheckBox- und Radio-Steuerelemente hinzugefügt. Radio-Steuerelemente haben diesen Style standardmäßig nicht mehr.</p>
<p>Focus (ehemals F) und LoseFocus (ehemals f) werden von mehr (aber nicht allen) Steuerelementtypen unterstützt.</p>
<p>Im Gegensatz zu GuiControl, das das g-Label eines Edit-Steuerelements auslöst, wird beim Setzen des Textes eines Edit-Steuerelements mit Edit.Value oder Edit.Text das Change-Ereignis nicht ausgelöst.</p>
<p>LV/TV.Add/Modify unterdrücken jetzt elementverändernde Ereignisse, so dass solche Ereignisse nur durch Benutzeraktion oder SendMessage ausgelöst werden können.</p>
<h3 id="removed">Entfernt</h3>
<p>+Delimiter<br>
+Hwnd<em>AusgabeVar</em>(verwenden Sie stattdessen <a href="lib/Gui.htm#Hwnd">Gui.Hwnd</a> oder <a href="lib/GuiControl.htm#Hwnd">GuiControl.Hwnd</a>)<br>
+Label<br>
+LastFoundExist<br>
Gui GuiName: Default</p>
<h3 id="control-options">Steuerelementoptionen</h3>
<p>+/-Background wird konsistenter interpretiert und unterstützt. Alle Steuerelemente, die "Gui Color" unterstützt haben, unterstützen nun <code>+Background<i>Farbe</i></code> und <code>+BackgroundDefault</code> (synonym mit <code>-Background</code>), nicht nur ListView/TreeView/StatusBar/Progress.</p>
<p><a href="lib/Gui.htm#Add">Gui.Add()</a> verwendet standardmäßig <code>y+m</code>/<code>x+m</code> anstatt <code>yp</code>/<code>xp</code>, wenn <code>xp</code>/<code>yp</code> oder <code>xp+0</code>/<code>yp+0</code> verwendet wird. Mit anderen Worten, das Steuerelement wird unterhalb/rechts vom vorherigen Steuerelement platziert, anstatt auf genau derselben Position. Wenn ein Offset ungleich Null verwendet wird, ist das Verhalten das gleiche wie in v1. Um genau dieselbe Position zu verwenden, geben Sie <code>xp yp</code> gemeinsam an.</p>
<p>Direkt nach <code>x+m</code> und <code>y+m</code> kann optional ein Offset angegeben werden, z.B. <code>x+m+10</code> (<code>x+m10</code> ist auch gültig, aber schlechter lesbar).</p>
<p><code>Choose</code> dient nicht länger als redundante (undokumentierte) Möglichkeit, den Wert für MonthCal anzugeben. Verwenden Sie einfach wie früher den <em>Text</em>-Parameter.</p>
<h3 id="guicontrolget">GuiControlGet</h3>
<h4 id="empty-sub-command">Leerer Unterbefehl</h4>
<p>Der leere Unterbefehl von GuiControlGet hatte zwei Modi: Standardmodus und Textmodus. Für den Textmodus musste das Wort <code>Text</code> im vierten Parameter angegeben werden. Wenn ein Steuerelement keinen "Wert" hatte, gab GuiControlGet standardmäßig das Ergebnis von <a href="https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-getwindowtexta">GetWindowText</a> zurück (was nicht immer sichtbarer Text ist). Einige Steuerelemente hatten keinen sichtbaren Text oder unterstützten dessen Abruf nicht, folglich ignorierten sie den vierten Parameter. <a href="lib/GuiControl.htm#Text">GuiControl.Text</a> gibt hingegen den Anzeigetext, versteckten Text (derselbe Text, den ControlGetText zurückgibt) oder gar nichts zurück.</p>
<p>Die folgende Tabelle zeigt pro Steuerelementtyp die nächstbeste Eigenschaft oder Funktion für beide GuiControlGet-Modi an.</p>
<table class="info">
<tr><th>Steuerelement</th><th>Standard</th><th>Text</th><th>Hinweise</th></tr>
<tr><td>ActiveX</td><td>.Value</td><td>.Text</td><td>Text ist versteckt. Siehe unten.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Text</td><td>ControlGetText()</td><td>Value statt Text verwenden, wenn AltSubmit verwendet wurde (aber Value gibt 0 zurück, wenn Text mit keinem Listenelement übereinstimmt). Text korrigiert die Groß-/Kleinschreibung, während ControlGetText den Inhalt des Eingabefeldes zurückgibt.</td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Text</td><td>Value statt Text verwenden, wenn AltSubmit verwendet wurde.</td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td>.Text</td><td>ControlGetText()</td><td>Value statt Text verwenden, wenn AltSubmit verwendet wurde. Text gibt den Text des ausgewählten Eintrags zurück, während ControlGetText den versteckten Text zurückgibt. Siehe unten.</td></tr>
<tr><td>ListView</td><td colspan="2">.Text</td><td>Text ist versteckt.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Tab</td><td>.Text</td><td>ControlGetText()</td><td>Value statt Text verwenden, wenn AltSubmit verwendet wurde. Text gibt den Text des ausgewählten Tabs zurück, während ControlGetText den versteckten Text zurückgibt.</td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">.Text</td><td>Text ist versteckt.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td></td></tr>
</table>
<p>ListBox: Bei einer Mehrfachauswahl-ListBox gibt Text und Value ein Array statt einer via Vertikalstrich getrennten Liste zurück.</p>
<p>ActiveX: <a href="lib/GuiControl.htm#Value">GuiControl.Value</a> gibt jedes Mal dasselbe Objekt zurück, während GuiControlGet jedes Mal ein neues Wrapper-Objekt erstellt. Folglich ist es nicht mehr notwendig, für eine <a href="lib/ComObjConnect.htm">ComObjConnect</a>-Verbindung eine Referenz zum ActiveX-Objekt aufrechtzuerhalten.</p>
<h4 id="other-sub-commands">Andere Unterbefehle</h4>
<p><strong>Pos</strong> → <a href="lib/GuiControl.htm#GetPos">GuiControl.GetPos()</a></p>
<p><strong>Focus</strong> → <a href="lib/Gui.htm#FocusedCtrl">Gui.FocusedCtrl</a>; gibt ein GuiControl-Objekt anstelle der ClassNN-Bezeichnung zurück.</p>
<p><strong>FocusV</strong> → <code>GuiObj.FocusedCtrl.Name</code></p>
<p><strong>Hwnd</strong> → <a href="lib/GuiControl.htm#Hwnd">GuiControl.Hwnd</a>; gibt einen reinen Integer zurück, keine hexadezimale Zeichenkette.</p>
<p><strong>Enabled/Visible/Name</strong> → gleichnamige GuiCtrl-Eigenschaften.</p>
<h3 id="guicontrol">GuiControl</h3>
<h4 id="blank-and-text-sub-commands">(Leer) und Text-Unterbefehle</h4>
<p>Die folgende Tabelle zeigt pro Steuerelementtyp die nächstbeste Eigenschaft oder Methode für beide GuiControl-Modi an.</p>
<table class="info">
<tr><th>Steuerelement</th><th>(Leer)</th><th>Text</th><th>Hinweise</th></tr>
<tr><td>ActiveX</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>Button</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>CheckBox</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>ComboBox</td><td>.Delete/Add/Choose</td><td>.Text</td><td></td></tr>
<tr><td>Custom</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>DateTime</td><td>.Value</td><td>.SetFormat()</td><td></td></tr>
<tr><td>DDL</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Edit</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>GroupBox</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>Hotkey</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Link</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>ListBox</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>ListView</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>MonthCal</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Picture</td><td colspan="2">.Value</td><td></td></tr>
<tr><td>Progress</td><td colspan="2">.Value</td><td><code>+=</code>-Operator statt <code>+</code>-Präfix verwenden.</td></tr>
<tr><td>Radio</td><td>.Value</td><td>.Text</td><td></td></tr>
<tr><td>Slider</td><td colspan="2">.Value</td><td><code>+=</code>-Operator statt <code>+</code>-Präfix verwenden.</td></tr>
<tr><td>StatusBar</td><td colspan="2">.Text oder SB.SetText()</td><td></td></tr>
<tr><td>Tab</td><td colspan="2">.Delete/Add/Choose</td><td></td></tr>
<tr><td>Text</td><td colspan="2">.Text</td><td></td></tr>
<tr><td>TreeView</td><td colspan="2">N/A</td><td>Befehl war wirkungslos.</td></tr>
<tr><td>UpDown</td><td colspan="2">.Value</td><td><code>+=</code>-Operator statt <code>+</code>-Präfix verwenden.</td></tr>
</table>
<h4 id="other-sub-commands-1">Andere Unterbefehle</h4>
<p><strong>Move</strong> → <a href="lib/GuiControl.htm#Move">GuiControl.Move()</a></p>
<p><strong>MoveDraw</strong> → GuiControl.Move(), <a href="lib/GuiControl.htm#Redraw">GuiControl.Redraw()</a></p>
<p><strong>Focus</strong> → <a href="lib/GuiControl.htm">GuiControl.Focus()</a>, das nun WM_NEXTDLGCTL statt SetFocus verwendet, so dass eine Schaltfläche beim Fokussieren temporär zur Standardschaltfläche gemacht wird, was mit dem Tabben zum Steuerelement konsistent ist.</p>
<p><strong>Enable/Disable</strong> → <a href="lib/GuiControl.htm#Enabled">GuiControl.Enabled</a> setzen</p>
<p><strong>Hide/Show</strong> → <a href="lib/GuiControl.htm#Visible">GuiControl.Visible</a> setzen</p>
<p><strong>Choose</strong> → <a href="lib/GuiControl.htm#Choose">GuiControl.Choose(n)</a>, wobei n ein reiner Integer ist. Der <code>|n</code>- oder <code>||n</code>-Modus wird nicht unterstützt (verwenden Sie stattdessen <a href="lib/ControlChooseIndex.htm">ControlChooseIndex</a>, wenn nötig).</p>
<p><strong>ChooseString</strong> → <a href="lib/GuiControl.htm#Choose">GuiControl.Choose(s)</a>, wobei s kein reiner Integer ist. Der <code>|n</code>- oder <code>||n</code>-Modus wird nicht unterstützt (verwenden Sie stattdessen <a href="lib/ControlChooseString.htm">ControlChooseString</a>, wenn nötig). Wenn die Zeichenkette mit mehreren Einträgen in einer Mehrfachauswahl-ListBox übereinstimmt, wird diese Methode alle gefundenen Einträge auswählen, nicht nur den ersten.</p>
<p><strong>Font</strong> → <a href="lib/GuiControl.htm#SetFont">GuiControl.SetFont()</a></p>
<p><strong>+/-Option</strong> → <a href="lib/GuiControl.htm#Opt">GuiControl.Opt("+/-Option")</a></p>
<h3 id="other-changes">Sonstige Änderungen</h3>
<p>Progress-Gui-Steuerelemente haben nicht mehr standardmäßig den PBS_SMOOTH-Style, d.h. ihr Aussehen richtet sich jetzt nach dem aktuellen Design des Betriebssystems.</p>
<p>Die Standardabstände und Steuerelementgrößen (insbesondere bei Button-Steuerelementen) können leicht von v1 abweichen, wenn DPI größer als 100&nbsp;% ist.</p>
<p>Picture-Steuerelemente löschen ihr aktuelles Bild nicht mehr, wenn das Setzen eines neuen Bildes via <code>GuiCtrl.Value := "neues Bild.png"</code> fehlschlägt. Es ist jedoch erlaubt, das aktuelle Bild mit <code>GuiCtrl.Value := ""</code> zu entfernen.</p>
<p>Der <em>SpalteNummer</em>-Parameter von <a href="lib/ListView.htm#InsertCol">ListView.InsertCol()</a> kann jetzt weggelassen werden, was dasselbe bewirkt wie, als würde man eine Spaltennummer größer als die Anzahl der aktuellen Spalten im Steuerelement angeben.</p>
<h2 id="error-handling">Fehlerbehandlung</h2>
<p><a href="lib/OnError.htm">OnError</a> wird nun bei kritischen Fehlern vor Beendigung des Skripts aufgerufen. Obwohl sich das Skript möglicherweise nicht in einem Zustand befindet, der eine sichere Ausführung zulässt, wird dies versucht, konsistent mit OnExit.</p>
<p>Laufzeitfehler setzen <code>Exception.What</code> nicht mehr auf die gerade ausgeführte benutzerdefinierte Funktion oder Subroutine (obwohl dies immer noch geschieht, wenn <code>Error()</code> ohne den zweiten Parameter aufgerufen wird). Dadurch wird der Zweck von <code>What</code> klarer: Ein Funktionsname weist auf einen Misserfolg dieser Funktion hin (nicht auf einen Misserfolg beim Aufruf der Funktion oder bei der Auswertung ihrer Parameter). <code>What</code> ist leer bei Fehlern bzgl. Ausdrucksauswertung und Kontrollfluss (einige andere können auch leer sein).</p>
<p>Exception-Objekte, die durch Laufzeitfehler ausgelöst werden, können jetzt als Instanzen der neuen Error-Klasse oder einer spezifischeren Unterklasse identifiziert werden. Error-Objekte haben eine <em>Stack</em>-Eigenschaft, die einen Stacktrace enthält. Wenn der <em>What</em>-Parameter den Namen einer laufenden Funktion angibt, werden <em>File</em> und <em>Line</em> nun entsprechend der Zeile gesetzt, die diese Funktion aufgerufen hat.</p>
<p>Die Try-Catch-Syntax wurde geändert, damit das Skript gezielt bestimmte Error-Klassen abfangen kann. Weitere Informationen finden Sie unter <a href="#catch">Catch</a> unten.</p>
<h3 id="continuable-errors">Fortsetzbare Fehler</h3>
<p>In den meisten Fällen bieten die Fehlerdialogfenster jetzt die Möglichkeit, den aktuellen Thread fortzusetzen (anstatt den Thread nur zu beenden). COM-Fehler beenden jetzt den Thread, wenn Sie sich gegen eine Fortsetzung entscheiden (anstatt das komplette Skript zu beenden).</p>
<p>Skripte sollten sich nicht darauf verlassen: Wenn der Fehler von einer internen Funktion ausgelöst wurde, wird beim Fortsetzen ein "" zurückgegeben. Wenn der Fehler vom Ausdrucksevaluator ausgelöst wurde (z.B. bei einer ungültigen dynamischen Referenz oder einer Division durch 0), wird der Ausdruck abgebrochen und "" zurückgegeben (wenn er als Parameter einer Kontrollanweisung verwendet wird).</p>
<p>In einigen Fällen unterstützt der Code keine Fortsetzung; in diesem Fall sollte die Fortsetzungsoption nicht angezeigt werden. Die Option wird auch nicht für kritische Fehler angezeigt, da diese für die Terminierung des Skripts konzipiert sind.</p>
<p><a href="lib/OnError.htm">OnError</a>-Rückruffunktionen akzeptieren jetzt einen zweiten Parameter, der einen der folgenden Werte enthält:</p>
<ul>
<li>Return: Die Rückgabe von -1 setzt den Thread fort, während 0 und 1 wie früher funktionieren.</li>
<li>Exit: Fortsetzung wird nicht unterstützt. Die Rückgabe ungleich Null stoppt weitere Verarbeitung, beendet aber dennoch den Thread.</li>
<li>ExitApp: Dies ist ein kritischer Fehler. Die Rückgabe ungleich Null stoppt weitere Verarbeitung, aber das Skript wird dennoch terminiert.</li>
</ul>
<h3 id="errorlevel">ErrorLevel</h3>
<p>ErrorLevel wurde entfernt. Skripte werden häufig (oder üblicherweise) ohne Fehlerprüfung geschrieben, so dass die ErrorLevel-Setzung bei Fehlern oft unbemerkt blieb. Eine sofortige Fehlermeldung mag ein wenig konfrontativ erscheinen, ist aber in der Regel hilfreicher.</p>
<p>Wo früher ErrorLevel gesetzt wurde, um einen Fehlerzustand anzugeben, wird nun eine Ausnahme mit einer (normalerweise) hilfreicheren Fehlermeldung ausgelöst.</p>
<p>Befehle wie "Process Exist", die mit ErrorLevel einen Wert zurückgegeben haben, geben jetzt einfach diesen Wert (z.B. <code>PID := ProcessExist()</code>) oder etwas Nützlicheres (z.B. <code>HWND := GroupActivate(Gruppe)</code>) zurück.</p>
<p>In einigen Fällen wurde ErrorLevel als sekundärer Rückgabewert verwendet.</p>
<ul>
<li><a href="lib/Sort.htm">Sort</a> mit der U-Option gibt nicht länger die Anzahl der entfernten Duplikate zurück.</li>
<li>Der Input-Befehl wurde entfernt. Es wurde durch InputHook überflüssig gemacht. Mit ein paar Zeilen Code kann ein einfacher Ersatz erstellt werden, der ein InputHook-Objekt mit den Ergebnissen zurückgibt, anstatt ErrorLevel und eine AusgabeVar zu verwenden.</li>
<li><a href="lib/InputBox.htm">InputBox</a> gibt ein Objekt mit der <em>Result</em>- (OK, Cancel oder Timeout) und <em>Value</em>-Eigenschaft zurück.</li>
</ul>
<p>File-Funktionen, die früher die Anzahl der Misserfolge in ErrorLevel gespeichert haben, speichern diese Information nun in die <em>Extra</em>-Eigenschaft des ausgelösten Exception-Objekts.</p>
<p><a href="lib/SendMessage.htm">SendMessage</a>-Timeout (Zeitüberschreitung) ist in der Regel ein anomaler Zustand und bewirkt, dass ein <a href="lib/Error.htm#TimeoutError">TimeoutError</a> ausgelöst wird. <a href="lib/Error.htm#TargetError">TargetError</a> und <a href="lib/Error.htm#OSError">OSError</a> können unter anderen Bedingungen ausgelöst werden.</p>
<p>Der UseErrorLevel-Modus von <a href="lib/Run.htm">Run</a> und <a href="lib/Hotkey.htm">Hotkey</a> wurde entfernt. Dieser Modus wurde eingeführt, als es noch kein <a href="lib/Try.htm">Try</a>/<a href="lib/Catch.htm">Catch</a> gab. Menu und Gui hatten diesen Modus auch, wurden aber durch Objekte ersetzt (die ErrorLevel nicht verwenden).</p>
<h3 id="expressions-1">Ausdrücke (Expressions)</h3>
<p>Es wird ein Ladezeitfehler bei mehr Fehlern als in v1 ausgelöst. Zum Beispiel:</p>
<ul>
<li>Leere runde Klammern (außer neben einem Funktionsnamen), z.B. <code>x ()</code></li>
<li>Präfixoperator auf der falschen Seite oder ohne Operand, z.B. <code>x!</code></li>
<li>Binärer Operator mit weniger als zwei Operanden.</li>
<li>Ternärer Operator mit weniger als drei Operanden.</li>
<li>Zuweisungsziel ist keine beschreibbare Variable oder Eigenschaft.</li>
</ul>
<p>Es wird eine Ausnahme ausgelöst, wenn einer der folgenden Fehler auftritt (anstatt den Fehler zu ignorieren oder eine leere Zeichenkette zu erzeugen):</p>
<ul>
<li>Wenn versucht wird, eine Berechnung mit einem nicht-numerischen Wert durchzuführen. (Numerische Zeichenketten sind zulässig.)</li>
<li>Division durch 0 oder andere ungültige/nicht unterstützte Eingaben wie <code>(-1)**1.5</code>. Beachten Sie, dass einige Fälle jetzt als ungültig erkannt werden, z.B. <code>0**0</code> und <code>a&lt;&lt;b</code> oder <code>a&gt;&gt;b</code>, wobei <em>b</em> außerhalb des Bereichs 0 bis 63 liegt.</li>
<li>Fehler bei der Reservierung von Speicher für den Rückgabewert einer internen Funktion, für eine Verkettung oder für das Ergebnis eines Ausdrucks.</li>
<li>Stackunterlauf (üblicherweise durch einen Syntaxfehler).</li>
<li>Versuch einer Zuweisung an etwas, das keine Variable (oder kein Array-Element) ist.</li>
<li>Versuch einer Zuweisung an eine schreibgeschützte Variable.</li>
<li>Versuch einer Doppeldereferenzierung (double-deref) mit einem leeren Namen, z.B. <code>fn(%leer%)</code>.</li>
<li>Fehler bei der Ausführung eines dynamischen Funktions- oder Methodenaufrufs.</li>
<li>Ein indirekter Methoden-/Eigenschaftsaufruf schlägt fehl, weil der Wert diese Methode/Eigenschaft nicht implementiert. (Bei assoziativen Arrays in v1 kann nur ein Methodenaufruf diesen Fehler verursachen.)</li>
<li>Eine Objektzuweisung schlägt fehl, weil ein Fehler bei der Speicherreservierung aufgetreten ist.</li>
</ul>
<p>Einige der Bedingungen oben werden in v1 erkannt, aber nicht inmitten eines Ausdrucks; zum Beispiel wird <code>A_AhkPath := x</code> in v1 erkannt, während <code>y := x, A_AhkPath := x</code> nur in v2 erkannt werden kann.</p>
<p>Bei separater Verwendung der Operatoren <code>+=</code>, <code>-=</code>, <code>--</code> und <code>++</code> wird eine leere Variable nicht mehr als 0 behandelt. Dies unterscheidet sich von v1, wo sie bei separater Verwendung eine leere Variable als 0 behandelten, aber nicht inmitten eines Ausdrucks oder mit einem Mehrfachanweisungskomma.</p>
<h3 id="functions-1">Funktionen</h3>
<p>Funktionen lösen bei Misserfolg grundsätzlich eine Ausnahme aus. Genauer gesagt:</p>
<ul>
<li>
<p>Fehler durch falsche Verwendung von <a href="lib/DllCall.htm">DllCall</a>, <a href="lib/RegExMatch.htm">RegExMatch</a> und <a href="lib/RegExReplace.htm">RegExReplace</a> kamen aufgrund ihrer Komplexität recht häufig vor und sind (wie viele Fehler) leichter zu erkennen und zu debuggen, wenn sofort eine Fehlermeldung angezeigt wird.</p>
</li>
<li>
<p><a href="lib/Math.htm">Mathematische Funktionen</a> lösen eine Ausnahme aus, wenn einer ihrer Eingabewerte nicht numerisch ist oder eine ungültige Operation (z.B. Division durch 0) versucht wird.</p>
</li>
<li>
<p>Funktionen mit einem <em>FensterTitel</em>-Parameter (mit Ausnahmen, wie z.B. der ahk_group-Modus von <a href="lib/WinClose.htm">WinClose</a>) lösen eine Ausnahme aus, wenn das Zielfenster oder -steuerelement nicht gefunden wird.</p>
</li>
</ul>
<p>Ausnahmen werden für einige Fehler ausgelöst, die früher nicht erkannt wurden, und einige Bedingungen, die fälschlicherweise als Fehler markiert wurden (früher durch ErrorLevel-Setzung), wurden behoben.</p>
<p>Einige Fehlermeldungen wurden geändert.</p>
<h3 id="catch">Catch</h3>
<p>Die Syntax für <a href="lib/Catch.htm">Catch</a> wurde geändert, um die Möglichkeit zu bieten, bestimmte Error-Klassen abzufangen und den Rest gewähren zu lassen (um die Kontrolle an ein anderes Catch weiter oben im Aufrufstapel zu übergeben oder um den Fehler zu melden und den Thread zu beenden). Früher war es erforderlich, geworfene Werte aller Typen abzufangen, den Typ zu überprüfen und dann erneut zu werfen. Zum Beispiel:</p>
<pre><em>; Alt (verwendet veraltete v2.0-a-Regeln zur Veranschaulichung, da v1 kein `is` oder keine Error-Klassen hatte)</em>
try
    SendMessage Mld,,, "Strlmnt1", "Das Fenster"
catch err
    if err is TimeoutError
        MsgBox "Das Fenster reagiert nicht"
    else
        throw err

<em>; Neu</em>
try
    SendMessage Mld,,, "Strlmnt1", "Das Fenster"
catch TimeoutError
    MsgBox "Das Fenster reagiert nicht"
</pre>
<p>Variationen:</p>
<ul>
<li><code>catch</code> fängt eine Error-Instanz ab.</li>
<li><code>catch as err</code> fängt eine Error-Instanz ab, die an err zugewiesen wird.</li>
<li><code>catch ValueError as err</code> fängt eine ValueError-Instanz ab, die an err zugewiesen wird.</li>
<li><code>catch ValueError, TypeError</code> fängt beide Typen ab.</li>
<li><code>catch ValueError, TypeError as err</code> fängt beide Typen ab und weist die Instanz err zu.</li>
<li><code>catch Any</code> fängt alles ab.</li>
<li><code>catch (MeinError as err)</code> erlaubt runde Klammern, wie die meisten anderen Kontrollanweisungen auch.</li>
</ul>
<p>Wenn <em>Try</em> ohne <em>Finally</em> oder <em>Catch</em> verwendet wird, verhält es sich so, als hätte es ein <em>Catch</em> mit leerem Block. Dies klingt wie v1, aber <em>Catch</em> allein fängt jetzt nur noch Instanzen von <a href="lib/Error.htm">Error</a> ab. In den meisten Fällen ist <em>Try</em> allein dazu gedacht, ein Error zu unterdrücken, so dass keine Änderung vorgenommen werden muss. Allerdings ist das direkte v2-Äquivalent von v1 <code>try irgendwas()</code> folgendes:</p>
<pre>try irgendwas()
catch Any
{}
</pre>
<p>Die Priorisierung des Fehlertyps gegenüber dem Namen der Ausgabevariable könnte zu besserem Code ermutigen, d.h. den erwarteten Fehler wie vorgesehen zu behandeln, ohne unerwartete Fehler, die hätten gemeldet werden sollen, zu unterdrücken oder falsch zu behandeln.</p>
<p>Da Werte aller Typen geworfen werden können, ist jede Klasse für den Filter gültig (z.B. <code>String</code> oder <code>Map</code>). Die Klassenprototypen werden jedoch beim Laden des Skripts aufgelöst und müssen als vollständiger Klassenname und nicht als beliebiger Ausdruck angegeben werden (ähnlich wie <code>y</code> in <code>class x extends y</code>).</p>
<p>Während eine <em>Catch</em>-Anweisung ausgeführt wird, kann <code>throw</code> (ohne Parameter) verwendet werden, um die Ausnahme erneut zu werfen (wodurch die Notwendigkeit vermieden wird, eine Ausgabevariable nur für diesen Zweck anzugeben). Dies wird sogar innerhalb einer verschachtelten <em>Try-Finally</em>-Anweisung unterstützt, aber nicht innerhalb einer verschachtelten <em>Try-Catch</em>-Anweisung. Das <code>throw</code> muss nicht physisch im Körper der <em>Catch</em>-Anweisung enthalten sein; sie kann von einer aufgerufenen Funktion verwendet werden.</p>
<p>Ein <a href="lib/Else.htm">Else</a> kann nach dem letzten <em>Catch</em> angegeben werden; es wird ausgeführt, wenn innerhalb von <em>Try</em> keine Ausnahme geworfen wird.</p>
<h2 id="keyboard-mouse-hotkeys-and-hotstrings">Tastatur, Maus, Hotkeys und Hotstrings</h2>
<p>Es sind weniger VK-zu-SC- und SC-zu-VK-Belegungen hartkodiert, was theoretisch die Kompatibilität mit unkonventionellen benutzerdefinierten Tastaturbelegungen verbessert.</p>
<p>Die Tastennamen "Return" und "Break" wurden entfernt. Verwenden Sie stattdessen "Enter" und "Pause".</p>
<p>Die Existenz von <kbd>AltGr</kbd> auf jeder Tastaturbelegung wird jetzt immer durch Lesen des Flags KLLF_ALTGR aus der Tastaturlayout-DLL erkannt. (v1.1.28+ Unicode Builds verwenden diese Methode bereits.) Die Fallback-Methoden zur Erkennung von <kbd>AltGr</kbd> über den Tastatur-Hook wurden entfernt.</p>
<p>Mausrad-Hotkeys setzen <a href="Variables.htm#EventInfo">A_EventInfo</a> auf den vom Maustreiber gemeldeten Delta-Wert, anstatt diesen Wert durch 120 zu teilen. Normalerweise ist dies ein mit 120 multiplizierter Wert, aber einige Maustreiber können Mausraddrehungen in höherer Auflösung melden.</p>
<p>Hotstrings behandeln nun <kbd>Umschalt</kbd>+<kbd>Backspace</kbd> wie <kbd>Backspace</kbd>, anstatt es innerhalb des Hotstring-Puffers in <code>`b</code> zu übersetzen.</p>
<p>Hotstrings verwenden das erste Doppelpunktpaar (<code class="no-highlight">::</code>) als Separator, nicht das letzte, wenn mehrere Doppelpunktpaare vorhanden sind. Mit anderen Worten, in v2 müssen Doppelpunkte (die an einen anderen Doppelpunkt angrenzen) im Auslösetext mit einem Escapezeichen versehen werden, während sie in v1 im Ersatztext mit einem Escapezeichen versehen werden müssen. Beachten Sie, dass früher bei einer ungeraden Anzahl aufeinanderfolgender Doppelpunkte der letzte Doppelpunkt nicht als Teil eines Paares interpretiert wurde. Zum Beispiel gibt es keine Änderung im Verhalten von <code class="no-highlight">::1:::2</code> (<code class="no-highlight">1</code> → <code class="no-highlight">:2</code>), aber <code class="no-highlight">::3::::4</code> ist jetzt <code class="no-highlight">3</code> → <code class="no-highlight">::4</code> statt <code class="no-highlight">3::</code> → <code class="no-highlight">4</code>.</p>
<p>Hotstrings escapen Doppelpunkte nicht mehr paarweise, daher ist es nun möglich, einen einzelnen Doppelpunkt am Ende des Auslösetexts mit einem Escapezeichen zu versehen. Zum Beispiel ist <code class="no-highlight">::5`:::6</code> nun <code class="no-highlight">5:</code> → <code class="no-highlight">6</code> statt eines Fehlers, und <code class="no-highlight">::7`::::8</code> ist nun <code class="no-highlight">7:</code> → <code class="no-highlight">:8</code> statt <code class="no-highlight">7::</code> → <code class="no-highlight">8</code>. In solchen Fällen ist es am besten, alle direkt geschriebenen Doppelpunkte (außer einzelne isolierte Doppelpunkte) mit einem Escapezeichen zu versehen.</p>
<p>Hotstrings mit Fortsetzungsbereichen verwenden nun standardmäßig den Text- statt Raw-Modus.</p>
<p>Hotkeys maskieren die Win/Alt-Taste nur noch beim Loslassen, wenn sie logisch unten ist und der Hotkey die Win/Alt-Taste benötigt (mit <code>#</code>/<code>!</code> oder einem benutzerdefinierten Präfix). Das heißt, dass Hotkeys, die die Win/Alt-Taste nicht benötigen, Win/Alt-Up nicht mehr maskieren, wenn die Win/Alt-Taste physisch unten ist. Dadurch können Hotkeys, die <code>{Blind}{LWin up}</code> senden, das Startmenü aktivieren (dies war bereits mit einer neubelegten Taste wie <code>AppsKey::RWin</code> möglich).</p>
<h2 id="other">Sonstiges</h2>
<p>Die Unterstützung für Windows 2000 und Windows XP wurde eingestellt.</p>
<p>AutoHotkey überschreibt bei der Startphase nicht mehr die Systemeinstellung <code>ForegroundLockTimeout</code>.</p>
<ul>
<li>Dies wurde durch Aufruf von <code>SystemParametersInfo</code> mit der <code>SPI_SETFOREGROUNDLOCKTIMEOUT</code>-Aktion erreicht, die Einfluss auf alle Anwendungen für die aktuelle Benutzersitzung hatte. Diese Einstellung blieb zwar nach dem Abmelden nicht erhalten, war aber dennoch für einige Benutzer unerwünscht.</li>
<li>Fehlerberichte von Benutzern (und einfache Logik) deuten darauf hin, dass, wenn es funktioniert, der Fokus von Programmen gestohlen werden kann, die nicht speziell dafür ausgelegt sind.</li>
<li>Tests unter Windows 10 zeigten, dass es keine Auswirkungen auf irgendetwas hatte; <code>SetForegroundWindow</code>-Aufrufe schlugen immer fehl, und andere von WinActivate angewendete Workarounds waren unabhängig vom Timeout notwendig und aktiv. <code>SPI_GETFOREGROUNDLOCKTIMEOUT</code> wurde von einem separaten Prozess verwendet, um zu verifizieren, ob die Änderung einen Effekt hatte (was manchmal nicht der Fall war).</li>
<li>Dies kann leicht in einem Skript repliziert werden:
<pre>DllCall("SystemParametersInfo", "int", 0x2001, "int", 0, "ptr", 0, "int", 2)</pre>
</li>
</ul>
<p>RegEx-Zeilenumbruchsübereinstimmung verwendet standardmäßig (*ANYCRLF) und (*BSR_ANYCRLF); `r und `n werden zusätzlich zu `r`n erkannt. Die `a-Option aktiviert implizit (*BSR_UNICODE).</p>
<p>RegEx-Callout-Funktionen können nun variadisch sein. Callouts, die über eine <code>pcre_callout</code>-Variable angegeben werden, können beliebige aufrufbare Objekte sein. <code>pcre_callout</code> selbst kann direkt als Funktion (evtl. verschachtelte Funktion) definiert werden. Da die <a href="#scope">Namensräume von Funktionen und Variablen zusammengeführt wurden</a>, kann ein Callout-Muster wie <code>(?C:fn)</code> auch auf eine lokale oder globale Variable verweisen, die ein Funktionsobjekt enthält, nicht nur auf eine benutzerdefinierte Funktion.</p>
<p>Skripte, die von der Standardeingabe (stdin) gelesen werden (z.B. mit <code>AutoHotkey.exe *</code>), fügen das ursprüngliche Arbeitsverzeichnis nicht mehr in <a href="Variables.htm#ScriptFullPath">A_ScriptFullPath</a> oder in den Titel des Hauptfensters ein, aber verwenden es als <a href="Variables.htm#ScriptDir">A_ScriptDir</a> und zum Lokalisieren des lokalen Lib-Ordners.</p>
<p>Einstellungen, die via <a href="Scripts.htm#auto">Auto-Execute-Thread</a> geändert werden, werden jetzt sofort zu Standardeinstellungen gemacht (für Threads, die nach diesem Punkt gestartet werden), nicht erst nach 100&nbsp;ms und dann noch einmal, wenn der Auto-Execute-Thread sein Ende erreicht hat.</p>
<p>Folgende Limitierungen wurden durch Zuhilfenahme dynamischer Speicherreservierungen beseitigt:</p>
<ul>
<li>Maximale Länge einer Zeile oder eines Fortsetzungsbereichs von 16383 Zeichen.</li>
<li>Maximal 512 Token pro Ausdruck (MAX_TOKENS).<br>
Arrays innerhalb des Ausdrucksevaluators, die basierend auf MAX_TOKENS dimensioniert wurden, basieren jetzt auf vorberechneten Schätzungen der erforderlichen Größen; in Sachen Performanz sollten keine Unterschiede feststellbar sein, aber der Stackverbrauch ist in den meisten Fällen etwas geringer. Dies kann die maximale Rekursionstiefe von benutzerdefinierten Funktionen erhöhen.</li>
<li>Maximal 512 Variablen- oder Funktionsreferenzen pro Argument (aber MAX_TOKENS war ohnehin restriktiver für Ausdrücke).</li>
<li>Maximal 255 angegebene Parameterwerte pro Funktionsaufruf (aber MAX_TOKENS war ohnehin restriktiver).</li>
</ul>
<p><a href="lib/ListVars.htm">ListVars</a> zeigt jetzt statische Variablen getrennt von lokalen Variablen an. Globale Variablen, die innerhalb der Funktion deklariert sind, werden ebenfalls als statische Variablen aufgelistet (dies ist ein Nebeneffekt neuer Implementierungsdetails, wird aber beibehalten, da es in Skripten mit vielen globalen Variablen nützlich sein könnte).</p>
<p>Die (undokumentierte?) "lose" Variablenoptimierung wurde entfernt, um Codegröße und Wartungskosten zu reduzieren. Diese Optimierung verbesserte die Performanz von Skripten mit mehr als 100000 Variablen.</p>
<p><a href="Program.htm#tray-icon">Tray-Menü</a>: Das Wort "This" wurde aus "Reload This Script" und "Edit This Script" entfernt, um mit "Pause Script" und den Menüoptionen des Hauptfensters konsistent zu sein.</p>
<p>YYYYMMDDHH24MISS-Zeitstempelwerte werden jetzt als ungültig eingestuft, wenn ihre Länge nicht eine gerade Zahl im Bereich von 4 bis 14 ist.</p>
<h3 id="persistence">Persistenz</h3>
<p>Skripte sind "<a href="lib/Persistent.htm">persistent</a>", wenn mindestens eine der folgenden Bedingungen zutrifft:</p>
<ul>
<li>Mindestens ein Hotkey oder Hotstring wurde im Skript definiert.</li>
<li>Mindestens eine <a href="lib/Gui.htm">Gui</a> (oder das <a href="Program.htm#main-window">Hauptfenster</a> des Skripts) ist sichtbar.</li>
<li>Mindestens ein <a href="lib/SetTimer.htm">Timer</a> ist gerade aktiv.</li>
<li>Mindestens eine <a href="lib/OnClipboardChange.htm">OnClipboardChange</a>-Rückruffunktion wurde gesetzt.</li>
<li>Mindestens ein <a href="lib/InputHook.htm">InputHook</a> ist aktiv.</li>
<li><code>Persistent()</code> oder <code>Persistent(true)</code> wurde aufgerufen und nicht durch Aufruf von <code>Persistent(false)</code> rückgängig gemacht.</li>
</ul>
<p>Wenn eines der folgenden Fälle eintritt und keine der obigen Bedingungen zutrifft, wird das Skript terminiert.</p>
<ul>
<li>Der letzte Skript-Thread endet.</li>
<li>Eine <a href="lib/Gui.htm">Gui</a> wurde geschlossen oder zerstört.</li>
<li>Das <a href="Program.htm#main-window">Hauptfenster</a> des Skripts wurde geschlossen (aber wenn das Fenster zerstört wird, wird das Skript wie früher unabhängig von der Persistenz beendet).</li>
<li>Ein <a href="lib/InputHook.htm">InputHook</a> ohne <a href="lib/InputHook.htm#OnEnd">OnEnd</a>-Rückruffunktion endet.</li>
</ul>
<p>Aus Flexibilitätsgründen macht <a href="lib/OnMessage.htm">OnMessage</a> das Skript nicht automatisch persistent.</p>
<p>v1-Skripte sind hingegen "persistent", wenn mindestens eine der folgenden Bedingungen zutrifft:</p>
<ul>
<li>Mindestens ein Hotkey oder Hotstring wurde im Skript definiert.</li>
<li>Gui oder OnMessage() kommt irgendwo im Skript vor.</li>
<li>Der Tastatur-Hook oder Maus-Hook ist installiert.</li>
<li>Input wird aufgerufen.</li>
<li>#Persistent wurde verwendet.</li>
</ul>
<h3 id="threads">Threads</h3>
<p><a href="misc/Threads.htm">Threads</a> beginnen mit einem unterbrechungsfreien Timeout von 17&nbsp;ms statt 15&nbsp;ms. 15 war zu niedrig, da der systeminterne Taktzähler in Schritten von mindestens 15 oder 16 aktualisiert wurde, d.h. wenn der Taktzähler genau zum falschen Zeitpunkt aktualisiert wurde, konnte der Thread unterbrechbar werden, obwohl praktisch keine Zeit vergangen war.</p>
<p>Threads, die unterbrechungsfrei beginnen, bleiben nun solange bestehen, bis mindestens eine Zeile ausgeführt wurde, auch dann, wenn das unterbrechungsfreie Timeout zuerst abläuft (z.B. wenn das System den Prozess unmittelbar nach dem Start des Threads sperrt, um einem anderen Prozess CPU-Zeit zu geben).</p>
<p><a href="lib/_MaxThreads.htm">#MaxThreads</a> und <a href="lib/_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a> machen keine Ausnahmen mehr für Subroutinen, deren erste Zeile einer der folgenden Befehle ist: <a href="lib/ExitApp.htm">ExitApp</a>, <a href="lib/Pause.htm">Pause</a>, <a href="lib/Edit.htm">Edit</a>, <a href="lib/Reload.htm">Reload</a>, <a href="lib/KeyHistory.htm">KeyHistory</a>, <a href="lib/ListLines.htm">ListLines</a>, <a href="lib/ListVars.htm">ListVars</a> oder <a href="lib/ListHotkeys.htm">ListHotkeys</a>.</p>
<h3 id="default-settings">Standardeinstellungen</h3>
<ul>
<li id="NoEnv">#NoEnv ist das Standardverhalten, daher wurde die Direktive selbst entfernt. Verwenden Sie stattdessen <a href="lib/EnvGet.htm">EnvGet</a>, wenn eine entsprechende interne Variable nicht verfügbar ist.</li>
<li><a href="lib/SendMode.htm">SendMode</a> verwendet standardmäßig Input statt Event.</li>
<li><a href="lib/SetTitleMatchMode.htm">Titelübereinstimmungsmodus</a> verwendet standardmäßig 2 statt 1.</li>
<li id="SetBatchLines">SetBatchLines wurde entfernt, folglich werden alle Skripte mit voller Geschwindigkeit ausgeführt (äquivalent zu SetBatchLines -1 in v1).</li>
<li>Das Arbeitsverzeichnis ist standardmäßig <a href="Variables.htm#ScriptDir">A_ScriptDir</a>. <a href="Variables.htm#InitialWorkingDir">A_InitialWorkingDir</a> enthält das Arbeitsverzeichnis, das vom Prozess, der AutoHotkey gestartet hat, gesetzt wurde.</li>
<li>Standardmäßig verwenden alle Skripte das <a href="lib/_SingleInstance.htm">#SingleInstance</a>-Prompt-Verhalten; #SingleInstance selbst aktiviert den Force-Modus. <code>#SingleInstance Prompt</code> kann auch explizit verwendet werden, um Klarheit zu schaffen oder um eine frühere Direktive zu überschreiben.</li>
<li><a href="lib/CoordMode.htm">CoordMode</a> verwendet standardmäßig Client (verfügbar seit v1.1.05) statt Window.</li>
<li>Die Standardcodepage für Skriptdateien (aber nicht für <em>via Skript</em> gelesene Dateien) ist jetzt UTF-8 statt ANSI (CP0). Dies kann wie früher mit dem Befehlszeilenparameter /CP überschrieben werden.</li>
<li id="MaxMem">#MaxMem wurde entfernt; die Variablenkapazität wird nicht mehr künstlich begrenzt.</li>
</ul>
<h3 id="default-script">Standardskript</h3>
<p>Wenn eine AutoHotkey-Programmdatei (z.B. AutoHotkey32.exe oder AutoHotkey64.exe) ohne Angabe einer Skriptdatei gestartet wird, wird nicht mehr im Ordner "Dokumente" des Benutzers nach einer <a href="Scripts.htm#defaultfile">Standardskriptdatei</a> gesucht.</p>
<p>AutoHotkey ist nicht für den direkten Start der Programmdatei vorgesehen, es sei denn, Sie verwenden eine <a href="Program.htm#portability">portable Kopie</a>. Anstatt die Programmdatei auszuführen, sollten Sie in der Regel <a href="Program.htm#run">eine .ahk-Datei ausführen</a>.</p>
<p>Wenn Sie eine Verknüpfung zu einer bestimmten Programmdatei erstellen, können Sie ein Leerzeichen und den Pfad eines Skripts (normalerweise in Anführungszeichen) an das Ziel der Verknüpfung anfügen.</p>
<h3 id="command-line">Befehlszeile</h3>
<p>Befehlszeilenargumente werden nicht mehr in ein Pseudo-Array nummerierter globaler Variablen gespeichert; verwenden Sie stattdessen die globale Variable <a href="Variables.htm#Args">A_Args</a> (verfügbar seit v1.1.27).</p>
<p>Die Optionen /R und /F wurden entfernt. Verwenden Sie stattdessen /restart und /force.</p>
<p>/validate sollte anstelle von /iLib verwendet werden, wenn ein Skript mit AutoHotkey.exe auf Syntaxfehler geprüft wird, da der Mechanismus zum automatischen Inkludieren von Funktionsbibliotheken entfernt wurde.</p>
<p>/ErrorStdOut wird jetzt in einem der folgenden Fälle als Skriptparameter behandelt, nicht intern:</p>
<ul>
<li>Beim Kompilieren des Skripts, wenn /script nicht verwendet wird.</li>
<li>Wenn es ein Suffix hat, das nicht mit <code>=</code> beginnt (früher wurde das Suffix ignoriert).</li>
</ul>

</body>
</html>
