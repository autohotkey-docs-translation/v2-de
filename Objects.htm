<!DOCTYPE HTML>
<html lang="de">
<head>
<title>Objekte - Definition &amp; Verwendung | AutoHotkey v2</title>
<meta name="description" content="Wie man Objekte verwendet, neue Objekttypen definiert und weitere Einzelheiten darüber, wie Objekte in AutoHotkey funktionieren." />
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="robots" content="noindex, nofollow">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
<script src="static/ga.js" type="text/javascript"></script>
<style>
ul.list_of_p p { margin: 0.5em 0; }
ul.list_of_p li { margin: 1em 0; }
</style>
</head>
<body>

<h1>Objekte</h1>

<p class="warning"><strong>Hinweis:</strong> Diese Seite ist noch in Bearbeitung.</p>

<p>Ein <i>Objekt</i> ist eine Kombination aus <em>Eigenschaften</em> und <a href="Concepts.htm#methods"><em>Methoden</em></a>.</p>
<p>Verwandte Themen:</p>
<ul>
  <li><a href="Concepts.htm#objects">Objekte</a>: Allgemeine Erklärung zu Objekten.</li>
  <li><a href="Concepts.htm#object-protocol">Objektorientierte Schnittstelle</a>: Einzelheiten darüber, wie ein Skript mit einem Objekt interagiert.</li>
  <li><a href="objects/Functor.htm">Funktionsobjekte</a>: Objekte, die <em>aufgerufen</em> werden können.</li>
</ul>

<p>Mit <b>IsObject</b> kann festgestellt werden, ob ein Wert ein Objekt ist:</p>
<pre>Ergebnis := IsObject(<i>Ausdruck</i>)</pre>

<p>Eine Auflistung der verfügbaren Objekttypen finden Sie unter <a href="objects/index.htm">Interne Klassen</a>. Es gibt zwei grundlegende Typen:</p>
<ul>
  <li><strong>AutoHotkey-Objekte</strong> sind Instanzen der <a href="objects/Object.htm">Object</a>-Klasse. Diese unterstützen Ad-hoc-Eigenschaften und -Methoden, und verfügen über Mittel, um herauszufinden, welche Eigenschaften und Methoden existieren. <a href="objects/Array.htm">Array</a>, <a href="objects/Map.htm">Map</a> und alle benutzerdefinierten und internen Klassen werden von Object abgeleitet.</li>
  <li><strong>COM-Objekte</strong>, wie solche, die via <a href="commands/ComObjCreate.htm">ComObjCreate</a> erstellt werden. Diese sind in externen Bibliotheken implementiert und unterscheiden sich daher von AutoHotkey-Objekten in Bezug auf das Verhalten. ComObject repräsentiert typischerweise ein COM- oder "Automation"-Objekt mit einer implementierten <a href="https://docs.microsoft.com/de-de/windows/desktop/api/oaidl/nn-oaidl-idispatch">IDispatch-Schnittstelle</a>. Es wird auch genutzt, um <a href="commands/ComObject.htm">Werte von spezifischen Typen zu wrappen</a>, damit diese an COM-Objekten und Funktionen übergeben werden können.</li>
</ul>

<h2 id="toc">Inhaltsverzeichnis</h2>
<ul>
  <li><a href="#Usage">Grundlegende Verwendung</a> - <a href="#Usage_Simple_Arrays">Arrays</a>, <a href="#Usage_Associative_Arrays">Maps (assoziative Arrays)</a>, <a href="#Usage_Objects">Objekte</a>, <a href="#Usage_Freeing_Objects">Freigeben von Objekten</a></li>
  <li><a href="#Extended_Usage">Erweiterte Verwendung</a> - <a href="#Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</a></li>
  <li><a href="#Custom_Objects">Benutzerdefinierte Objekte</a> - <a href="#creating-a-base-object">Erstellen eines Base-Objekts</a>, <a href="#Custom_Classes">Klassen</a>, <a href="#Custom_NewDelete">Konstruktion und Destruktion</a>, <a href="#Meta_Functions">Metafunktionen</a></li>
  <li><a href="#primitive">Primitive Werte</a></li>
  <li><a href="#Implementation">Implementierung</a> - <a href="#Reference_Counting">Referenzzählung</a>, <a href="#ObjPtr">Objekt-Pointer</a></li>
</ul>

<span id="Syntax"></span><h2 id="Usage">Grundlegende Verwendung</h2>

<h3 id="Usage_Simple_Arrays">Arrays</h3>
<p>Erstellen eines <a href="objects/Array.htm">Arrays</a>:</p>
<pre>MeinArray := [Element1, Element2, ..., ElementN]
MeinArray := Array(Element1, Element2, ..., ElementN)</pre>
<p>Abrufen eines Elements (oder <em>Array-Elements</em>):</p>
<pre>Wert := MeinArray[Index]</pre>
<p>Ändern eines Elementwertes (<code>Index</code> muss zwischen 1 und Länge liegen, oder ein äquivalenter umgekehrter Index):</p>
<pre>MeinArray[Index] := Wert</pre>
<p>Einfügen eines oder mehrerer Elemente ab einem bestimmten Index mittels <a href="objects/Array.htm#InsertAt">InsertAt</a>-Methode:</p>
<pre>MeinArray.InsertAt(Index, Wert, Wert2, ...)</pre>
<p>Anfügen eines oder mehrerer Elemente mittels <a href="objects/Array.htm#Push">Push</a>-Methode:</p>
<pre>MeinArray.Push(Wert, Wert2, ...)</pre>
<p>Entfernen eines Elements mittels <a href="objects/Array.htm#RemoveAt">RemoveAt</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.RemoveAt(Index)</pre>
<p>Entfernen eines Elements mittels <a href="objects/Array.htm#Pop">Pop</a>-Methode:</p>
<pre>EntfernterWert := MeinArray.Pop()</pre>
<p><a href="objects/Array.htm#Length">Length</a> gibt die Anzahl aller Elemente im Array zurück. Um die Inhalte des Arrays zu durchlaufen, erfolgt dies entweder via Index oder mit einer For-Schleife. Zum Beispiel:</p>
<pre>MeinArray := ["eins", "zwei", "drei"]

<em>; Durchläuft das Array von 1 bis zu seinem Ende:</em>
Loop MeinArray.Length
    MsgBox MeinArray[A_Index]

<em>; Enumeriert die Inhalte des Arrays:</em>
For index, wert in MeinArray
    MsgBox "Element " index " ist '" wert "'"
    
<em>; Das Gleiche nochmal:</em>
For wert in MeinArray
    MsgBox "Element " A_Index " ist '" wert "'"
</pre>

<h3 id="Usage_Associative_Arrays">Map-Objekte (Assoziative Arrays)</h3>
<p>Ein <a href="objects/Map.htm">Map</a>-Objekt bzw. assoziatives Array ist ein Objekt, das mehrere eindeutige Keys (Schlüssel) und mehrere Values (Werte) enthält, die jeweils miteinander verbunden sind. Keys können Zeichenketten, Integer oder Objekte sein. Values beliebige Typen. Ein assoziatives Array kann wie folgt erstellt werden:</p>
<pre>MeinMap := Map("KeyA", ValueA, "KeyB", ValueB, ..., "KeyZ", ValueZ)</pre>
<p>Abrufen eines Elements, wo <code>Key</code> eine <a href="Concepts.htm#variables">Variable</a> oder ein <a href="Language.htm#expressions">Ausdruck</a> ist:</p>
<pre>Wert := MeinMap[Key]</pre>
<p>Zuweisen eines Elements:</p>
<pre>MeinMap[Key] := Wert</pre>
<p>Entfernen eines Elements mittels <a href="objects/Array.htm#Delete">Delete</a>-Methode:</p>
<pre>EntfernterWert := MeinMap.Delete(Key)</pre>
<p>Enumerieren von Elementen:</p>
<pre>MeinMap := Map("zehn", 10, "zwanzig", 20, "dreißig", 30)
<a href="commands/For.htm">For</a> key, value in MeinMap
    MsgBox key ' = ' value</pre>

<h3 id="Usage_Objects">Objekte</h3>
<p>Ein Objekt kann <em>Eigenschaften</em>, <em>Methoden</em> und <em>Elemente</em> haben (z. B. Array-Elemente). Der Zugriff auf Elemente erfolgt über <code>[]</code>, wie in den vorherigen Abschnitten gezeigt. Der Zugriff auf Eigenschaften und Methoden erfolgt durch Anfügen eines Punktes und einem Identifikator (einfach ein <a href="Concepts.htm#names">Name</a>).</p>
<p><strong>Beispiele:</strong></p>
<p>Abrufen oder Setzen einer Eigenschaft mit dem direkt geschriebenen Namen <em>Eigenschaft</em>:</p>
<pre>Wert := Objekt.Eigenschaft</pre>
<pre>Objekt.Eigenschaft := Wert</pre>
<p>Abrufen oder Setzen einer Eigenschaft mit einem Namen, der via <a href="Language.htm#expressions">Ausdruck</a> oder <a href="Concepts.htm#variables">Variable</a> ermittelt wird:</p>
<pre>Wert := Objekt.%Ausdruck%</pre>
<pre>Objekt.%Ausdruck% := Wert</pre>
<p>Aufrufen einer Methode mit dem direkt geschriebenen Namen <em>Methode</em>:</p>
<pre>RückgabeWert := Objekt.Methode(Params)</pre>
<p>Aufrufen einer Methode mit einem Namen, der via Ausdruck oder Variable ermittelt wird:</p>
<pre>RückgabeWert := Objekt.%Ausdruck%(Params)</pre>
<p>Einige Eigenschaften können Parameter akzeptieren:</p>
<pre>Wert := Objekt.Eigenschaft[Params]
Objekt.Eigenschaft[Params] := Wert</pre>
<p>Tatsächlich ruft die Array-Indexierungssyntax <code>MeinArray[Index]</code> eigentlich die <a href="#__Item">__Item</a>-Eigenschaft von <code>MeinArray</code> auf und übergibt <code>Index</code> als Parameter.</p>

<h3 id="Usage_Freeing_Objects">Freigeben von Objekten</h3>
<p>Skripte geben Objekte nicht explizit frei. Sobald die letzte Referenz zu einem Objekt freigegeben ist, wird das Objekt automatisch freigegeben. Eine Referenz, die in einer Variable gespeichert ist, wird automatisch freigegeben, wenn diese Variable irgendeinen anderen Wert zugewiesen bekommt. Zum Beispiel:</p>
<pre>obj := {}  <em>; Erstellt ein Objekt.</em>
obj := ""  <em>; Gibt die letzte Referenz frei, wodurch das Objekt freigegeben wird.</em></pre>
<p>Außerdem wird eine Referenz, die in einer Eigenschaft oder einem Array-Element gespeichert ist, freigegeben, wenn diese Eigenschaft oder dieses Array-Element irgendeinen anderen Wert zugewiesen bekommt oder aus dem Objekt entfernt wird.</p>
<pre>arr := [{}]  <em>; Erstellt ein Array, das ein Objekt enthält.</em>
arr[1] := {}  <em>; Erstellt ein zweites Objekt, wodurch das erste Objekt indirekt freigegeben wird.</em>
arr.RemoveAt(1)  <em>; Entfernt und gibt das zweite Objekt frei.</em></pre>
<p id="Circular_References">Da alle Referenzen zu einem Objekt freigegeben werden müssen, bevor das Objekt freigegeben werden kann, können Objekte mit Zirkelbezügen nicht automatisch freigegeben werden. Wenn beispielsweise <code>x.child</code> auf <code>y</code> verweist und <code>y.parent</code> auf <code>x</code> verweist, würde es nicht genügen, <code>x</code> und <code>y</code> zu leeren, weil das Parent-Objekt noch eine Referenz zum Child-Objekt enthält, und umgekehrt. Um diese Situation in den Griff zu bekommen, entfernen Sie den Zirkelbezug.</p>
<pre>
x := {}, y := {}             <em>; Erstellt zwei Objekte.</em>
x.child := y, y.parent := x  <em>; Erstellt ein Zirkelbezug.</em>

y.parent := ""               <em>; Der Zirkelbezug muss entfernt werden, bevor die Objekte freigegeben werden können.</em>
x := "", y := ""             <em>; Wenn die Zeile darüber fehlen würde, könnten die Objekte auf diese Weise nicht freigegeben werden.</em>
</pre>
<p>Für mehr Details, siehe <a href="#Reference_Counting">Referenzzählung</a>.</p>

<h2 id="Extended_Usage">Erweiterte Verwendung</h2>

<h3 id="Usage_Arrays_of_Arrays">Mehrdimensionale Arrays</h3>
<p>Obwohl "mehrdimensionale" Arrays nicht unterstützt werden, kann ein Skript mehrere Arrays oder Maps kombinieren. Zum Beispiel:</p>
<pre>
Gitter := [[1,2,3],
         [4,5,6],
         [7,8,9]]
MsgBox Gitter[1][3] <em>; 3</em>
MsgBox Gitter[3][2] <em>; 8</em>
</pre>
<p id="Array2D">Ein benutzerdefiniertes Objekt kann mehrdimensionale Unterstützung implementieren, indem es eine <a href="#__Item">__Item</a>-Eigenschaft definiert. Zum Beispiel:</p>
<pre>
class Array2D extends Array {
    __new(x, y) {
        this.Länge := x * y
        this.Breite := x
        this.Höhe := y
    }
    __Item[x, y] {
        get =&gt; super[this.Breite * (y-1) + x]
        set =&gt; super[this.Breite * (y-1) + x] := value
    }
}

Gitter := Array2D(4, 3)
Gitter[4, 1] := "#"
Gitter[3, 2] := "#"
Gitter[2, 2] := "#"
Gitter[1, 3] := "#"
Gittertext := ""
Loop Gitter.Höhe {
    y := A_Index
    Loop Gitter.Breite {
        x := A_Index
        Gittertext .= Gitter[x, y] || "-"
    }
    Gittertext .= "`n"
}
MsgBox Gittertext
</pre>
<p>Ein echtes Skript sollte eine Fehlerprüfung durchführen und andere Methoden überschreiben, wie z. B. <a href="#__Enum">__Enum</a>, um die Enumeration zu unterstützen.</p>

<h2 id="Custom_Objects">Benutzerdefinierte Objekte</h2>
<p>Es gibt zwei verschiedene Möglichkeiten, benutzerdefinierte Objekte zu erstellen:</p>
<ul>
  <li><em>Ad hoc</em>: Ein Objekt erstellen und Eigenschaften und Methoden hinzufügen.</li>
  <li><em>Delegation</em>: Eigenschaften und Methoden in einem <em>Base-Objekt</em> oder einer Klasse definieren.</li>
</ul>
<p><a href="#Meta_Functions">Metafunktionen</a> können genutzt werden, um das Verhalten eines Objekts noch genauer zu steuern.</p>
<p class="note"><strong>Hinweis:</strong> In diesem Abschnitt ist ein <em>Objekt</em> eine beliebige Instanz der <a href="objects/Object.htm">Object</a>-Klasse. Dieser Abschnitt gilt nicht für COM-Objekte.</p>

<h3 id="ad-hoc">Ad Hoc</h3>
<p>Ein neues Objekt kann grundsätzlich zu jeder Zeit um Eigenschaften und Methoden erweitert werden. Das folgende Beispiel zeigt, wie ein Objekt mit einer Eigenschaft und einer Methode konstruiert werden kann:</p>
<pre><em>; Erstellt ein Objekt.</em>
obj := {}
<em>; Speichert einen Wert.</em>
obj.foo := "bar"
<em>; Definiert eine Methode.</em>
obj.test := obj_test
<em>; Ruft die Methode auf.</em>
obj.test()

obj_test(this) {
    MsgBox this.foo
}</pre>
<p>Sobald <code>obj.test()</code> aufgerufen wird, wird <i>obj</i> automatisch an den Anfang der Parameterliste gesetzt. Standardmäßig wird der Name der Funktion aus folgenden Komponenten gebildet (aber nicht zwingend notwendig): der "Typ" des Objekts und der Name der Methode.</p>
<p>Siehe auch: <a href="objects/Object.htm#DefineProp">DefineProp</a></p>

<h3 id="delegation">Delegation</h3>
<p>Objekte sind <em>prototypenbasiert</em>. Das heißt, dass alle Eigenschaften oder Methoden, die nicht im Objekt selbst definiert sind, stattdessen im <a href="objects/Object.htm#Base">Base</a> des Objekts definiert werden können. Man bezeichnet dies als <em>Vererbung durch Delegation</em> oder <em>Differenzielle Vererbung</em>, da ein Objekt nur die Teile implementieren kann, die sich vom Objekt unterscheiden, während es den Rest an dessen Base delegiert.</p>
<p>Obwohl ein Base-Objekt gemeinhin auch als Prototyp bekannt ist, verwenden wir den Begriff "<a href="objects/Class.htm#Prototype">Prototyp</a> einer Klasse" für das Objekt, auf dem jede Instanz der Klasse basiert, und "Base" für das Objekt, auf dem eine Instanz basiert.</p>
<p class="note">Das Objektdesign von AutoHotkey wurde hauptsächlich von JavaScript und Lua beeinflusst, und etwas C#. Wir verwenden <code><i>obj</i>.base</code> anstelle von JavaScript's <code><i>obj</i>.__proto__</code> und <code><i>cls</i>.Prototype</code> anstelle von JavaScript's <code><i>func</i>.prototype</code>. (Klassenobjekte werden anstelle von Konstruktorfunktionen verwendet.)</p>

<p>Das Base eines Objekts wird auch verwendet, um dessen Typ oder Klasse zu identifizieren. Zum Beispiel erstellt <code>x := []</code> ein Objekt <em>basierend auf</em> <code>Array.Prototype</code>; das heißt, dass die Ausdrücke <code>x is Array</code> und <code>x.HasBase(Array.Prototype)</code> True sind und <code>type(x)</code> "Array" zurückgibt. Der Protoyp jeder Klasse basiert auf dem Prototyp ihrer Base-Klasse, also ist <code>x.HasBase(Object.Prototype)</code> ebenfalls True.</p>
<p>Es kann eine beliebige Instanz von Object oder eine abgeleitete Klasse ein Base-Objekt sein, allerdings kann ein Objekt nur <a href="objects/Object.htm#Base">als Base</a> eines Objekts mit dem gleichen nativen Typ zugewiesen werden. Auf diese Weise wird sichergestellt, dass interne Methoden immer den nativen Typ eines Objekts identifizieren und nur auf Objekte angewendet werden können, die die richtige binäre Struktur aufweisen.</p>
<p>Base-Objekte können auf zwei verschiedene Arten definiert werden:</p>
<ul>
  <li>Durch <a href="#creating-a-base-object">Erstellen eines normalen Objekts</a>.</li>
  <li>Durch <a href="#Custom_Classes">Definieren einer Klasse</a>. Jede Klasse hat eine <a href="objects/Class.htm#Prototype">Prototype</a>-Eigenschaft, die ein Objekt enthält, auf dem alle Instanzen dieser Klasse basieren, während die Klasse selbst zum Base-Objekt von allen direkten Unterklassen wird.</li>
</ul>
<p>Ein Base-Objekt kann der <a href="objects/Object.htm#Base">Base</a>-Eigenschaft eines anderen Objekts zugewiesen werden, allerdings wird das Base eines Objekts normalerweise beim Erstellen implizit gesetzt.</p>

<h3 id="creating-a-base-object">Erstellen eines Base-Objekts</h3>
<p>Es kann ein beliebiges Objekt als Base eines anderen Objekts verwendet werden, das den gleichen nativen Typ hat. Das folgende Beispiel basiert auf dem vorherigen Beispiel unter <a href="#ad-hoc">Ad Hoc</a> (kombinieren Sie beide vor dem Ausführen):</p>
<pre>anderesObj := {}
anderesObj.base := obj
anderesObj.test()</pre>
<p>In diesem Fall erbt <i>anderesObj</i> das <i>foo</i> und <i>test</i> von <i>obj</i>. Diese Vererbung ist dynamisch - das heißt, wenn <code>obj.foo</code> modifiziert wird, wird <code>anderesObj.foo</code> diese Änderung widerspiegeln. Wenn das Skript <code>anderesObj.foo</code> einen Wert zuweist, wird dieser Wert in <i>anderesObj</i> gespeichert; weitere Änderungen an <code>obj.foo</code> hätten keinen Einfluss auf <code>anderesObj.foo</code>. Sobald <code>anderesObj.test()</code> aufgerufen wird, enthält ihr <i>this</i>-Parameter eine Referenz zu <i>anderesObj</i> statt zu <i>obj</i>.
</p>

<h3 id="Custom_Classes">Klassen</h3>
<blockquote>Unter einer Klasse (auch Objekttyp genannt) versteht man in der objektorientierten Programmierung ein abstraktes Modell bzw. einen Bauplan für eine Reihe von ähnlichen Objekten. <a href="https://de.wikipedia.org/wiki/Klasse_(Objektorientierung)" class="source">Wikipedia</a></blockquote>
<p>Allgemein ausgedrückt ist eine <em>Klasse</em> eine Gruppe oder Kategorie von Dingen, die Eigenschaften oder Attribute gemeinsam nutzen. In AutoHotkey definiert <code>class</code> Eigenschaften und Methoden, die von Instanzen der Klasse gemeinsam genutzt werden sollen. Eine <em>Instanz</em> ist nur ein Objekt, das Eigenschaften und Methoden von der Klasse erbt und typischerweise auch als Teil dieser Klasse verstanden werden kann (z. B. mit dem Ausdruck <code><i>Instanz</i> is <i>KlasseName</i></code>). Instanzen werden typischerweise durch den Aufruf von <a href="objects/Class.htm#Call"><em>KlasseName</em>()</a> erzeugt.</p>
<p>Da ein von <a href="objects/Object.htm">Object</a> abgeleitetes Objekt <a href="#ad-hoc">dynamisch</a> und <a href="#delegation">prototypenbasiert</a> ist, besteht jede Klasse aus zwei Teilen:</p>
<ul>
  <li>Die Klasse hat ein <a href="objects/Class.htm#Prototype">Prototyp</a>-Objekt, auf dem alle Instanzen der Klasse basieren. Alle Methoden und Eigenschaften, die sich auf eine bestimmte Instanz beziehen, sind im Prototypobjekt enthalten. Dazu gehören alle Eigenschaften und Methoden, denen das Schlüsselwort <code>static</code> fehlt.</li>
  <li>Die Klasse selbst ist ein Objekt, das nur statische Methoden und Eigenschaften enthält. Dazu gehören alle Eigenschaften und Methoden mit dem Schlüsselwort <code>static</code> und alle verschachtelten Klassen. Diese gelten nicht für eine bestimmte Instanz und können verwendet werden, indem man via Name auf die Klasse selbst verweist.</li>
</ul>
<p>Das Folgende zeigt die meisten Elemente einer Klassendefinition:</p>
<pre>class KlasseName extends BaseKlasseName
{
    InstanzVar := <i>Ausdruck</i>
    
    static KlasseVar := <i>Ausdruck</i>

    class VerschachtelteKlasse
    {
        ...
    }

    Methode()
    {
        ...
    }
    
    static Methode()
    {
        ...
    }

    Eigenschaft[]  <em>; Die eckigen Klammern sind optional</em>
    {
        <span class="dec">get</span> {
            return <i>Eigenschaftswert</i>
        }
        <span class="dec">set</span> {
            <i>Speichere oder verarbeite</i> <span class="biv">value</span>
        }
    }
    
    KurzeEigenschaft[]
    {
        <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
        <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
    }
    
    KürzereEigenschaft[] =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
}
</pre>
<p>Dies konstruiert, nachdem das Skript geladen wurde, ein <a href="objects/Class.htm">Class</a>-Objekt und speichert es in eine <a href="Functions.htm#Global">globale</a> Konstante (schreibgeschützte Variable) namens <i>KlasseName</i>. Wenn <code>extends BaseKlasseName</code> vorhanden ist, muss der <i>BaseKlasseName</i> der vollständige Name einer anderen Klasse sein. Der vollständige Name jeder Klasse ist in <code><i>KlasseName</i>.Prototype.__Class</code> gespeichert.</p>
<p>Aufgrund der Mehrdeutigkeit zwischen Klassennamen und Variablen kann der Klassenname nicht genutzt werden, um im selben Kontext sowohl die Klasse zu verweisen als auch eine separate Variable zu erstellen (um z. B. eine Instanz der Klasse zu enthalten). Zum Beispiel wird <code>box := Box()</code> nicht funktionieren, weil sowohl <code>box</code> als auch <code>Box</code> in dasselbe aufgelöst werden. Der Versuch, eine Top-Level-Klasse (nicht verschachtelte Klasse) auf diese Weise neu zuzuweisen, führt zu einem Ladezeitfehler.</p>
<p>In dieser Dokumentation bezieht sich das Wort "Klasse" in der Regel auf ein Klassenobjekt, das mit dem Schlüsselwort <code>class</code> erstellt wurde.</p>
<p>Klassendefinitionen können Variablendeklarationen, Methodendefinitionen und Unterklassendefinitionen enthalten.</p>

<h4 id="Custom_Classes_var">Instanzvariablen</h4>
<p>Eine <em>Instanzvariable</em> ist eine Variable, von der jede Instanz der Klasse eine eigene Kopie hat. Sie werden wie normale Zuweisungen deklariert, ohne dass das Präfix <code>this.</code> angegeben werden muss (dies gilt nur in der Klassendefinition):</p>
<pre>InstanzVar := Ausdruck</pre>
<p>Solche Deklarationen werden jedes Mal ausgewertet, wenn eine neue Instanz der Klasse mit <a href="objects/Class.htm#Call"><em>KlasseName</em>()</a> erstellt wird, nachdem alle Base-Klassendeklarationen ausgewertet wurden, aber bevor <a href="#Custom_NewDelete">__New</a> aufgerufen wird. Dies wird erreicht, indem automatisch eine Methode mit dem Namen <em>__Init</em> erstellt wird, die einen Aufruf von <code>super.__Init()</code> enthält, und jede Deklaration in diese eingefügt wird. Daher darf eine einzelne Klassendefinition weder eine __Init-Methode noch eine Instanzvariablendeklaration enthalten.</p>
<p><em>Ausdruck</em> kann mit <code>this</code> auf andere Instanzvariablen und Methoden zugreifen. Globale Variablen können gelesen, aber nicht zugewiesen werden. Eine zusätzliche Zuweisung (oder die Verwendung des <a href="Variables.htm#ref">Referenzoperators</a>) innerhalb des Ausdrucks erzeugt in der Regel eine Variable, die lokal für die __Init-Methode ist. <code>x := y := 1</code> beispielsweise würde <code>this.x</code> und eine lokale Variable <code>y</code> setzen (die wieder freigegeben wird, sobald alle Initialisierungen ausgewertet wurden).</p>
<p>Um Zugriff auf eine Instanzvariable zu erhalten (sogar innerhalb einer Methode), müssen Sie immer das Zielobjekt angeben; zum Beispiel <code><b>this</b>.InstanzVar</code>.</p>
<p>Deklarationen wie <code>x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>x := {}, x.y := 42</code> würde beispielsweise <code>x</code> deklarieren und außerdem <code>this.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_staticvar">Statische bzw. Klassenvariablen</h4>
<p>Statische bzw. Klassenvariablen gehören nur der Klasse selbst, allerdings können ihre Werte von Unterklassen geerbt werden. Solche Variablen müssen mit dem Schlüsselwort "static" deklariert werden:</p>
<pre>static KlasseVar := Ausdruck</pre>
<p>Diese Deklarationen werden nur einmal ausgewertet, während die Klasse initialisiert wird. In dieser AutoHotkey-Version werden Klassen der Reihenfolge nach, wie sie im Skript erscheinen, initialisiert, bevor die <a href="Scripts.htm#auto">Startphase des Skripts</a> erfolgt. Zu diesem Zweck wird automatisch eine statische Methode namens <em>__Init</em> definiert.</p>
<p>Jede Deklaration speichert einen Wert in das Klassenobjekt. <em>Ausdruck</em> wird ähnlich interpretiert wie bei Instanzvariablen, außer dass <code>this</code> auf die Klasse selbst verweist.</p>
<p>Um einer Klassenvariable etwas zuzuweisen, müssen Sie immer das Klassenobjekt angeben; zum Beispiel <code><b>KlasseName</b>.KlasseVar := Wert</code>. Wenn eine Unterklasse keine Eigenschaft mit diesem Namen besitzt, kann <code><i>Unterklasse</i>.KlasseVar</code> auch genutzt werden, um den Wert abzurufen; wenn der Wert eine Referenz zu einem Objekt ist, werden Unterklassen sich dieses Objekt standardmäßig teilen. Allerdings würde <code><i>Unterklasse</i>.KlasseVar := y</code> den Wert nicht in <em>KlasseName</em>, sondern in <em>Unterklasse</em> speichern.</p>
<p>Deklarationen wie <code>static x.y := z</code> werden auch unterstützt, sofern <code>x</code> zuvor in dieser Klasse deklariert wurde. <code>static x := {}, x.y := 42</code> würde beispielsweise <code>x</code> deklarieren und außerdem <code><i>KlasseName</i>.x.y</code> initialisieren.</p>

<h4 id="Custom_Classes_class">Verschachtelte Klassen</h4>
<p>Verschachtelten Klassendefinitionen ermöglichen es, ein Klassenobjekt mit einer statischen Variable/Klassenvariable der äußeren Klasse statt mit einer separaten globalen Variablen zu assoziieren. Im obigen Beispiel konstruiert <code>class VerschachtelteKlasse</code> ein <a href="objects/Class.htm">Class</a>-Objekt und speichert es in <code>KlasseName.VerschachtelteKlasse</code>. Unterklassen können <em>VerschachtelteKlasse</em> erben oder es mit ihrer eigenen verschachtelten Klasse überschreiben (in diesem Fall kann mit <code>(<i>WelcheKlasse</i>.VerschachtelteKlasse)()</code> eine geeignete Klasse instanziiert werden).</p>
<pre>
class VerschachtelteKlasse
{
    ...
}
</pre>
<p>Die Verschachtelung einer Klasse bedeutet nicht, dass eine bestimmte Beziehung zur äußeren Klasse besteht. Die verschachtelte Klasse wird weder automatisch instanziiert, noch haben Instanzen der verschachtelten Klasse eine Verbindung zu einer Instanz der äußeren Klasse, es sei denn, das Skript stellt diese Verbindung explizit her.</p>
<p>Aufgrund der Funktionsweise der Methoden bei <a href="objects/Object.htm">Object</a>-Klassen übergibt <code><i>WelcheKlasse</i>.VerschachtelteKlasse()</code> jedoch implizit <em>WelcheKlasse</em> als ersten Parameter, äquivalent zu <code><i>WelcheKlasse</i>.VerschachtelteKlasse.Call(<i>WelcheKlasse</i>)</code>. Sofern <code>static Call()</code> nicht überschrieben wird, wird dieser Parameter automatisch an <a href="#Custom_NewDelete">__New</a> übergeben.</p>

<h4 id="Custom_Classes_method">Methoden</h4>
<p>Methodendefinitionen sehen genauso aus wie Funktionsdefinitionen. Jede Methode hat einen versteckten Parameter namens <code>this</code>, der eine Referenz zum Objekt enthält, über dem die Klasse aufgerufen wurde. Es gibt zwei Arten von Methoden:</p>
<ul>
  <li>Instanzmethoden sind wie folgt definiert und an den <a href="objects/Class.htm#Prototype">Prototyp</a> der Klasse gekoppelt, wodurch sie über jede Instanz der Klasse zugänglich sind. Wenn die Methode aufgerufen wird, verweist <code>this</code> auf eine Instanz der Klasse.</li>
  <li>Um statische Methoden zu definieren, muss vor dem Methodennamen das separate Schlüsselwort <code>static</code> verwendet werden. Diese sind an das Klassenobjekt selbst gekoppelt, allerdings werden diese auch von Unterklassen geerbt, so dass <code>this</code> entweder auf die Klasse selbst oder auf eine Unterklasse verweist.</li>
</ul>
<pre>
Methode()
{
    ...
}
</pre>

<p>Die <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann genutzt werden, um eine einzeilige Methode für die Rückgabe eines Ausdrucks zu definieren:</p>
<pre>Methode() =&gt; <i>Ausdruck</i></pre>

<h4 id="Custom_Classes_super">Super</h4>
<p>Innerhalb einer Methode oder eines Eigenschaft-Getters/Setters kann das Schlüsselwort <code>super</code> anstelle von <code>this</code> verwendet werden, um auf Superklassen-Versionen von Methoden oder Eigenschaften, die in einer abgeleiteten Klasse überschrieben werden, zugreifen zu können. <code>super.Methode()</code> in der Klasse oben würde beispielsweise bewirken, dass typischerweise eine Version von <em>Methode</em> aufgerufen wird, die innerhalb von <em>BaseKlasseName</em> definiert wurde. Hinweis:</p>
<ul>
  <li><code>super.Methode()</code> ruft immer das Base der Klasse oder des Prototypobjekts auf, das mit der ursprünglichen Definition der aktuellen Methode verknüpft ist, sogar wenn <code>this</code> von einer <em>Unterklasse</em> aus dieser Klasse oder von einer ganz anderen Klasse abgeleitet wurde.</li>
  <li><code>super.Methode()</code> übergibt implizit <code>this</code> als ersten (versteckten) Parameter.</li>
  <li>Da nicht bekannt ist, wo (oder ob) <em>KlasseName</em> innerhalb der Kette von Base-Objekten existiert, wird <em>KlasseName</em> selbst als Ausgangspunkt verwendet. Daher ist <code>super.Methode()</code> meistens äquivalent zu <code>(<i>KlasseName</i>.Prototype.base.Methode)(this)</code> (aber ohne <em>Prototype</em>, wenn <em>Methode</em> statisch ist). Allerdings wird <code><i>KlasseName</i>.Prototype</code> beim Laden des Skripts aufgelöst.</li>
</ul>
<p>Nach dem Schlüsselwort <code>super</code> muss eines der folgenden Symbole erfolgen: <code>.[(</code></p>
<p><code>super()</code> ist äquivalent zu <code>super.call()</code>.</p>

<h4 id="Custom_Classes_property">Eigenschaften</h4>
<p>Eine Eigenschaftsdefinition erzeugt eine <a href="objects/Object.htm#DefineProp">dynamische Eigenschaft</a>, die eine Methode aufruft, anstatt einfach einen Wert zu speichern oder zurückzugeben.</p>
<pre>Eigenschaft[]  <em>; Die eckigen Klammern sind optional</em>
{
    <span class="dec">get</span> {
        return <i>Eigenschaftswert</i>
    }
    <span class="dec">set</span> {
        <i>Speichere oder verarbeite</i> <span class="biv">value</span>
    }
}
</pre>
<p><em>Eigenschaft</em> ist der Name der Eigenschaft, mit dem sie aufgerufen werden kann. <code>obj.Eigenschaft</code> würde beispielsweise <em>get</em> aufrufen, und <code>obj.Eigenschaft := Wert</code> würde <em>set</em> aufrufen. Innerhalb von <em>get</em> oder <em>set</em> bezieht sich <code>this</code> auf das Objekt, das aufgerufen wird. Innerhalb von <em>set</em> enthält <code>value</code> den Wert, der zugewiesen wird.</p>
<p>Die Definition und Übergabe von Parametern erfolgt auf der rechten Seite des Eigenschaftsnamens, in eckigen Klammern. Abgesehen von den eckigen Klammern werden Eigenschaftsparameter genauso wie Methodenparameter definiert - optionale, variadische und ByRef-Parameter werden unterstützt.</p>
<p>Wenn eine Eigenschaft keine Parameter akzeptieren kann (die eckigen Klammern werden weggelassen oder sind leer), werden Parameter automatisch an die <a href="#__Item">__Item</a>-Eigenschaft des von <em>get</em> zurückgegebenen Objekts weitergeleitet. <code>this.Eigenschaft[x]</code> beispielsweise hätte die gleiche Wirkung wie <code>(this.Eigenschaft)[x]</code> oder <code>y := this.Eigenschaft, y[x]</code>.</p>
<p>Um statische Eigenschaften zu definieren, muss vor dem Eigenschaftsnamen das separate Schlüsselwort <code>static</code> verwendet werden. In diesem Fall verweist <code>this</code> auf die Klasse selbst oder eine Unterklasse.</p>
<p>Der Rückgabewert von <em>set</em> wird ignoriert. <code>Wert := obj.Eigenschaft := 42</code> beispielsweise wird immer <code>Wert := 42</code> zuweisen, egal was die Eigenschaft macht, es sei denn, sie löst eine Ausnahme aus oder beendet den Thread.</p>
<p>Jede Klasse kann eine oder beide Hälften einer Eigenschaft definieren. Wenn eine Klasse eine Eigenschaft überschreibt, kann sie <code><a href="#Custom_Classes_super">super.Eigenschaft</a></code> benutzen, um auf die via eigene Base-Klasse definierte Eigenschaft zugreifen zu können. Wenn <em>Get</em> oder <em>Set</em> nicht definiert ist, kann es von einem Base-Objekt geerbt werden. Wenn <em>Get</em> undefiniert ist, kann die Eigenschaft einen Wert zurückgeben, der von einem Base geerbt wurde. Wenn <em>Set</em> in diesem und allen Base-Objekten undefiniert ist (oder von einer geerbten Werteigenschaft verschleiert wird), führt der Versuch, die Eigenschaft zu setzen, zum Auslösen einer Ausnahme.</p>
<p>Intern sind <em>get</em> und <em>set</em> zwei unterschiedliche Methoden, die sich untereinander keine Variablen teilen können (es sei denn, man speichert sie in <code>this</code>).</p>
<p>Siehe auch: <a href="objects/Object.htm#DefineProp">DefineProp</a></p>
<p><a href="#Meta_Functions">Metafunktionen</a> bieten eine breitere Auswahl an Möglichkeiten für den kontrollierten Zugriff auf Eigenschaften und Methoden eines Objekts, allerdings sind sie komplizierter und fehleranfälliger.</p>

<h4 id="Custom_Classes_property_short">Fat-Arrow-Eigenschaften</h4>
<p>Die <a href="Variables.htm#fat-arrow">Fat-Arrow-Syntax</a> kann genutzt werden, um einen <a href="#Custom_Classes_property">Eigenschaft</a>-Getter oder -Setter für die Rückgabe eines Ausdrucks zu definieren:</p>
<pre>KurzeEigenschaft[]
{
    <span class="dec">get</span> =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i>
    <span class="dec">set</span> =&gt; <i>Ausdruck zum Speichern oder Verarbeiten von</i> <span class="biv">value</span>
}</pre>
<p>Wenn man nur einen Getter definiert, können die geschweiften Klammern und <code>get</code> weggelassen werden:</p>
<pre>KürzereEigenschaft[] =&gt; <i>Ausdruck zum Ermitteln des Eigenschaftswertes</i></pre>

<h3 id="__Enum">__Enum-Methode</h3>
<pre class="Syntax">__Enum(AnzahlVars)</pre>
<p>Die __Enum-Methode wird aufgerufen, wenn das Objekt an eine <a href="commands/For.htm">For-Schleife</a> übergeben wird. Diese Methode sollte einen <a href="objects/Enumerator.htm">Enumerator</a> zurückgeben, der Elemente im Objekt, wie z. B. Array-Elemente, zurückgeben wird. Wenn es undefiniert bleibt, kann das Objekt nicht direkt an eine For-Schleife übergeben werden, es sei denn, es hat eine <a href="objects/Enumerator.htm#Call">Enumerator-kompatible Call-Methode</a>.</p>
<p><em>AnzahlVars</em> enthält die Anzahl der Variablen, die an die For-Schleife übergeben wurden. Wenn <em>AnzahlVars</em> 2 ist, wird erwartet, dass der Enumerator dem ersten Parameter den Key oder Index eines Elements und dem zweiten Parameter den Wert zuweist. Jeder Key oder Index sollte als Parameter der <a href="#__Item">__Item</a>-Eigenschaft akzeptiert werden. Dadurch können <a href="AHKL_DBGPClients.htm">DBGp-basierte Debugger</a> ein bestimmtes Element abrufen oder setzen, nachdem sie via Enumerator aufgelistet wurden.</p>

<h3 id="__Item">__Item-Eigenschaft</h3>
<p>Die __Item-Eigenschaft wird indirekt aufgerufen, wenn der Indexierungsoperator (Array-Syntax) in Verbindung mit dem Objekt verwendet wird. Im folgenden Beispiel wird die Eigenschaft als statisch deklariert, so dass der Indexierungsoperator bei der Env-Klasse selbst angewendet werden kann. Ein weiteres Beispiel finden Sie unter <a href="#Array2D">Array2D</a>.</p>
<pre>class Env {
    static __Item[name] {
        get =&gt; EnvGet(name)
        set =&gt; EnvSet(name, value)
    }
}

Env["PATH"] .= ";" A_ScriptDir  <em>; Hat nur Einfluss auf dieses Skript und Unterprozesse.</em>
MsgBox Env["PATH"]</pre>
<p><code>__Item</code> ist quasi ein Standardeigenschaftsname (wenn so eine Eigenschaft definiert wurde):</p>
<ul>
  <li><code><i>object</i>[<i>params</i>]</code> ist äquivalent zu <code><i>object</i>.__Item[<i>params</i>]</code>, wenn Parameter vorhanden sind.</li>
  <li><code><i>object</i>[]</code> ist äquivalent zu <code><i>object</i>.__Item</code>.</li>
</ul>
<p>Zum Beispiel:</p>
<pre>
obj := {}
obj[] := Map()     <em>; Äquivalent zu obj.__Item := Map()</em>
obj["base"] := 10
MsgBox obj.base = Object.prototype  <em>; True</em>
MsgBox obj["base"]                  <em>; 10</em>
</pre>
<p class="note"><strong>Hinweis:</strong> Wenn ein expliziter Eigenschaftsname mit leeren eckigen Klammern kombiniert wird, wie in <code>obj.prop[]</code>, wird dies als zwei separate Operationen behandelt: zuerst wird <code>obj.prop</code> abgerufen, danach indirekt die Standardeigenschaft des Ergebnisses aufgerufen. Dies ist Bestandteil der Sprachsyntax und somit objektunabhängig.</p>

<h3 id="Custom_NewDelete">Konstruktion und Destruktion</h3>
<p>Jedes Mal, wenn ein Objekt mit der Standardimplementierung von <a href="objects/Class.htm#Call"><em>KlasseName</em>()</a> erstellt wird, wird die <code>__New</code>-Methode des neuen Objekts aufgerufen, um eine benutzerdefinierte Initialisierung zu ermöglichen. Alle Parameter, die an <code><i>KlasseName</i>()</code> übergeben werden, werden an <code>__New</code> weitergeleitet, so dass sie den ursprünglichen Inhalt des Objekts oder die Art und Weise, wie es konstruiert ist, beeinflussen können. Zerstört man ein Objekt, wird <code>__Delete</code> aufgerufen. Zum Beispiel:</p>
<pre>m1 := GMem(0, 10)
m2 := {base: GMem.Prototype}, m2.__New(0, 30)

<em>; Hinweis: Für allgemeine Speicherreservierungen sollten Sie stattdessen <a href="commands/BufferAlloc.htm">BufferAlloc</a>() verwenden.</em>
class GMem<span id="GMem"></span>
{
    __New(aFlags, aGröße)
    {
        this.ptr := DllCall("GlobalAlloc", "UInt", aFlags, "Ptr", aGröße, "Ptr")
        if !this.ptr
            throw Exception("Nicht genug Speicher")
        MsgBox "New GMem mit einer Größe von " aGröße " Bytes auf der Adresse " this.ptr "."
    }

    __Delete()
    {
        MsgBox "Delete GMem auf der Adresse " this.ptr "."
        DllCall("GlobalFree", "Ptr", this.ptr)
    }
}</pre>
<p>__Delete wird nicht bei Objekten aufgerufen, die eine Eigenschaft namens "__Class" besitzen. <a href="objects/Class.htm#Prototype">Prototypobjekte</a> haben standardmäßig diese Eigenschaft.</p>
<p>Wenn eine Ausnahme oder ein Laufzeitfehler ausgelöst wird, während __Delete ausgeführt wird, und nicht innerhalb von __Delete behandelt wird, verhält es sich so, als wäre __Delete von einem neuen <a href="misc/Threads.htm">Thread</a> aufgerufen wurden. Das heißt, dass ein Fehlerdialogfenster angezeigt und __Delete durchgeführt wird, aber der Thread nicht beendet wird (es sei denn, er wurde bereits beendet).</p>
<p>Jede Klasse kann auch eine <code>static __New</code>-Methode haben, die unmittelbar nach Initialisierung ihrer <a href="#Custom_Classes_staticvar">statischen Variablen</a> aufgerufen wird (dies geschieht der Reihenfolge nach, wie die Klassen im Skript definiert sind). Diese Methode kann von einer Base-Klasse geerbt und daher zum Initialisieren von Unterklassen verwendet werden. Innerhalb von <code>static __New</code> verweist <code>this</code> entweder auf die Klasse, die die Methode definiert hat, oder auf eine Unterklasse.</p>

<h3 id="Meta_Functions">Metafunktionen</h3>
<pre class="Syntax">
class <i>KlasseName</i> {
    __Get(Name, Params)
    __Set(Name, Params, Wert)
    __Call(Name, Params)
}
</pre>
<dl>
  <dt>Name</dt>
  <dd><p>Der Name der Eigenschaft oder Methode.</p></dd>
  <dt>Params</dt>
  <dd><p>Ein <a href="objects/Array.htm">Array</a> mit Parametern. Dazu gehören nur die Parameter zwischen <code>()</code> oder <code>[]</code>, die also leer sein können. Die Metafunktion soll Fälle wie <code>x.y[z]</code> behandeln, in denen <code>x.y</code> nicht definiert ist.</p></dd>
  <dt>Wert</dt>
  <dd><p>Der Wert, der zugewiesen wird.</p></dd>
</dl>
<p>Metafunktionen definieren, was passieren soll, wenn eine undefinierte Eigenschaft oder Methode aufgerufen wird. Wenn <code>obj.unk</code> beispielsweise keinen Wert zugewiesen bekommen hat, wird die <i>__Get</i>-Metafunktion aufgerufen. <code>obj.unk := value</code> veranlasst hingegen den Aufruf von <i>__Set</i> und <code>obj.unk()</code> den Aufruf von <i>__Call</i>.</p>
<p>Eigenschaften und Methoden können im Objekt selbst oder in einem seiner <a href="#delegation">Base-Objekte</a> definiert werden. Damit für jede Eigenschaft eine Metafunktion aufgerufen werden kann, sollten Sie grundsätzlich vermeiden, irgendwelche Eigenschaften zu definieren. Interne Eigenschaften wie <a href="objects/Object.htm#Base">Base</a> können mit einer <a href="#Custom_Classes_property">Eigenschaftsdefinition</a> oder <a href="objects/Object.htm#DefineProp">DefineProp</a> überschrieben werden.</p>
<p>Wenn eine Metafunktion definiert ist, muss sie die gewünschte Standardaktion ausführen. Zum Beispiel kann Folgendes erwartet werden:</p>
<ul>
  <li><i>Call</i>: Löse einen <a href="objects/Error.htm#MethodError">MethodError</a> aus.</li>
  <li>Wenn Parameter angegeben wurden, löse eine Ausnahme aus (es gibt kein Objekt, an das die Parameter weitergeleitet werden können).</li>
  <li><i>Get</i>: Löse einen <a href="objects/Error.htm#PropertyError">PropertyError</a> aus.</li>
  <li><i>Set</i>: Definiere eine neue Eigenschaft mit dem angegebenen Wert, z. B. durch Aufruf von <a href="objects/Object.htm#DefineProp">DefineProp</a>. </li>
</ul>
<p>Es kann ein beliebiges <a href="objects/Functor.htm">aufrufbares Objekt</a> als Metafunktion verwendet werden, wenn man es der entsprechenden Eigenschaft zuweist.</p>
<p>Metafunktionen werden in den folgenden Fällen nicht aufgerufen:</p>
<ul>
  <li><code>x[y]</code>: Die Verwendung von eckigen Klammern ohne Eigenschaftsnamen ruft nur die <a href="#__Item">__Item</a>-Eigenschaft auf.</li>
  <li><code>x()</code>: Der Aufruf des Objekts selbst ruft nur die <code>Call</code>-Methode auf. Dazu gehören interne Aufrufe von internen Funktionen wie <a href="commands/SetTimer.htm">SetTimer</a> und <a href="commands/Hotkey.htm">Hotkey</a>.</li>
  <li>Interne Aufrufe von anderen Metafunktionen oder Doppel-Unterstrich-Methoden lösen <code>__Call</code> nicht aus.</li>
</ul>

<h4 id="Dynamic_Properties">Dynamische Eigenschaften</h4>
<p>Mit der <a href="#Custom_Classes_property">Eigenschaftssyntax</a> und <a href="objects/Object.htm#DefineProp">DefineProp</a> können Eigenschaften definiert werden, die jedes Mal, wenn sie ausgewertet werden, einen Wert berechnen, allerdings muss jede Eigenschaft im Voraus definiert sein. Mit <em>__Get</em> und <em>__Set</em> können hingegen Eigenschaften implementiert werden, die erst zum Zeitpunkt ihres Aufrufs bekannt sind.</p>
<p>Zum Beispiel kann ein "Proxy-Objekt" mit Eigenschaften erstellt werden, die den aktuellen Wert über das Netzwerk (oder über einen anderen Kanal) abfragen. Ein Remote-Server sendet eine Antwort zurück, die den Wert der Eigenschaft enthält, und das Proxy-Objekt übergibt den Wert an seinen Aufrufer. Auch wenn der Name jeder Eigenschaft im Voraus bekannt war, wäre es unlogisch, jede Eigenschaft einzeln in der Proxy-Klasse zu definieren, da jede Eigenschaft dasselbe tun würde (eine Netzwerkanfrage senden). Metafunktionen bekommen den Namen der Eigenschaft als Parameter, demzufolge sind sie eine gute Lösung für dieses Problem.</p>

<h2 id="primitive">Primitive Werte</h2>
<p>Primitive Werte, wie Zeichenketten und Zahlen, können keine eigenen Eigenschaften und Methoden haben. Allerdings unterstützen primitive Werte die gleiche Art von <a href="#delegation">Delegation</a> wie Objekte. Das heißt, dass jede Eigenschaft oder Methode, die einen primitiven Wert aufruft, an ein vordefiniertes Prototypobjekt delegiert wird, das auch über die <a href="objects/Class.htm#Prototype">Prototype</a>-Eigenschaft der entsprechenden Klasse zugänglich ist. Die folgenden Klassen beziehen sich auf primitive Werte:</p>
<ul style="line-height: 1.5">
  <li>Primitive (extends <a href="objects/Any.htm">Any</a>) <ul style="padding-left: 1.7em">
    <li>Number <ul style="padding-left: 1.7em">
      <li>Float</li>
      <li>Integer</li>
    </ul></li>
    <li>String</li>
  </ul></li>
</ul>
<p>Obwohl die Überprüfung der <a href="commands/Type.htm">Type</a>-Zeichenkette in der Regel schneller ist, kann der Typ eines Wertes getestet werden, indem überprüft wird, ob der Wert ein Base hat. <code>n.HasBase(Number.Prototype)</code> oder <code>n is Number</code> beispielsweise ist True, wenn <em>n</em> ein reiner Integer oder eine reine Floating-Point-Zahl ist, aber False, wenn <em>n</em> eine numerische Zeichenkette ist, da String nicht von Number ableitet. <code>IsNumber(n)</code> hingegen ist True, wenn <em>n</em> eine Zahl oder numerische Zeichenkette ist.</p>
<p><a href="objects/Any.htm#GetBase">ObjGetBase</a> und die <a href="objects/Any.htm#Base">Base</a>-Eigenschaft geben eines der vordefinierten Prototypobjekte zurück, wenn es angebracht ist.</p>
<p>Beachten Sie, dass <code>x is Any</code> normalerweise für jeden Wert innerhalb der Typenhierarchie von AutoHotkey True, aber für COM-Objekte False ist.</p>

<h3 id="primitive-extension">Hinzufügen von Eigenschaften und Methoden</h3>
<p>Eigenschaften und Methoden können für alle Werte eines bestimmten Typs hinzugefügt werden, indem das Prototypobjekt dieses Typs geändert wird. Da aber ein primitiver Wert kein Object-Objekt ist und keine eigenen Eigenschaften oder Methoden haben kann, können die primitiven Prototypobjekte nicht von <code>Object.Prototype</code> ableiten. Mit anderen Worten sind Methoden wie <a href="objects/Object.htm#DefineProp">DefineProp</a> und <a href="objects/Object.htm#HasOwnProp">HasOwnProp</a> standardmäßig nicht zugänglich. Diese können indirekt aufgerufen werden. Zum Beispiel:</p>
<pre>
DefProp := {}.DefineProp
DefProp( "".base, "Length", { get: StrLen } )
MsgBox A_AhkPath.length " == " StrLen(A_AhkPath)
</pre>
<p>Obwohl primitive Werte Werteigenschaften von ihrem Prototyp erben können, wird eine Ausnahme ausgelöst, wenn das Skript versucht, eine Werteigenschaft auf einen primitiven Wert zu setzen. Zum Beispiel:</p>
<pre>"".base.test := 1  <em>; Bitte nicht nachmachen.</em>
MsgBox "".test  <em>; 1</em>
"".test := 2  <em>; Fehler: Eigenschaft ist schreibgeschützt.</em></pre>
<p>Obwohl __Set- und Eigenschaft-Setter genutzt werden können, sind sie nicht nützlich, da primitive Werte als unveränderlich zu betrachten sind.</p>

<h2 id="Implementation">Implementierung</h2>
<span id="Refs"></span><h3 id="Reference_Counting">Referenzzählung</h3>
<p>AutoHotkey verwendet einen einfachen Referenzzählungsmechanismus, um automatisch Ressourcen freizugeben, falls ein Objekt nicht länger in einem Skript benötigt bzw. verwiesen wird. Skript-Autoren sollten diesen Mechanismus nicht explizit aufrufen, es sei denn, sie müssen sich direkt mit unverwalteten <a href="#ObjPtr">Objekt-Pointern</a> befassen.</p>
<p>Temporär zurückgegebene Referenzen von Funktionen, Methoden oder Operatoren innerhalb eines Ausdrucks werden erst freigegeben, wenn die Auswertung dieses Ausdrucks abgeschlossen oder abgebrochen wurde. Im folgenden Beispiel wird das neue <a href="#GMem">GMem</a>-Objekt erst nach Durchführung von MsgBox freigegeben:</p>
<pre>MsgBox <a href="commands/DllCall.htm">DllCall</a>("GlobalSize", "ptr", GMem(0, 20).ptr, "ptr")  <em>; 20</em></pre>
<p class="note"><strong>Hinweis:</strong> In diesem Beispiel kann <code>.ptr</code> auch weggelassen werden, da der <a href="commands/DllCall.htm#ptr">Ptr</a>-Argumenttyp Objekte mit einer <code>Ptr</code>-Eigenschaft zulässt. Allerdings funktioniert das oben gezeigte Muster auch mit anderen Eigenschaftsnamen.</p>
<p>Um eine Aktion nach Freigabe der letzten Referenz zu einem Objekt durchzuführen, implementieren Sie die <a href="#Custom_NewDelete">__Delete</a>-Metafunktion.</p>
<p><b>Bekannte Einschränkungen:</b></p>
<ul>
  <li>Zirkelbezüge müssen unterbrochen werden, bevor ein Objekt freigegeben werden kann. Siehe <a href="#Circular_References">Freigeben von Objekten</a>, um anhand eines Beispiels mehr darüber zu erfahren.</li>
  <li>Im Gegensatz zu Referenzen in statischen und globalen Variablen werden Referenzen in nicht-statischen lokalen Variablen oder im Ausdrucksauswertungsstapel nicht automatisch freigegeben, sobald das Programm beendet wird. Solche Referenzen werden nur freigegeben, wenn die Funktion oder der Ausdruck regulär beendet werden kann.</li>
</ul>
<p>Obwohl das Betriebssystem den vom Objekt benutzten Speicher zurückfordert, sobald das Programm beendet wird, kann <a href="#Custom_NewDelete">__Delete</a> erst aufgerufen werden, wenn alle Referenzen zum Objekt freigegeben worden sind. Das kann wichtig sein, wenn andere Ressourcen freigegeben werden, die nicht automatisch vom Betriebssystem zurückgefordert werden, wie zum Beispiel temporäre Dateien.</p>

<h3 id="ObjPtr">Objekt-Pointer</h3>
<p>In einigen seltenen Fällen ist es eventuell erforderlich, dass ein Objekt via DllCall an einen externen Code übergeben werden muss, oder dass ein Objekt in eine binäre Datenstruktur gespeichert werden muss, damit es später abgerufen werden kann. Die Adresse eines Objekts kann via <code>Adresse := ObjPtr(meinObjekt)</code> abgerufen werden; dies würde allerdings effektiv zwei Referenzen zum Objekt erzeugen, während das Programm selbst nur die eine Referenz in <em>meinObjekt</em> kennt. Das Objekt wird gelöscht, sobald die letzte <em>bekannte</em> Referenz zum Objekt freigegeben wird. Demzufolge muss das Skript das Objekt darüber informieren, dass es eine Referenz erhalten hat. Dies kann man wie folgt erreichen (die folgenden zwei Zeilen sind äquivalent):</p>
<pre>
ObjAddRef(Adresse := ObjPtr(meinObjekt))
Adresse := ObjPtrAddRef(meinObjekt)
</pre>
<p>Außerdem muss das Objekt informiert werden, wenn das Skript mit dieser Referenz fertig ist:</p>
<pre>ObjRelease(Adresse)</pre>
<p>Generell sollte jede neue Kopie einer Objektadresse als separate Referenz zum Objekt behandelt werden, demzufolge sollte das Skript ObjAddRef aufrufen, wenn es eine Kopie erhält, und sofort ObjRelease aufrufen, bevor es eine verliert. Zum Beispiel sollte immer ObjAddRef aufgerufen werden, wenn eine Adresse mit so etwas wie <code>x := Adresse</code> kopiert wird. Ebenso sollte das Skript ObjRelease aufrufen, wenn es mit <em>x</em> fertig ist (oder dabei ist den Wert von <em>x</em> zu überschreiben).</p>
<p id="ObjFromPtr">Mit der ObjFromPtr-Funktion kann eine Adresse in eine geeignete Referenz umgewandelt werden:</p>
<pre>meinObjekt := ObjFromPtr(Adresse)</pre>
<p>ObjFromPtr geht davon aus, dass <em>Adresse</em> eine gezählte Referenz ist, und nimmt sie in Besitz. Mit anderen Worten, <code>meinObjekt := ""</code> würde bewirken, dass die Referenz, ursprünglich repräsentiert von <em>Adresse</em>, freigegeben wird. Danach muss <em>Adresse</em> als ungültig betrachtet werden. Um stattdessen eine neue Referenz zu erstellen, verwenden Sie eine der folgenden Möglichkeiten:</p>
<pre>
ObjAddRef(Adresse), meinObjekt := ObjFromPtr(Adresse)
meinObjekt := ObjFromPtrAddRef(Adresse)
</pre>

</body>
</html>
